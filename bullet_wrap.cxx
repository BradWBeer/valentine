/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.11
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

#define SWIGCFFI


#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#  ifndef GCC_HASCLASSVISIBILITY
#    define GCC_HASCLASSVISIBILITY
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif




#ifdef __cplusplus
#  define EXTERN   extern "C"
#else
#  define EXTERN   extern
#endif

#define EXPORT   EXTERN SWIGEXPORT

#include <string.h>



#ifdef __cplusplus
#  define EXTERN   extern "C"
#else
#  define EXTERN   extern
#endif

#define EXPORT   EXTERN SWIGEXPORT

#include <string.h>
#include <stdlib.h>


#include <BulletSoftBody/btSoftBody.h>
#include <BulletSoftBody/btSoftBodyHelpers.h>
#include <BulletSoftBody/btSoftRigidDynamicsWorld.h>
#include <BulletSoftBody/btSoftBodyRigidBodyCollisionConfiguration.h>
#include <BulletSoftBody/btDefaultSoftBodySolver.h>
#include <btBulletDynamicsCommon.h>
  

  typedef btSoftBody::Element Element;
  typedef btSoftBody::Material Material;
  typedef btSoftBody::Feature Feature;
  typedef btSoftBody::Config Config;
  typedef btSoftBody::Node Node;
  typedef btSoftBody::fCollision fCollision;
  
EXPORT int _wrap_btGetVersion () {
  int lresult = (int)0 ;
  int result;
  
  try {
    result = (int)btGetVersion();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btGetInfinityMask () {
  int lresult = (int)0 ;
  int result;
  
  try {
    result = (int)btGetInfinityMask();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btScalar _wrap_btSqrt (btScalar larg1) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)btSqrt(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btFabs (btScalar larg1) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)btFabs(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btCos (btScalar larg1) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)btCos(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSin (btScalar larg1) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)btSin(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btTan (btScalar larg1) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)btTan(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAcos (btScalar larg1) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)btAcos(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAsin (btScalar larg1) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)btAsin(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAtan (btScalar larg1) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)btAtan(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAtan2 (btScalar larg1, btScalar larg2) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)btAtan2(arg1,arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btExp (btScalar larg1) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)btExp(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btLog (btScalar larg1) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)btLog(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btPow (btScalar larg1, btScalar larg2) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)btPow(arg1,arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btFmod (btScalar larg1, btScalar larg2) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)btFmod(arg1,arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAtan2Fast (btScalar larg1, btScalar larg2) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)btAtan2Fast(arg1,arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btFuzzyZero (btScalar larg1) {
  int lresult = (int)0 ;
  btScalar arg1 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)btFuzzyZero(arg1);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btEqual (btScalar larg1, btScalar larg2) {
  int lresult = (int)0 ;
  btScalar arg1 ;
  btScalar arg2 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)btEqual(arg1,arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btGreaterEqual (btScalar larg1, btScalar larg2) {
  int lresult = (int)0 ;
  btScalar arg1 ;
  btScalar arg2 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)btGreaterEqual(arg1,arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btIsNegative (btScalar larg1) {
  int lresult = (int)0 ;
  btScalar arg1 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)btIsNegative(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btScalar _wrap_btRadians (btScalar larg1) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)btRadians(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btDegrees (btScalar larg1) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)btDegrees(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btFsel (btScalar larg1, btScalar larg2, btScalar larg3) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)btFsel(arg1,arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btMachineIsLittleEndian () {
  int lresult = (int)0 ;
  bool result;
  
  try {
    result = (bool)btMachineIsLittleEndian();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT unsigned int _wrap_btSelect__SWIG_0 (unsigned int larg1, unsigned int larg2, unsigned int larg3) {
  unsigned int lresult = (unsigned int)0 ;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  unsigned int result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (unsigned int)btSelect(arg1,arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (unsigned int)0;
  }
}


EXPORT int _wrap_btSelect__SWIG_1 (unsigned int larg1, int larg2, int larg3) {
  int lresult = (int)0 ;
  unsigned int arg1 ;
  int arg2 ;
  int arg3 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (int)btSelect(arg1,arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT float _wrap_btSelect__SWIG_2 (unsigned int larg1, float larg2, float larg3) {
  float lresult = (float)0 ;
  unsigned int arg1 ;
  float arg2 ;
  float arg3 ;
  float result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (float)btSelect(arg1,arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (float)0;
  }
}


EXPORT unsigned int _wrap_btSwapEndian__SWIG_0 (unsigned int larg1) {
  unsigned int lresult = (unsigned int)0 ;
  unsigned int arg1 ;
  unsigned int result;
  
  arg1 = larg1;
  try {
    result = (unsigned int)btSwapEndian(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (unsigned int)0;
  }
}


EXPORT unsigned short _wrap_btSwapEndian__SWIG_1 (unsigned short larg1) {
  unsigned short lresult = (unsigned short)0 ;
  unsigned short arg1 ;
  unsigned short result;
  
  arg1 = larg1;
  try {
    result = (unsigned short)btSwapEndian(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (unsigned short)0;
  }
}


EXPORT unsigned int _wrap_btSwapEndian__SWIG_2 (int larg1) {
  unsigned int lresult = (unsigned int)0 ;
  int arg1 ;
  unsigned int result;
  
  arg1 = larg1;
  try {
    result = (unsigned int)btSwapEndian(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (unsigned int)0;
  }
}


EXPORT unsigned short _wrap_btSwapEndian__SWIG_3 (short larg1) {
  unsigned short lresult = (unsigned short)0 ;
  short arg1 ;
  unsigned short result;
  
  arg1 = larg1;
  try {
    result = (unsigned short)btSwapEndian(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (unsigned short)0;
  }
}


EXPORT unsigned int _wrap_btSwapEndianFloat (float larg1) {
  unsigned int lresult = (unsigned int)0 ;
  float arg1 ;
  unsigned int result;
  
  arg1 = larg1;
  try {
    result = (unsigned int)btSwapEndianFloat(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (unsigned int)0;
  }
}


EXPORT float _wrap_btUnswapEndianFloat (unsigned int larg1) {
  float lresult = (float)0 ;
  unsigned int arg1 ;
  float result;
  
  arg1 = larg1;
  try {
    result = (float)btUnswapEndianFloat(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (float)0;
  }
}


EXPORT void _wrap_btSwapEndianDouble (double larg1, unsigned char *larg2) {
  double arg1 ;
  unsigned char *arg2 = (unsigned char *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    btSwapEndianDouble(arg1,arg2);
    
  } catch (...) {
    
  }
}


EXPORT double _wrap_btUnswapEndianDouble (unsigned char *larg1) {
  double lresult = (double)0 ;
  unsigned char *arg1 = (unsigned char *) 0 ;
  double result;
  
  arg1 = larg1;
  try {
    result = (double)btUnswapEndianDouble((unsigned char const *)arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (double)0;
  }
}


EXPORT btScalar _wrap_btLargeDot (btScalar *larg1, btScalar *larg2, int larg3) {
  btScalar lresult = (btScalar)0 ;
  btScalar *arg1 = (btScalar *) 0 ;
  btScalar *arg2 = (btScalar *) 0 ;
  int arg3 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)btLargeDot((float const *)arg1,(float const *)arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btNormalizeAngle (btScalar larg1) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)btNormalizeAngle(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btVector3_m_floats_set (btVector3 *larg1, btScalar *larg2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      size_t ii;
      btScalar *b = (btScalar *) arg1->m_floats;
      for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((btScalar *) arg2 + ii);
    }
    
  } catch (...) {
    
  }
}


EXPORT btScalar *_wrap_btVector3_m_floats_get (btVector3 *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *)(btScalar *) ((arg1)->m_floats);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT btVector3 *_wrap_new_btVector3__SWIG_0 () {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *result = 0 ;
  
  try {
    result = (btVector3 *)new btVector3();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_new_btVector3__SWIG_1 (btScalar *larg1, btScalar *larg2, btScalar *larg3) {
  btVector3 * lresult = (btVector3 *)0 ;
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btVector3 *)new btVector3((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btVector3___add_assign__ (btVector3 *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btVector3 *) &(arg1)->operator +=((btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btVector3___sub_assign__ (btVector3 *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btVector3 *) &(arg1)->operator -=((btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btVector3___mul_assign____SWIG_0 (btVector3 *larg1, btScalar *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *arg2 = 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btVector3 *) &(arg1)->operator *=((btScalar const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btVector3___div_assign__ (btVector3 *larg1, btScalar *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *arg2 = 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btVector3 *) &(arg1)->operator /=((btScalar const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btScalar _wrap_btVector3_dot (btVector3 *larg1, btVector3 *larg2) {
  btScalar lresult = (btScalar)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btVector3 const *)arg1)->dot((btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btVector3_length2 (btVector3 *larg1) {
  btScalar lresult = (btScalar)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btVector3 const *)arg1)->length2();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btVector3_length (btVector3 *larg1) {
  btScalar lresult = (btScalar)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btVector3 const *)arg1)->length();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btVector3_norm (btVector3 *larg1) {
  btScalar lresult = (btScalar)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btVector3 const *)arg1)->norm();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btVector3_distance2 (btVector3 *larg1, btVector3 *larg2) {
  btScalar lresult = (btScalar)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btVector3 const *)arg1)->distance2((btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btVector3_distance (btVector3 *larg1, btVector3 *larg2) {
  btScalar lresult = (btScalar)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btVector3 const *)arg1)->distance((btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btVector3 *_wrap_btVector3_safeNormalize (btVector3 *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &(arg1)->safeNormalize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btVector3_normalize (btVector3 *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &(arg1)->normalize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btVector3_normalized (btVector3 *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  try {
    result = ((btVector3 const *)arg1)->normalized();
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btVector3_rotate (btVector3 *larg1, btVector3 *larg2, btScalar larg3) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = ((btVector3 const *)arg1)->rotate((btVector3 const &)*arg2,arg3);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btScalar _wrap_btVector3_angle (btVector3 *larg1, btVector3 *larg2) {
  btScalar lresult = (btScalar)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btVector3 const *)arg1)->angle((btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btVector3 *_wrap_btVector3_absolute (btVector3 *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  try {
    result = ((btVector3 const *)arg1)->absolute();
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btVector3_cross (btVector3 *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btVector3 const *)arg1)->cross((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btScalar _wrap_btVector3_triple (btVector3 *larg1, btVector3 *larg2, btVector3 *larg3) {
  btScalar lresult = (btScalar)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)((btVector3 const *)arg1)->triple((btVector3 const &)*arg2,(btVector3 const &)*arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btVector3_minAxis (btVector3 *larg1) {
  int lresult = (int)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btVector3 const *)arg1)->minAxis();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btVector3_maxAxis (btVector3 *larg1) {
  int lresult = (int)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btVector3 const *)arg1)->maxAxis();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btVector3_furthestAxis (btVector3 *larg1) {
  int lresult = (int)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btVector3 const *)arg1)->furthestAxis();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btVector3_closestAxis (btVector3 *larg1) {
  int lresult = (int)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btVector3 const *)arg1)->closestAxis();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btVector3_setInterpolate3 (btVector3 *larg1, btVector3 *larg2, btVector3 *larg3, btScalar larg4) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setInterpolate3((btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btVector3_lerp (btVector3 *larg1, btVector3 *larg2, btScalar *larg3) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = ((btVector3 const *)arg1)->lerp((btVector3 const &)*arg2,(btScalar const &)*arg3);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btVector3___mul_assign____SWIG_1 (btVector3 *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btVector3 *) &(arg1)->operator *=((btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btScalar *_wrap_btVector3_getX (btVector3 *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btVector3 const *)arg1)->getX();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT btScalar *_wrap_btVector3_getY (btVector3 *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btVector3 const *)arg1)->getY();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT btScalar *_wrap_btVector3_getZ (btVector3 *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btVector3 const *)arg1)->getZ();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT void _wrap_btVector3_setX (btVector3 *larg1, btScalar larg2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setX(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btVector3_setY (btVector3 *larg1, btScalar larg2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setY(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btVector3_setZ (btVector3 *larg1, btScalar larg2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setZ(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btVector3_setW (btVector3 *larg1, btScalar larg2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setW(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar *_wrap_btVector3_x (btVector3 *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btVector3 const *)arg1)->x();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT btScalar *_wrap_btVector3_y (btVector3 *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btVector3 const *)arg1)->y();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT btScalar *_wrap_btVector3_z (btVector3 *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btVector3 const *)arg1)->z();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT btScalar *_wrap_btVector3_w (btVector3 *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btVector3 const *)arg1)->w();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT int _wrap_btVector3___eq__ (btVector3 *larg1, btVector3 *larg2) {
  int lresult = (int)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)((btVector3 const *)arg1)->operator ==((btVector3 const &)*arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btVector3___ne__ (btVector3 *larg1, btVector3 *larg2) {
  int lresult = (int)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)((btVector3 const *)arg1)->operator !=((btVector3 const &)*arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btVector3_setMax (btVector3 *larg1, btVector3 *larg2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMax((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btVector3_setMin (btVector3 *larg1, btVector3 *larg2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMin((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btVector3_setValue (btVector3 *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setValue((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btVector3_getSkewSymmetricMatrix (btVector3 *larg1, btVector3 *larg2, btVector3 *larg3, btVector3 *larg4) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  btVector3 *arg4 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btVector3 const *)arg1)->getSkewSymmetricMatrix(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btVector3_setZero (btVector3 *larg1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->setZero();
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btVector3_isZero (btVector3 *larg1) {
  int lresult = (int)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btVector3 const *)arg1)->isZero();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btVector3_fuzzyZero (btVector3 *larg1) {
  int lresult = (int)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btVector3 const *)arg1)->fuzzyZero();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btVector3_serialize (btVector3 *larg1, btVector3FloatData *larg2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3FloatData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btVector3 const *)arg1)->serialize(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btVector3_deSerialize (btVector3 *larg1, btVector3FloatData *larg2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3FloatData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->deSerialize((btVector3FloatData const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btVector3_serializeFloat (btVector3 *larg1, btVector3FloatData *larg2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3FloatData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btVector3 const *)arg1)->serializeFloat(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btVector3_deSerializeFloat (btVector3 *larg1, btVector3FloatData *larg2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3FloatData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->deSerializeFloat((btVector3FloatData const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btVector3_serializeDouble (btVector3 *larg1, btVector3DoubleData *larg2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3DoubleData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btVector3 const *)arg1)->serializeDouble(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btVector3_deSerializeDouble (btVector3 *larg1, btVector3DoubleData *larg2) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3DoubleData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->deSerializeDouble((btVector3DoubleData const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT long _wrap_btVector3_maxDot (btVector3 *larg1, btVector3 *larg2, long larg3, btScalar *larg4) {
  long lresult = (long)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  long arg3 ;
  btScalar *arg4 = 0 ;
  long result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (long)((btVector3 const *)arg1)->maxDot((btVector3 const *)arg2,arg3,*arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (long)0;
  }
}


EXPORT long _wrap_btVector3_minDot (btVector3 *larg1, btVector3 *larg2, long larg3, btScalar *larg4) {
  long lresult = (long)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  long arg3 ;
  btScalar *arg4 = 0 ;
  long result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (long)((btVector3 const *)arg1)->minDot((btVector3 const *)arg2,arg3,*arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (long)0;
  }
}


EXPORT btVector3 *_wrap_btVector3_dot3 (btVector3 *larg1, btVector3 *larg2, btVector3 *larg3, btVector3 *larg4) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = ((btVector3 const *)arg1)->dot3((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_delete_btVector3 (btVector3 *larg1) {
  btVector3 *arg1 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btDot (btVector3 *larg1, btVector3 *larg2) {
  btScalar lresult = (btScalar)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)btDot((btVector3 const &)*arg1,(btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btDistance2 (btVector3 *larg1, btVector3 *larg2) {
  btScalar lresult = (btScalar)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)btDistance2((btVector3 const &)*arg1,(btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btDistance (btVector3 *larg1, btVector3 *larg2) {
  btScalar lresult = (btScalar)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)btDistance((btVector3 const &)*arg1,(btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAngle__SWIG_0 (btVector3 *larg1, btVector3 *larg2) {
  btScalar lresult = (btScalar)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)btAngle((btVector3 const &)*arg1,(btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btVector3 *_wrap_btCross (btVector3 *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = btCross((btVector3 const &)*arg1,(btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btScalar _wrap_btTriple (btVector3 *larg1, btVector3 *larg2, btVector3 *larg3) {
  btScalar lresult = (btScalar)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)btTriple((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btVector3 *_wrap_lerp (btVector3 *larg1, btVector3 *larg2, btScalar *larg3) {
  btVector3 * lresult = (btVector3 *)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = lerp((btVector3 const &)*arg1,(btVector3 const &)*arg2,(float const &)*arg3);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector4 *_wrap_new_btVector4__SWIG_0 () {
  btVector4 * lresult = (btVector4 *)0 ;
  btVector4 *result = 0 ;
  
  try {
    result = (btVector4 *)new btVector4();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector4 *)0;
  }
}


EXPORT btVector4 *_wrap_new_btVector4__SWIG_1 (btScalar *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4) {
  btVector4 * lresult = (btVector4 *)0 ;
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btVector4 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btVector4 *)new btVector4((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector4 *)0;
  }
}


EXPORT btVector4 *_wrap_btVector4_absolute4 (btVector4 *larg1) {
  btVector4 * lresult = (btVector4 *)0 ;
  btVector4 *arg1 = (btVector4 *) 0 ;
  btVector4 result;
  
  arg1 = larg1;
  try {
    result = ((btVector4 const *)arg1)->absolute4();
    lresult = new btVector4(result);
    return lresult;
  } catch (...) {
    return (btVector4 *)0;
  }
}


EXPORT btScalar _wrap_btVector4_getW (btVector4 *larg1) {
  btScalar lresult = (btScalar)0 ;
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btVector4 const *)arg1)->getW();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btVector4_maxAxis4 (btVector4 *larg1) {
  int lresult = (int)0 ;
  btVector4 *arg1 = (btVector4 *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btVector4 const *)arg1)->maxAxis4();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btVector4_minAxis4 (btVector4 *larg1) {
  int lresult = (int)0 ;
  btVector4 *arg1 = (btVector4 *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btVector4 const *)arg1)->minAxis4();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btVector4_closestAxis4 (btVector4 *larg1) {
  int lresult = (int)0 ;
  btVector4 *arg1 = (btVector4 *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btVector4 const *)arg1)->closestAxis4();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btVector4_setValue (btVector4 *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4, btScalar *larg5) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->setValue((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4,(btScalar const &)*arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btVector4 (btVector4 *larg1) {
  btVector4 *arg1 = (btVector4 *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSwapScalarEndian (btScalar *larg1, btScalar *larg2) {
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    btSwapScalarEndian((float const &)*arg1,*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSwapVector3Endian (btVector3 *larg1, btVector3 *larg2) {
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    btSwapVector3Endian((btVector3 const &)*arg1,*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btUnSwapVector3Endian (btVector3 *larg1) {
  btVector3 *arg1 = 0 ;
  
  arg1 = larg1;
  try {
    btUnSwapVector3Endian(*arg1);
    
  } catch (...) {
    
  }
}


EXPORT btScalar *_wrap_btQuadWord_getX (btQuadWord *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btQuadWord const *)arg1)->getX();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT btScalar *_wrap_btQuadWord_getY (btQuadWord *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btQuadWord const *)arg1)->getY();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT btScalar *_wrap_btQuadWord_getZ (btQuadWord *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btQuadWord const *)arg1)->getZ();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT void _wrap_btQuadWord_setX (btQuadWord *larg1, btScalar larg2) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setX(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btQuadWord_setY (btQuadWord *larg1, btScalar larg2) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setY(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btQuadWord_setZ (btQuadWord *larg1, btScalar larg2) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setZ(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btQuadWord_setW (btQuadWord *larg1, btScalar larg2) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setW(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar *_wrap_btQuadWord_x (btQuadWord *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btQuadWord const *)arg1)->x();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT btScalar *_wrap_btQuadWord_y (btQuadWord *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btQuadWord const *)arg1)->y();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT btScalar *_wrap_btQuadWord_z (btQuadWord *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btQuadWord const *)arg1)->z();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT btScalar *_wrap_btQuadWord_w (btQuadWord *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btQuadWord const *)arg1)->w();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT int _wrap_btQuadWord___eq__ (btQuadWord *larg1, btQuadWord *larg2) {
  int lresult = (int)0 ;
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btQuadWord *arg2 = 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)((btQuadWord const *)arg1)->operator ==((btQuadWord const &)*arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btQuadWord___ne__ (btQuadWord *larg1, btQuadWord *larg2) {
  int lresult = (int)0 ;
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btQuadWord *arg2 = 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)((btQuadWord const *)arg1)->operator !=((btQuadWord const &)*arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btQuadWord_setValue__SWIG_0 (btQuadWord *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setValue((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btQuadWord_setValue__SWIG_1 (btQuadWord *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4, btScalar *larg5) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->setValue((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4,(btScalar const &)*arg5);
    
  } catch (...) {
    
  }
}


EXPORT btQuadWord *_wrap_new_btQuadWord__SWIG_0 () {
  btQuadWord * lresult = (btQuadWord *)0 ;
  btQuadWord *result = 0 ;
  
  try {
    result = (btQuadWord *)new btQuadWord();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuadWord *)0;
  }
}


EXPORT btQuadWord *_wrap_new_btQuadWord__SWIG_1 (btScalar *larg1, btScalar *larg2, btScalar *larg3) {
  btQuadWord * lresult = (btQuadWord *)0 ;
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btQuadWord *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btQuadWord *)new btQuadWord((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuadWord *)0;
  }
}


EXPORT btQuadWord *_wrap_new_btQuadWord__SWIG_2 (btScalar *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4) {
  btQuadWord * lresult = (btQuadWord *)0 ;
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btQuadWord *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btQuadWord *)new btQuadWord((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuadWord *)0;
  }
}


EXPORT void _wrap_btQuadWord_setMax (btQuadWord *larg1, btQuadWord *larg2) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btQuadWord *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMax((btQuadWord const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btQuadWord_setMin (btQuadWord *larg1, btQuadWord *larg2) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  btQuadWord *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMin((btQuadWord const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btQuadWord (btQuadWord *larg1) {
  btQuadWord *arg1 = (btQuadWord *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btQuaternion *_wrap_new_btQuaternion__SWIG_0 () {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *result = 0 ;
  
  try {
    result = (btQuaternion *)new btQuaternion();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_new_btQuaternion__SWIG_1 (btScalar *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btQuaternion *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btQuaternion *)new btQuaternion((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_new_btQuaternion__SWIG_2 (btVector3 *larg1, btScalar *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btVector3 *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btQuaternion *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btQuaternion *)new btQuaternion((btVector3 const &)*arg1,(btScalar const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_new_btQuaternion__SWIG_3 (btScalar *larg1, btScalar *larg2, btScalar *larg3) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btQuaternion *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btQuaternion *)new btQuaternion((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT void _wrap_btQuaternion_setRotation (btQuaternion *larg1, btVector3 *larg2, btScalar *larg3) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setRotation((btVector3 const &)*arg2,(btScalar const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btQuaternion_setEuler (btQuaternion *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setEuler((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btQuaternion_setEulerZYX (btQuaternion *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setEulerZYX((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT btQuaternion *_wrap_btQuaternion___add_assign__ (btQuaternion *larg1, btQuaternion *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btQuaternion *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btQuaternion *) &(arg1)->operator +=((btQuaternion const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion___sub_assign__ (btQuaternion *larg1, btQuaternion *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btQuaternion *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btQuaternion *) &(arg1)->operator -=((btQuaternion const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion___mul_assign____SWIG_0 (btQuaternion *larg1, btScalar *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *arg2 = 0 ;
  btQuaternion *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btQuaternion *) &(arg1)->operator *=((btScalar const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion___mul_assign____SWIG_1 (btQuaternion *larg1, btQuaternion *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btQuaternion *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btQuaternion *) &(arg1)->operator *=((btQuaternion const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btScalar _wrap_btQuaternion_dot (btQuaternion *larg1, btQuaternion *larg2) {
  btScalar lresult = (btScalar)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btQuaternion const *)arg1)->dot((btQuaternion const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btQuaternion_length2 (btQuaternion *larg1) {
  btScalar lresult = (btScalar)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btQuaternion const *)arg1)->length2();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btQuaternion_length (btQuaternion *larg1) {
  btScalar lresult = (btScalar)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btQuaternion const *)arg1)->length();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion_normalize (btQuaternion *larg1) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btQuaternion *) &(arg1)->normalize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion___mul__ (btQuaternion *larg1, btScalar *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *arg2 = 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btQuaternion const *)arg1)->operator *((btScalar const &)*arg2);
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion___div__ (btQuaternion *larg1, btScalar *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *arg2 = 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btQuaternion const *)arg1)->operator /((btScalar const &)*arg2);
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion___div_assign__ (btQuaternion *larg1, btScalar *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *arg2 = 0 ;
  btQuaternion *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btQuaternion *) &(arg1)->operator /=((btScalar const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion_normalized (btQuaternion *larg1) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  try {
    result = ((btQuaternion const *)arg1)->normalized();
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btScalar _wrap_btQuaternion_angle (btQuaternion *larg1, btQuaternion *larg2) {
  btScalar lresult = (btScalar)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btQuaternion const *)arg1)->angle((btQuaternion const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btQuaternion_angleShortestPath (btQuaternion *larg1, btQuaternion *larg2) {
  btScalar lresult = (btScalar)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btQuaternion const *)arg1)->angleShortestPath((btQuaternion const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btQuaternion_getAngle (btQuaternion *larg1) {
  btScalar lresult = (btScalar)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btQuaternion const *)arg1)->getAngle();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btQuaternion_getAngleShortestPath (btQuaternion *larg1) {
  btScalar lresult = (btScalar)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btQuaternion const *)arg1)->getAngleShortestPath();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btVector3 *_wrap_btQuaternion_getAxis (btQuaternion *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  try {
    result = ((btQuaternion const *)arg1)->getAxis();
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion_inverse (btQuaternion *larg1) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  try {
    result = ((btQuaternion const *)arg1)->inverse();
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion___add__ (btQuaternion *larg1, btQuaternion *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btQuaternion const *)arg1)->operator +((btQuaternion const &)*arg2);
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion___sub__ (btQuaternion *larg1, btQuaternion *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btQuaternion const *)arg1)->operator -((btQuaternion const &)*arg2);
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion___neg__ (btQuaternion *larg1) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  try {
    result = ((btQuaternion const *)arg1)->operator -();
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion_farthest (btQuaternion *larg1, btQuaternion *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btQuaternion const *)arg1)->farthest((btQuaternion const &)*arg2);
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion_nearest (btQuaternion *larg1, btQuaternion *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btQuaternion const *)arg1)->nearest((btQuaternion const &)*arg2);
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion_slerp (btQuaternion *larg1, btQuaternion *larg2, btScalar *larg3) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = ((btQuaternion const *)arg1)->slerp((btQuaternion const &)*arg2,(btScalar const &)*arg3);
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_btQuaternion_getIdentity () {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *result = 0 ;
  
  try {
    result = (btQuaternion *) &btQuaternion::getIdentity();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btScalar *_wrap_btQuaternion_getW (btQuaternion *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btQuaternion const *)arg1)->getW();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT void _wrap_btQuaternion_serialize (btQuaternion *larg1, btQuaternionFloatData *larg2) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternionFloatData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btQuaternion const *)arg1)->serialize(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btQuaternion_deSerialize (btQuaternion *larg1, btQuaternionFloatData *larg2) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternionFloatData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->deSerialize((btQuaternionFloatData const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btQuaternion_serializeFloat (btQuaternion *larg1, btQuaternionFloatData *larg2) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternionFloatData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btQuaternion const *)arg1)->serializeFloat(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btQuaternion_deSerializeFloat (btQuaternion *larg1, btQuaternionFloatData *larg2) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternionFloatData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->deSerializeFloat((btQuaternionFloatData const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btQuaternion_serializeDouble (btQuaternion *larg1, btQuaternionDoubleData *larg2) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternionDoubleData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btQuaternion const *)arg1)->serializeDouble(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btQuaternion_deSerializeDouble (btQuaternion *larg1, btQuaternionDoubleData *larg2) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  btQuaternionDoubleData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->deSerializeDouble((btQuaternionDoubleData const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btQuaternion (btQuaternion *larg1) {
  btQuaternion *arg1 = (btQuaternion *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_dot (btQuaternion *larg1, btQuaternion *larg2) {
  btScalar lresult = (btScalar)0 ;
  btQuaternion *arg1 = 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)dot((btQuaternion const &)*arg1,(btQuaternion const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_length (btQuaternion *larg1) {
  btScalar lresult = (btScalar)0 ;
  btQuaternion *arg1 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)length((btQuaternion const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAngle__SWIG_1 (btQuaternion *larg1, btQuaternion *larg2) {
  btScalar lresult = (btScalar)0 ;
  btQuaternion *arg1 = 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)btAngle((btQuaternion const &)*arg1,(btQuaternion const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btQuaternion *_wrap_inverse (btQuaternion *larg1) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  try {
    result = inverse((btQuaternion const &)*arg1);
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_slerp (btQuaternion *larg1, btQuaternion *larg2, btScalar *larg3) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btQuaternion *arg1 = 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = slerp((btQuaternion const &)*arg1,(btQuaternion const &)*arg2,(float const &)*arg3);
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btVector3 *_wrap_quatRotate (btQuaternion *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btQuaternion *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = quatRotate((btQuaternion const &)*arg1,(btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btQuaternion *_wrap_shortestArcQuat (btVector3 *larg1, btVector3 *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = shortestArcQuat((btVector3 const &)*arg1,(btVector3 const &)*arg2);
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btQuaternion *_wrap_shortestArcQuatNormalize2 (btVector3 *larg1, btVector3 *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btVector3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = shortestArcQuatNormalize2(*arg1,*arg2);
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btTransform *_wrap_new_btTransform__SWIG_0 () {
  btTransform * lresult = (btTransform *)0 ;
  btTransform *result = 0 ;
  
  try {
    result = (btTransform *)new btTransform();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_new_btTransform__SWIG_1 (btQuaternion *larg1, btVector3 *larg2) {
  btTransform * lresult = (btTransform *)0 ;
  btQuaternion *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btTransform *)new btTransform((btQuaternion const &)*arg1,(btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_new_btTransform__SWIG_2 (btQuaternion *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btQuaternion *arg1 = 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *)new btTransform((btQuaternion const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_new_btTransform__SWIG_3 (btMatrix3x3 *larg1, btVector3 *larg2) {
  btTransform * lresult = (btTransform *)0 ;
  btMatrix3x3 *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btTransform *)new btTransform((btMatrix3x3 const &)*arg1,(btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_new_btTransform__SWIG_4 (btMatrix3x3 *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btMatrix3x3 *arg1 = 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *)new btTransform((btMatrix3x3 const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_new_btTransform__SWIG_5 (btTransform *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btTransform *arg1 = 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *)new btTransform((btTransform const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btTransform___assign__ (btTransform *larg1, btTransform *larg2) {
  btTransform * lresult = (btTransform *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btTransform *) &(arg1)->operator =((btTransform const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT void _wrap_btTransform_mult (btTransform *larg1, btTransform *larg2, btTransform *larg3) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->mult((btTransform const &)*arg2,(btTransform const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btTransform___funcall__ (btTransform *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btTransform const *)arg1)->operator ()((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btTransform___mul____SWIG_0 (btTransform *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btTransform const *)arg1)->operator *((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btQuaternion *_wrap_btTransform___mul____SWIG_1 (btTransform *larg1, btQuaternion *larg2) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btQuaternion *arg2 = 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btTransform const *)arg1)->operator *((btQuaternion const &)*arg2);
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_btTransform_getBasis__SWIG_0 (btTransform *larg1) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btMatrix3x3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btMatrix3x3 *) &(arg1)->getBasis();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_btTransform_getBasis__SWIG_1 (btTransform *larg1) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btMatrix3x3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btMatrix3x3 *) &((btTransform const *)arg1)->getBasis();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btVector3 *_wrap_btTransform_getOrigin__SWIG_0 (btTransform *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &(arg1)->getOrigin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btTransform_getOrigin__SWIG_1 (btTransform *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btTransform const *)arg1)->getOrigin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btQuaternion *_wrap_btTransform_getRotation (btTransform *larg1) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  try {
    result = ((btTransform const *)arg1)->getRotation();
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT void _wrap_btTransform_setFromOpenGLMatrix (btTransform *larg1, btScalar *larg2) {
  btTransform *arg1 = (btTransform *) 0 ;
  btScalar *arg2 = (btScalar *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setFromOpenGLMatrix((btScalar const *)arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTransform_getOpenGLMatrix (btTransform *larg1, btScalar *larg2) {
  btTransform *arg1 = (btTransform *) 0 ;
  btScalar *arg2 = (btScalar *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btTransform const *)arg1)->getOpenGLMatrix(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTransform_setOrigin (btTransform *larg1, btVector3 *larg2) {
  btTransform *arg1 = (btTransform *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setOrigin((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btTransform_invXform (btTransform *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btTransform const *)arg1)->invXform((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btTransform_setBasis (btTransform *larg1, btMatrix3x3 *larg2) {
  btTransform *arg1 = (btTransform *) 0 ;
  btMatrix3x3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setBasis((btMatrix3x3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTransform_setRotation (btTransform *larg1, btQuaternion *larg2) {
  btTransform *arg1 = (btTransform *) 0 ;
  btQuaternion *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setRotation((btQuaternion const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTransform_setIdentity (btTransform *larg1) {
  btTransform *arg1 = (btTransform *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->setIdentity();
    
  } catch (...) {
    
  }
}


EXPORT btTransform *_wrap_btTransform___mul_assign__ (btTransform *larg1, btTransform *larg2) {
  btTransform * lresult = (btTransform *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btTransform *) &(arg1)->operator *=((btTransform const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btTransform_inverse (btTransform *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btTransform result;
  
  arg1 = larg1;
  try {
    result = ((btTransform const *)arg1)->inverse();
    lresult = new btTransform(result);
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btTransform_inverseTimes (btTransform *larg1, btTransform *larg2) {
  btTransform * lresult = (btTransform *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btTransform const *)arg1)->inverseTimes((btTransform const &)*arg2);
    lresult = new btTransform(result);
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btTransform___mul____SWIG_2 (btTransform *larg1, btTransform *larg2) {
  btTransform * lresult = (btTransform *)0 ;
  btTransform *arg1 = (btTransform *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btTransform const *)arg1)->operator *((btTransform const &)*arg2);
    lresult = new btTransform(result);
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btTransform_getIdentity () {
  btTransform * lresult = (btTransform *)0 ;
  btTransform *result = 0 ;
  
  try {
    result = (btTransform *) &btTransform::getIdentity();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT void _wrap_btTransform_serialize (btTransform *larg1, btTransformFloatData *larg2) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransformFloatData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btTransform const *)arg1)->serialize(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTransform_serializeFloat (btTransform *larg1, btTransformFloatData *larg2) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransformFloatData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btTransform const *)arg1)->serializeFloat(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTransform_deSerialize (btTransform *larg1, btTransformFloatData *larg2) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransformFloatData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->deSerialize((btTransformFloatData const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTransform_deSerializeDouble (btTransform *larg1, btTransformDoubleData *larg2) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransformDoubleData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->deSerializeDouble((btTransformDoubleData const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTransform_deSerializeFloat (btTransform *larg1, btTransformFloatData *larg2) {
  btTransform *arg1 = (btTransform *) 0 ;
  btTransformFloatData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->deSerializeFloat((btTransformFloatData const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btTransform (btTransform *larg1) {
  btTransform *arg1 = (btTransform *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btMatrix3x3 *_wrap_new_btMatrix3x3__SWIG_0 () {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *result = 0 ;
  
  try {
    result = (btMatrix3x3 *)new btMatrix3x3();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_new_btMatrix3x3__SWIG_1 (btQuaternion *larg1) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btQuaternion *arg1 = 0 ;
  btMatrix3x3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btMatrix3x3 *)new btMatrix3x3((btQuaternion const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_new_btMatrix3x3__SWIG_2 (btScalar *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4, btScalar *larg5, btScalar *larg6, btScalar *larg7, btScalar *larg8, btScalar *larg9) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btScalar *arg1 = 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btScalar *arg6 = 0 ;
  btScalar *arg7 = 0 ;
  btScalar *arg8 = 0 ;
  btScalar *arg9 = 0 ;
  btMatrix3x3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  try {
    result = (btMatrix3x3 *)new btMatrix3x3((btScalar const &)*arg1,(btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4,(btScalar const &)*arg5,(btScalar const &)*arg6,(btScalar const &)*arg7,(btScalar const &)*arg8,(btScalar const &)*arg9);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_new_btMatrix3x3__SWIG_3 (btMatrix3x3 *larg1) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *arg1 = 0 ;
  btMatrix3x3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btMatrix3x3 *)new btMatrix3x3((btMatrix3x3 const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_btMatrix3x3___assign__ (btMatrix3x3 *larg1, btMatrix3x3 *larg2) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 *arg2 = 0 ;
  btMatrix3x3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btMatrix3x3 *) &(arg1)->operator =((btMatrix3x3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btVector3 *_wrap_btMatrix3x3_getColumn (btMatrix3x3 *larg1, int larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  int arg2 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btMatrix3x3 const *)arg1)->getColumn(arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btMatrix3x3_getRow (btMatrix3x3 *larg1, int larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  int arg2 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btVector3 *) &((btMatrix3x3 const *)arg1)->getRow(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btMatrix3x3___aref____SWIG_0 (btMatrix3x3 *larg1, int larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  int arg2 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btVector3 *) &(arg1)->operator [](arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btMatrix3x3___aref____SWIG_1 (btMatrix3x3 *larg1, int larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  int arg2 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btVector3 *) &((btMatrix3x3 const *)arg1)->operator [](arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_btMatrix3x3___mul_assign__ (btMatrix3x3 *larg1, btMatrix3x3 *larg2) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 *arg2 = 0 ;
  btMatrix3x3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btMatrix3x3 *) &(arg1)->operator *=((btMatrix3x3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_btMatrix3x3___add_assign__ (btMatrix3x3 *larg1, btMatrix3x3 *larg2) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 *arg2 = 0 ;
  btMatrix3x3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btMatrix3x3 *) &(arg1)->operator +=((btMatrix3x3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_btMatrix3x3___sub_assign__ (btMatrix3x3 *larg1, btMatrix3x3 *larg2) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 *arg2 = 0 ;
  btMatrix3x3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btMatrix3x3 *) &(arg1)->operator -=((btMatrix3x3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT void _wrap_btMatrix3x3_setFromOpenGLSubMatrix (btMatrix3x3 *larg1, btScalar *larg2) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = (btScalar *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setFromOpenGLSubMatrix((btScalar const *)arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMatrix3x3_setValue (btMatrix3x3 *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4, btScalar *larg5, btScalar *larg6, btScalar *larg7, btScalar *larg8, btScalar *larg9, btScalar *larg10) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btScalar *arg6 = 0 ;
  btScalar *arg7 = 0 ;
  btScalar *arg8 = 0 ;
  btScalar *arg9 = 0 ;
  btScalar *arg10 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  arg10 = larg10;
  try {
    (arg1)->setValue((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4,(btScalar const &)*arg5,(btScalar const &)*arg6,(btScalar const &)*arg7,(btScalar const &)*arg8,(btScalar const &)*arg9,(btScalar const &)*arg10);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMatrix3x3_setRotation (btMatrix3x3 *larg1, btQuaternion *larg2) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btQuaternion *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setRotation((btQuaternion const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMatrix3x3_setEulerYPR (btMatrix3x3 *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setEulerYPR((btScalar const &)*arg2,(btScalar const &)*arg3,(btScalar const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMatrix3x3_setEulerZYX (btMatrix3x3 *larg1, btScalar larg2, btScalar larg3, btScalar larg4) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setEulerZYX(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMatrix3x3_setIdentity (btMatrix3x3 *larg1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->setIdentity();
    
  } catch (...) {
    
  }
}


EXPORT btMatrix3x3 *_wrap_btMatrix3x3_getIdentity () {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *result = 0 ;
  
  try {
    result = (btMatrix3x3 *) &btMatrix3x3::getIdentity();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT void _wrap_btMatrix3x3_getOpenGLSubMatrix (btMatrix3x3 *larg1, btScalar *larg2) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = (btScalar *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btMatrix3x3 const *)arg1)->getOpenGLSubMatrix(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMatrix3x3_getRotation (btMatrix3x3 *larg1, btQuaternion *larg2) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btQuaternion *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btMatrix3x3 const *)arg1)->getRotation(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMatrix3x3_getEulerYPR (btMatrix3x3 *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btMatrix3x3 const *)arg1)->getEulerYPR(*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMatrix3x3_getEulerZYX__SWIG_0 (btMatrix3x3 *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4, unsigned int larg5) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  unsigned int arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    ((btMatrix3x3 const *)arg1)->getEulerZYX(*arg2,*arg3,*arg4,arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMatrix3x3_getEulerZYX__SWIG_1 (btMatrix3x3 *larg1, btScalar *larg2, btScalar *larg3, btScalar *larg4) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btMatrix3x3 const *)arg1)->getEulerZYX(*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT btMatrix3x3 *_wrap_btMatrix3x3_scaled (btMatrix3x3 *larg1, btVector3 *larg2) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btMatrix3x3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btMatrix3x3 const *)arg1)->scaled((btVector3 const &)*arg2);
    lresult = new btMatrix3x3(result);
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btScalar _wrap_btMatrix3x3_determinant (btMatrix3x3 *larg1) {
  btScalar lresult = (btScalar)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btMatrix3x3 const *)arg1)->determinant();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btMatrix3x3 *_wrap_btMatrix3x3_adjoint (btMatrix3x3 *larg1) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 result;
  
  arg1 = larg1;
  try {
    result = ((btMatrix3x3 const *)arg1)->adjoint();
    lresult = new btMatrix3x3(result);
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_btMatrix3x3_absolute (btMatrix3x3 *larg1) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 result;
  
  arg1 = larg1;
  try {
    result = ((btMatrix3x3 const *)arg1)->absolute();
    lresult = new btMatrix3x3(result);
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_btMatrix3x3_transpose (btMatrix3x3 *larg1) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 result;
  
  arg1 = larg1;
  try {
    result = ((btMatrix3x3 const *)arg1)->transpose();
    lresult = new btMatrix3x3(result);
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_btMatrix3x3_inverse (btMatrix3x3 *larg1) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 result;
  
  arg1 = larg1;
  try {
    result = ((btMatrix3x3 const *)arg1)->inverse();
    lresult = new btMatrix3x3(result);
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btVector3 *_wrap_btMatrix3x3_solve33 (btMatrix3x3 *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btMatrix3x3 const *)arg1)->solve33((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_btMatrix3x3_transposeTimes (btMatrix3x3 *larg1, btMatrix3x3 *larg2) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 *arg2 = 0 ;
  btMatrix3x3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btMatrix3x3 const *)arg1)->transposeTimes((btMatrix3x3 const &)*arg2);
    lresult = new btMatrix3x3(result);
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btMatrix3x3 *_wrap_btMatrix3x3_timesTranspose (btMatrix3x3 *larg1, btMatrix3x3 *larg2) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 *arg2 = 0 ;
  btMatrix3x3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btMatrix3x3 const *)arg1)->timesTranspose((btMatrix3x3 const &)*arg2);
    lresult = new btMatrix3x3(result);
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT btScalar _wrap_btMatrix3x3_tdotx (btMatrix3x3 *larg1, btVector3 *larg2) {
  btScalar lresult = (btScalar)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btMatrix3x3 const *)arg1)->tdotx((btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btMatrix3x3_tdoty (btMatrix3x3 *larg1, btVector3 *larg2) {
  btScalar lresult = (btScalar)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btMatrix3x3 const *)arg1)->tdoty((btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btMatrix3x3_tdotz (btMatrix3x3 *larg1, btVector3 *larg2) {
  btScalar lresult = (btScalar)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btMatrix3x3 const *)arg1)->tdotz((btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btMatrix3x3_diagonalize (btMatrix3x3 *larg1, btMatrix3x3 *larg2, btScalar larg3, int larg4) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3 *arg2 = 0 ;
  btScalar arg3 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->diagonalize(*arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btMatrix3x3_cofac (btMatrix3x3 *larg1, int larg2, int larg3, int larg4, int larg5) {
  btScalar lresult = (btScalar)0 ;
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    result = (btScalar)((btMatrix3x3 const *)arg1)->cofac(arg2,arg3,arg4,arg5);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btMatrix3x3_serialize (btMatrix3x3 *larg1, btMatrix3x3FloatData *larg2) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3FloatData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btMatrix3x3 const *)arg1)->serialize(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMatrix3x3_serializeFloat (btMatrix3x3 *larg1, btMatrix3x3FloatData *larg2) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3FloatData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btMatrix3x3 const *)arg1)->serializeFloat(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMatrix3x3_deSerialize (btMatrix3x3 *larg1, btMatrix3x3FloatData *larg2) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3FloatData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->deSerialize((btMatrix3x3FloatData const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMatrix3x3_deSerializeFloat (btMatrix3x3 *larg1, btMatrix3x3FloatData *larg2) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3FloatData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->deSerializeFloat((btMatrix3x3FloatData const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMatrix3x3_deSerializeDouble (btMatrix3x3 *larg1, btMatrix3x3DoubleData *larg2) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  btMatrix3x3DoubleData *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->deSerializeDouble((btMatrix3x3DoubleData const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btMatrix3x3 (btMatrix3x3 *larg1) {
  btMatrix3x3 *arg1 = (btMatrix3x3 *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btMotionState (btMotionState *larg1) {
  btMotionState *arg1 = (btMotionState *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMotionState_getWorldTransform (btMotionState *larg1, btTransform *larg2) {
  btMotionState *arg1 = (btMotionState *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btMotionState const *)arg1)->getWorldTransform(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btMotionState_setWorldTransform (btMotionState *larg1, btTransform *larg2) {
  btMotionState *arg1 = (btMotionState *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setWorldTransform((btTransform const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btBroadphasePairSortPredicate___funcall__ (btBroadphasePairSortPredicate *larg1, btBroadphasePair *larg2, btBroadphasePair *larg3) {
  int lresult = (int)0 ;
  btBroadphasePairSortPredicate *arg1 = (btBroadphasePairSortPredicate *) 0 ;
  btBroadphasePair *arg2 = 0 ;
  btBroadphasePair *arg3 = 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (bool)((btBroadphasePairSortPredicate const *)arg1)->operator ()((btBroadphasePair const &)*arg2,(btBroadphasePair const &)*arg3);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btBroadphasePairSortPredicate *_wrap_new_btBroadphasePairSortPredicate () {
  btBroadphasePairSortPredicate * lresult = (btBroadphasePairSortPredicate *)0 ;
  btBroadphasePairSortPredicate *result = 0 ;
  
  try {
    result = (btBroadphasePairSortPredicate *)new btBroadphasePairSortPredicate();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphasePairSortPredicate *)0;
  }
}


EXPORT void _wrap_delete_btBroadphasePairSortPredicate (btBroadphasePairSortPredicate *larg1) {
  btBroadphasePairSortPredicate *arg1 = (btBroadphasePairSortPredicate *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btBroadphaseInterface (btBroadphaseInterface *larg1) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btBroadphaseProxy *_wrap_btBroadphaseInterface_createProxy (btBroadphaseInterface *larg1, btVector3 *larg2, btVector3 *larg3, int larg4, void *larg5, short larg6, short larg7, btDispatcher *larg8, void *larg9) {
  btBroadphaseProxy * lresult = (btBroadphaseProxy *)0 ;
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  int arg4 ;
  void *arg5 = (void *) 0 ;
  short arg6 ;
  short arg7 ;
  btDispatcher *arg8 = (btDispatcher *) 0 ;
  void *arg9 = (void *) 0 ;
  btBroadphaseProxy *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  try {
    result = (btBroadphaseProxy *)(arg1)->createProxy((btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphaseProxy *)0;
  }
}


EXPORT void _wrap_btBroadphaseInterface_destroyProxy (btBroadphaseInterface *larg1, btBroadphaseProxy *larg2, btDispatcher *larg3) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btDispatcher *arg3 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->destroyProxy(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBroadphaseInterface_setAabb (btBroadphaseInterface *larg1, btBroadphaseProxy *larg2, btVector3 *larg3, btVector3 *larg4, btDispatcher *larg5) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btDispatcher *arg5 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->setAabb(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBroadphaseInterface_getAabb (btBroadphaseInterface *larg1, btBroadphaseProxy *larg2, btVector3 *larg3, btVector3 *larg4) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btBroadphaseInterface const *)arg1)->getAabb(arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBroadphaseInterface_rayTest__SWIG_0 (btBroadphaseInterface *larg1, btVector3 *larg2, btVector3 *larg3, btBroadphaseRayCallback *larg4, btVector3 *larg5, btVector3 *larg6) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btBroadphaseRayCallback *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    (arg1)->rayTest((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBroadphaseInterface_rayTest__SWIG_1 (btBroadphaseInterface *larg1, btVector3 *larg2, btVector3 *larg3, btBroadphaseRayCallback *larg4, btVector3 *larg5) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btBroadphaseRayCallback *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->rayTest((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4,(btVector3 const &)*arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBroadphaseInterface_rayTest__SWIG_2 (btBroadphaseInterface *larg1, btVector3 *larg2, btVector3 *larg3, btBroadphaseRayCallback *larg4) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btBroadphaseRayCallback *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->rayTest((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBroadphaseInterface_aabbTest (btBroadphaseInterface *larg1, btVector3 *larg2, btVector3 *larg3, btBroadphaseAabbCallback *larg4) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btBroadphaseAabbCallback *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->aabbTest((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBroadphaseInterface_calculateOverlappingPairs (btBroadphaseInterface *larg1, btDispatcher *larg2) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btDispatcher *arg2 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->calculateOverlappingPairs(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btOverlappingPairCache *_wrap_btBroadphaseInterface_getOverlappingPairCache__SWIG_0 (btBroadphaseInterface *larg1) {
  btOverlappingPairCache * lresult = (btOverlappingPairCache *)0 ;
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btOverlappingPairCache *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btOverlappingPairCache *)(arg1)->getOverlappingPairCache();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btOverlappingPairCache *)0;
  }
}


EXPORT btOverlappingPairCache *_wrap_btBroadphaseInterface_getOverlappingPairCache__SWIG_1 (btBroadphaseInterface *larg1) {
  btOverlappingPairCache * lresult = (btOverlappingPairCache *)0 ;
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btOverlappingPairCache *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btOverlappingPairCache *)((btBroadphaseInterface const *)arg1)->getOverlappingPairCache();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btOverlappingPairCache *)0;
  }
}


EXPORT void _wrap_btBroadphaseInterface_getBroadphaseAabb (btBroadphaseInterface *larg1, btVector3 *larg2, btVector3 *larg3) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btBroadphaseInterface const *)arg1)->getBroadphaseAabb(*arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBroadphaseInterface_resetPool (btBroadphaseInterface *larg1, btDispatcher *larg2) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  btDispatcher *arg2 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->resetPool(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBroadphaseInterface_printStats (btBroadphaseInterface *larg1) {
  btBroadphaseInterface *arg1 = (btBroadphaseInterface *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->printStats();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btDispatcher (btDispatcher *larg1) {
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btCollisionAlgorithm *_wrap_btDispatcher_findAlgorithm__SWIG_0 (btDispatcher *larg1, btCollisionObjectWrapper *larg2, btCollisionObjectWrapper *larg3, btPersistentManifold *larg4) {
  btCollisionAlgorithm * lresult = (btCollisionAlgorithm *)0 ;
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btCollisionObjectWrapper *arg2 = (btCollisionObjectWrapper *) 0 ;
  btCollisionObjectWrapper *arg3 = (btCollisionObjectWrapper *) 0 ;
  btPersistentManifold *arg4 = (btPersistentManifold *) 0 ;
  btCollisionAlgorithm *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btCollisionAlgorithm *)(arg1)->findAlgorithm((btCollisionObjectWrapper const *)arg2,(btCollisionObjectWrapper const *)arg3,arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionAlgorithm *)0;
  }
}


EXPORT btCollisionAlgorithm *_wrap_btDispatcher_findAlgorithm__SWIG_1 (btDispatcher *larg1, btCollisionObjectWrapper *larg2, btCollisionObjectWrapper *larg3) {
  btCollisionAlgorithm * lresult = (btCollisionAlgorithm *)0 ;
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btCollisionObjectWrapper *arg2 = (btCollisionObjectWrapper *) 0 ;
  btCollisionObjectWrapper *arg3 = (btCollisionObjectWrapper *) 0 ;
  btCollisionAlgorithm *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btCollisionAlgorithm *)(arg1)->findAlgorithm((btCollisionObjectWrapper const *)arg2,(btCollisionObjectWrapper const *)arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionAlgorithm *)0;
  }
}


EXPORT btPersistentManifold *_wrap_btDispatcher_getNewManifold (btDispatcher *larg1, btCollisionObject *larg2, btCollisionObject *larg3) {
  btPersistentManifold * lresult = (btPersistentManifold *)0 ;
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  btPersistentManifold *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btPersistentManifold *)(arg1)->getNewManifold((btCollisionObject const *)arg2,(btCollisionObject const *)arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPersistentManifold *)0;
  }
}


EXPORT void _wrap_btDispatcher_releaseManifold (btDispatcher *larg1, btPersistentManifold *larg2) {
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btPersistentManifold *arg2 = (btPersistentManifold *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->releaseManifold(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDispatcher_clearManifold (btDispatcher *larg1, btPersistentManifold *larg2) {
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btPersistentManifold *arg2 = (btPersistentManifold *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->clearManifold(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btDispatcher_needsCollision (btDispatcher *larg1, btCollisionObject *larg2, btCollisionObject *larg3) {
  int lresult = (int)0 ;
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (bool)(arg1)->needsCollision((btCollisionObject const *)arg2,(btCollisionObject const *)arg3);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btDispatcher_needsResponse (btDispatcher *larg1, btCollisionObject *larg2, btCollisionObject *larg3) {
  int lresult = (int)0 ;
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (bool)(arg1)->needsResponse((btCollisionObject const *)arg2,(btCollisionObject const *)arg3);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btDispatcher_dispatchAllCollisionPairs (btDispatcher *larg1, btOverlappingPairCache *larg2, btDispatcherInfo *larg3, btDispatcher *larg4) {
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btOverlappingPairCache *arg2 = (btOverlappingPairCache *) 0 ;
  btDispatcherInfo *arg3 = 0 ;
  btDispatcher *arg4 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->dispatchAllCollisionPairs(arg2,(btDispatcherInfo const &)*arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btDispatcher_getNumManifolds (btDispatcher *larg1) {
  int lresult = (int)0 ;
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btDispatcher const *)arg1)->getNumManifolds();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btPersistentManifold *_wrap_btDispatcher_getManifoldByIndexInternal (btDispatcher *larg1, int larg2) {
  btPersistentManifold * lresult = (btPersistentManifold *)0 ;
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  int arg2 ;
  btPersistentManifold *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btPersistentManifold *)(arg1)->getManifoldByIndexInternal(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPersistentManifold *)0;
  }
}


EXPORT btPersistentManifold **_wrap_btDispatcher_getInternalManifoldPointer (btDispatcher *larg1) {
  btPersistentManifold ** lresult = (btPersistentManifold **)0 ;
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btPersistentManifold **result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btPersistentManifold **)(arg1)->getInternalManifoldPointer();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPersistentManifold **)0;
  }
}


EXPORT btPoolAllocator *_wrap_btDispatcher_getInternalManifoldPool__SWIG_0 (btDispatcher *larg1) {
  btPoolAllocator * lresult = (btPoolAllocator *)0 ;
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btPoolAllocator *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btPoolAllocator *)(arg1)->getInternalManifoldPool();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPoolAllocator *)0;
  }
}


EXPORT btPoolAllocator *_wrap_btDispatcher_getInternalManifoldPool__SWIG_1 (btDispatcher *larg1) {
  btPoolAllocator * lresult = (btPoolAllocator *)0 ;
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btPoolAllocator *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btPoolAllocator *)((btDispatcher const *)arg1)->getInternalManifoldPool();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPoolAllocator *)0;
  }
}


EXPORT void *_wrap_btDispatcher_allocateCollisionAlgorithm (btDispatcher *larg1, int larg2) {
  void * lresult = (void *)0 ;
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  int arg2 ;
  void *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (void *)(arg1)->allocateCollisionAlgorithm(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (void *)0;
  }
}


EXPORT void _wrap_btDispatcher_freeCollisionAlgorithm (btDispatcher *larg1, void *larg2) {
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->freeCollisionAlgorithm(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btCollisionConfiguration (btCollisionConfiguration *larg1) {
  btCollisionConfiguration *arg1 = (btCollisionConfiguration *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btPoolAllocator *_wrap_btCollisionConfiguration_getPersistentManifoldPool (btCollisionConfiguration *larg1) {
  btPoolAllocator * lresult = (btPoolAllocator *)0 ;
  btCollisionConfiguration *arg1 = (btCollisionConfiguration *) 0 ;
  btPoolAllocator *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btPoolAllocator *)(arg1)->getPersistentManifoldPool();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPoolAllocator *)0;
  }
}


EXPORT btPoolAllocator *_wrap_btCollisionConfiguration_getCollisionAlgorithmPool (btCollisionConfiguration *larg1) {
  btPoolAllocator * lresult = (btPoolAllocator *)0 ;
  btCollisionConfiguration *arg1 = (btCollisionConfiguration *) 0 ;
  btPoolAllocator *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btPoolAllocator *)(arg1)->getCollisionAlgorithmPool();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPoolAllocator *)0;
  }
}


EXPORT btCollisionAlgorithmCreateFunc *_wrap_btCollisionConfiguration_getCollisionAlgorithmCreateFunc (btCollisionConfiguration *larg1, int larg2, int larg3) {
  btCollisionAlgorithmCreateFunc * lresult = (btCollisionAlgorithmCreateFunc *)0 ;
  btCollisionConfiguration *arg1 = (btCollisionConfiguration *) 0 ;
  int arg2 ;
  int arg3 ;
  btCollisionAlgorithmCreateFunc *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btCollisionAlgorithmCreateFunc *)(arg1)->getCollisionAlgorithmCreateFunc(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionAlgorithmCreateFunc *)0;
  }
}


EXPORT btDefaultCollisionConfiguration *_wrap_new_btDefaultCollisionConfiguration__SWIG_0 (btDefaultCollisionConstructionInfo *larg1) {
  btDefaultCollisionConfiguration * lresult = (btDefaultCollisionConfiguration *)0 ;
  btDefaultCollisionConstructionInfo *arg1 = 0 ;
  btDefaultCollisionConfiguration *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btDefaultCollisionConfiguration *)new btDefaultCollisionConfiguration((btDefaultCollisionConstructionInfo const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDefaultCollisionConfiguration *)0;
  }
}


EXPORT btDefaultCollisionConfiguration *_wrap_new_btDefaultCollisionConfiguration__SWIG_1 () {
  btDefaultCollisionConfiguration * lresult = (btDefaultCollisionConfiguration *)0 ;
  btDefaultCollisionConfiguration *result = 0 ;
  
  try {
    result = (btDefaultCollisionConfiguration *)new btDefaultCollisionConfiguration();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDefaultCollisionConfiguration *)0;
  }
}


EXPORT void _wrap_delete_btDefaultCollisionConfiguration (btDefaultCollisionConfiguration *larg1) {
  btDefaultCollisionConfiguration *arg1 = (btDefaultCollisionConfiguration *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btPoolAllocator *_wrap_btDefaultCollisionConfiguration_getPersistentManifoldPool (btDefaultCollisionConfiguration *larg1) {
  btPoolAllocator * lresult = (btPoolAllocator *)0 ;
  btDefaultCollisionConfiguration *arg1 = (btDefaultCollisionConfiguration *) 0 ;
  btPoolAllocator *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btPoolAllocator *)(arg1)->getPersistentManifoldPool();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPoolAllocator *)0;
  }
}


EXPORT btPoolAllocator *_wrap_btDefaultCollisionConfiguration_getCollisionAlgorithmPool (btDefaultCollisionConfiguration *larg1) {
  btPoolAllocator * lresult = (btPoolAllocator *)0 ;
  btDefaultCollisionConfiguration *arg1 = (btDefaultCollisionConfiguration *) 0 ;
  btPoolAllocator *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btPoolAllocator *)(arg1)->getCollisionAlgorithmPool();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPoolAllocator *)0;
  }
}


EXPORT btVoronoiSimplexSolver *_wrap_btDefaultCollisionConfiguration_getSimplexSolver (btDefaultCollisionConfiguration *larg1) {
  btVoronoiSimplexSolver * lresult = (btVoronoiSimplexSolver *)0 ;
  btDefaultCollisionConfiguration *arg1 = (btDefaultCollisionConfiguration *) 0 ;
  btVoronoiSimplexSolver *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVoronoiSimplexSolver *)(arg1)->getSimplexSolver();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVoronoiSimplexSolver *)0;
  }
}


EXPORT btCollisionAlgorithmCreateFunc *_wrap_btDefaultCollisionConfiguration_getCollisionAlgorithmCreateFunc (btDefaultCollisionConfiguration *larg1, int larg2, int larg3) {
  btCollisionAlgorithmCreateFunc * lresult = (btCollisionAlgorithmCreateFunc *)0 ;
  btDefaultCollisionConfiguration *arg1 = (btDefaultCollisionConfiguration *) 0 ;
  int arg2 ;
  int arg3 ;
  btCollisionAlgorithmCreateFunc *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btCollisionAlgorithmCreateFunc *)(arg1)->getCollisionAlgorithmCreateFunc(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionAlgorithmCreateFunc *)0;
  }
}


EXPORT void _wrap_btDefaultCollisionConfiguration_setConvexConvexMultipointIterations__SWIG_0 (btDefaultCollisionConfiguration *larg1, int larg2, int larg3) {
  btDefaultCollisionConfiguration *arg1 = (btDefaultCollisionConfiguration *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setConvexConvexMultipointIterations(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDefaultCollisionConfiguration_setConvexConvexMultipointIterations__SWIG_1 (btDefaultCollisionConfiguration *larg1, int larg2) {
  btDefaultCollisionConfiguration *arg1 = (btDefaultCollisionConfiguration *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setConvexConvexMultipointIterations(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDefaultCollisionConfiguration_setConvexConvexMultipointIterations__SWIG_2 (btDefaultCollisionConfiguration *larg1) {
  btDefaultCollisionConfiguration *arg1 = (btDefaultCollisionConfiguration *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->setConvexConvexMultipointIterations();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDefaultCollisionConfiguration_setPlaneConvexMultipointIterations__SWIG_0 (btDefaultCollisionConfiguration *larg1, int larg2, int larg3) {
  btDefaultCollisionConfiguration *arg1 = (btDefaultCollisionConfiguration *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setPlaneConvexMultipointIterations(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDefaultCollisionConfiguration_setPlaneConvexMultipointIterations__SWIG_1 (btDefaultCollisionConfiguration *larg1, int larg2) {
  btDefaultCollisionConfiguration *arg1 = (btDefaultCollisionConfiguration *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setPlaneConvexMultipointIterations(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDefaultCollisionConfiguration_setPlaneConvexMultipointIterations__SWIG_2 (btDefaultCollisionConfiguration *larg1) {
  btDefaultCollisionConfiguration *arg1 = (btDefaultCollisionConfiguration *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->setPlaneConvexMultipointIterations();
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btCollisionDispatcher_getDispatcherFlags (btCollisionDispatcher *larg1) {
  int lresult = (int)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCollisionDispatcher const *)arg1)->getDispatcherFlags();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btCollisionDispatcher_setDispatcherFlags (btCollisionDispatcher *larg1, int larg2) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setDispatcherFlags(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionDispatcher_registerCollisionCreateFunc (btCollisionDispatcher *larg1, int larg2, int larg3, btCollisionAlgorithmCreateFunc *larg4) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  int arg2 ;
  int arg3 ;
  btCollisionAlgorithmCreateFunc *arg4 = (btCollisionAlgorithmCreateFunc *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->registerCollisionCreateFunc(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btCollisionDispatcher_getNumManifolds (btCollisionDispatcher *larg1) {
  int lresult = (int)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCollisionDispatcher const *)arg1)->getNumManifolds();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btPersistentManifold **_wrap_btCollisionDispatcher_getInternalManifoldPointer (btCollisionDispatcher *larg1) {
  btPersistentManifold ** lresult = (btPersistentManifold **)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btPersistentManifold **result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btPersistentManifold **)(arg1)->getInternalManifoldPointer();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPersistentManifold **)0;
  }
}


EXPORT btPersistentManifold *_wrap_btCollisionDispatcher_getManifoldByIndexInternal__SWIG_0 (btCollisionDispatcher *larg1, int larg2) {
  btPersistentManifold * lresult = (btPersistentManifold *)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  int arg2 ;
  btPersistentManifold *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btPersistentManifold *)(arg1)->getManifoldByIndexInternal(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPersistentManifold *)0;
  }
}


EXPORT btPersistentManifold *_wrap_btCollisionDispatcher_getManifoldByIndexInternal__SWIG_1 (btCollisionDispatcher *larg1, int larg2) {
  btPersistentManifold * lresult = (btPersistentManifold *)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  int arg2 ;
  btPersistentManifold *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btPersistentManifold *)((btCollisionDispatcher const *)arg1)->getManifoldByIndexInternal(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPersistentManifold *)0;
  }
}


EXPORT btCollisionDispatcher *_wrap_new_btCollisionDispatcher (btCollisionConfiguration *larg1) {
  btCollisionDispatcher * lresult = (btCollisionDispatcher *)0 ;
  btCollisionConfiguration *arg1 = (btCollisionConfiguration *) 0 ;
  btCollisionDispatcher *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btCollisionDispatcher *)new btCollisionDispatcher(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionDispatcher *)0;
  }
}


EXPORT void _wrap_delete_btCollisionDispatcher (btCollisionDispatcher *larg1) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btPersistentManifold *_wrap_btCollisionDispatcher_getNewManifold (btCollisionDispatcher *larg1, btCollisionObject *larg2, btCollisionObject *larg3) {
  btPersistentManifold * lresult = (btPersistentManifold *)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  btPersistentManifold *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btPersistentManifold *)(arg1)->getNewManifold((btCollisionObject const *)arg2,(btCollisionObject const *)arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPersistentManifold *)0;
  }
}


EXPORT void _wrap_btCollisionDispatcher_releaseManifold (btCollisionDispatcher *larg1, btPersistentManifold *larg2) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btPersistentManifold *arg2 = (btPersistentManifold *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->releaseManifold(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionDispatcher_clearManifold (btCollisionDispatcher *larg1, btPersistentManifold *larg2) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btPersistentManifold *arg2 = (btPersistentManifold *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->clearManifold(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btCollisionAlgorithm *_wrap_btCollisionDispatcher_findAlgorithm__SWIG_0 (btCollisionDispatcher *larg1, btCollisionObjectWrapper *larg2, btCollisionObjectWrapper *larg3, btPersistentManifold *larg4) {
  btCollisionAlgorithm * lresult = (btCollisionAlgorithm *)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btCollisionObjectWrapper *arg2 = (btCollisionObjectWrapper *) 0 ;
  btCollisionObjectWrapper *arg3 = (btCollisionObjectWrapper *) 0 ;
  btPersistentManifold *arg4 = (btPersistentManifold *) 0 ;
  btCollisionAlgorithm *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btCollisionAlgorithm *)(arg1)->findAlgorithm((btCollisionObjectWrapper const *)arg2,(btCollisionObjectWrapper const *)arg3,arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionAlgorithm *)0;
  }
}


EXPORT btCollisionAlgorithm *_wrap_btCollisionDispatcher_findAlgorithm__SWIG_1 (btCollisionDispatcher *larg1, btCollisionObjectWrapper *larg2, btCollisionObjectWrapper *larg3) {
  btCollisionAlgorithm * lresult = (btCollisionAlgorithm *)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btCollisionObjectWrapper *arg2 = (btCollisionObjectWrapper *) 0 ;
  btCollisionObjectWrapper *arg3 = (btCollisionObjectWrapper *) 0 ;
  btCollisionAlgorithm *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btCollisionAlgorithm *)(arg1)->findAlgorithm((btCollisionObjectWrapper const *)arg2,(btCollisionObjectWrapper const *)arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionAlgorithm *)0;
  }
}


EXPORT int _wrap_btCollisionDispatcher_needsCollision (btCollisionDispatcher *larg1, btCollisionObject *larg2, btCollisionObject *larg3) {
  int lresult = (int)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (bool)(arg1)->needsCollision((btCollisionObject const *)arg2,(btCollisionObject const *)arg3);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionDispatcher_needsResponse (btCollisionDispatcher *larg1, btCollisionObject *larg2, btCollisionObject *larg3) {
  int lresult = (int)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (bool)(arg1)->needsResponse((btCollisionObject const *)arg2,(btCollisionObject const *)arg3);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btCollisionDispatcher_dispatchAllCollisionPairs (btCollisionDispatcher *larg1, btOverlappingPairCache *larg2, btDispatcherInfo *larg3, btDispatcher *larg4) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btOverlappingPairCache *arg2 = (btOverlappingPairCache *) 0 ;
  btDispatcherInfo *arg3 = 0 ;
  btDispatcher *arg4 = (btDispatcher *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->dispatchAllCollisionPairs(arg2,(btDispatcherInfo const &)*arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionDispatcher_setNearCallback (btCollisionDispatcher *larg1, btNearCallback larg2) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btNearCallback arg2 = (btNearCallback) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setNearCallback(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btNearCallback _wrap_btCollisionDispatcher_getNearCallback (btCollisionDispatcher *larg1) {
  btNearCallback lresult = (btNearCallback)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btNearCallback result;
  
  arg1 = larg1;
  try {
    result = (btNearCallback)((btCollisionDispatcher const *)arg1)->getNearCallback();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btNearCallback)0;
  }
}


EXPORT void _wrap_btCollisionDispatcher_defaultNearCallback (btBroadphasePair *larg1, btCollisionDispatcher *larg2, btDispatcherInfo *larg3) {
  btBroadphasePair *arg1 = 0 ;
  btCollisionDispatcher *arg2 = 0 ;
  btDispatcherInfo *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    btCollisionDispatcher::defaultNearCallback(*arg1,*arg2,(btDispatcherInfo const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void *_wrap_btCollisionDispatcher_allocateCollisionAlgorithm (btCollisionDispatcher *larg1, int larg2) {
  void * lresult = (void *)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  int arg2 ;
  void *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (void *)(arg1)->allocateCollisionAlgorithm(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (void *)0;
  }
}


EXPORT void _wrap_btCollisionDispatcher_freeCollisionAlgorithm (btCollisionDispatcher *larg1, void *larg2) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->freeCollisionAlgorithm(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btCollisionConfiguration *_wrap_btCollisionDispatcher_getCollisionConfiguration__SWIG_0 (btCollisionDispatcher *larg1) {
  btCollisionConfiguration * lresult = (btCollisionConfiguration *)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btCollisionConfiguration *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btCollisionConfiguration *)(arg1)->getCollisionConfiguration();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionConfiguration *)0;
  }
}


EXPORT btCollisionConfiguration *_wrap_btCollisionDispatcher_getCollisionConfiguration__SWIG_1 (btCollisionDispatcher *larg1) {
  btCollisionConfiguration * lresult = (btCollisionConfiguration *)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btCollisionConfiguration *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btCollisionConfiguration *)((btCollisionDispatcher const *)arg1)->getCollisionConfiguration();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionConfiguration *)0;
  }
}


EXPORT void _wrap_btCollisionDispatcher_setCollisionConfiguration (btCollisionDispatcher *larg1, btCollisionConfiguration *larg2) {
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btCollisionConfiguration *arg2 = (btCollisionConfiguration *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setCollisionConfiguration(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btPoolAllocator *_wrap_btCollisionDispatcher_getInternalManifoldPool__SWIG_0 (btCollisionDispatcher *larg1) {
  btPoolAllocator * lresult = (btPoolAllocator *)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btPoolAllocator *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btPoolAllocator *)(arg1)->getInternalManifoldPool();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPoolAllocator *)0;
  }
}


EXPORT btPoolAllocator *_wrap_btCollisionDispatcher_getInternalManifoldPool__SWIG_1 (btCollisionDispatcher *larg1) {
  btPoolAllocator * lresult = (btPoolAllocator *)0 ;
  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
  btPoolAllocator *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btPoolAllocator *)((btCollisionDispatcher const *)arg1)->getInternalManifoldPool();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPoolAllocator *)0;
  }
}


EXPORT int _wrap_btCollisionObject_mergesSimulationIslands (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionObject const *)arg1)->mergesSimulationIslands();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btVector3 *_wrap_btCollisionObject_getAnisotropicFriction (btCollisionObject *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btCollisionObject const *)arg1)->getAnisotropicFriction();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btCollisionObject_setAnisotropicFriction__SWIG_0 (btCollisionObject *larg1, btVector3 *larg2, int larg3) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *arg2 = 0 ;
  int arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setAnisotropicFriction((btVector3 const &)*arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionObject_setAnisotropicFriction__SWIG_1 (btCollisionObject *larg1, btVector3 *larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setAnisotropicFriction((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btCollisionObject_hasAnisotropicFriction__SWIG_0 (btCollisionObject *larg1, int larg2) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)((btCollisionObject const *)arg1)->hasAnisotropicFriction(arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionObject_hasAnisotropicFriction__SWIG_1 (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionObject const *)arg1)->hasAnisotropicFriction();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btCollisionObject_setContactProcessingThreshold (btCollisionObject *larg1, btScalar larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setContactProcessingThreshold(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btCollisionObject_getContactProcessingThreshold (btCollisionObject *larg1) {
  btScalar lresult = (btScalar)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btCollisionObject const *)arg1)->getContactProcessingThreshold();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btCollisionObject_isStaticObject (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionObject const *)arg1)->isStaticObject();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionObject_isKinematicObject (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionObject const *)arg1)->isKinematicObject();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionObject_isStaticOrKinematicObject (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionObject const *)arg1)->isStaticOrKinematicObject();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionObject_hasContactResponse (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionObject const *)arg1)->hasContactResponse();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btCollisionObject *_wrap_new_btCollisionObject () {
  btCollisionObject * lresult = (btCollisionObject *)0 ;
  btCollisionObject *result = 0 ;
  
  try {
    result = (btCollisionObject *)new btCollisionObject();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionObject *)0;
  }
}


EXPORT void _wrap_delete_btCollisionObject (btCollisionObject *larg1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionObject_setCollisionShape (btCollisionObject *larg1, btCollisionShape *larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionShape *arg2 = (btCollisionShape *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setCollisionShape(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btCollisionShape *_wrap_btCollisionObject_getCollisionShape__SWIG_0 (btCollisionObject *larg1) {
  btCollisionShape * lresult = (btCollisionShape *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionShape *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btCollisionShape *)((btCollisionObject const *)arg1)->getCollisionShape();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionShape *)0;
  }
}


EXPORT btCollisionShape *_wrap_btCollisionObject_getCollisionShape__SWIG_1 (btCollisionObject *larg1) {
  btCollisionShape * lresult = (btCollisionShape *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionShape *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btCollisionShape *)(arg1)->getCollisionShape();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionShape *)0;
  }
}


EXPORT void _wrap_btCollisionObject_setIgnoreCollisionCheck (btCollisionObject *larg1, btCollisionObject *larg2, int larg3) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  bool arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    (arg1)->setIgnoreCollisionCheck((btCollisionObject const *)arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btCollisionObject_checkCollideWithOverride (btCollisionObject *larg1, btCollisionObject *larg2) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)((btCollisionObject const *)arg1)->checkCollideWithOverride((btCollisionObject const *)arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void *_wrap_btCollisionObject_internalGetExtensionPointer (btCollisionObject *larg1) {
  void * lresult = (void *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  void *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (void *)((btCollisionObject const *)arg1)->internalGetExtensionPointer();
    lresult = result;
    return lresult;
  } catch (...) {
    return (void *)0;
  }
}


EXPORT void _wrap_btCollisionObject_internalSetExtensionPointer (btCollisionObject *larg1, void *larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->internalSetExtensionPointer(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btCollisionObject_getActivationState (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCollisionObject const *)arg1)->getActivationState();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btCollisionObject_setActivationState (btCollisionObject *larg1, int larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btCollisionObject const *)arg1)->setActivationState(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionObject_setDeactivationTime (btCollisionObject *larg1, btScalar larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setDeactivationTime(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btCollisionObject_getDeactivationTime (btCollisionObject *larg1) {
  btScalar lresult = (btScalar)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btCollisionObject const *)arg1)->getDeactivationTime();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btCollisionObject_forceActivationState (btCollisionObject *larg1, int larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btCollisionObject const *)arg1)->forceActivationState(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionObject_activate__SWIG_0 (btCollisionObject *larg1, int larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    ((btCollisionObject const *)arg1)->activate(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionObject_activate__SWIG_1 (btCollisionObject *larg1) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  
  arg1 = larg1;
  try {
    ((btCollisionObject const *)arg1)->activate();
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btCollisionObject_isActive (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionObject const *)arg1)->isActive();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btCollisionObject_setRestitution (btCollisionObject *larg1, btScalar larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setRestitution(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btCollisionObject_getRestitution (btCollisionObject *larg1) {
  btScalar lresult = (btScalar)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btCollisionObject const *)arg1)->getRestitution();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btCollisionObject_setFriction (btCollisionObject *larg1, btScalar larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setFriction(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btCollisionObject_getFriction (btCollisionObject *larg1) {
  btScalar lresult = (btScalar)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btCollisionObject const *)arg1)->getFriction();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btCollisionObject_setRollingFriction (btCollisionObject *larg1, btScalar larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setRollingFriction(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btCollisionObject_getRollingFriction (btCollisionObject *larg1) {
  btScalar lresult = (btScalar)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btCollisionObject const *)arg1)->getRollingFriction();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btCollisionObject_getInternalType (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCollisionObject const *)arg1)->getInternalType();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btTransform *_wrap_btCollisionObject_getWorldTransform__SWIG_0 (btCollisionObject *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &(arg1)->getWorldTransform();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btCollisionObject_getWorldTransform__SWIG_1 (btCollisionObject *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btCollisionObject const *)arg1)->getWorldTransform();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT void _wrap_btCollisionObject_setWorldTransform (btCollisionObject *larg1, btTransform *larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setWorldTransform((btTransform const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btBroadphaseProxy *_wrap_btCollisionObject_getBroadphaseHandle__SWIG_0 (btCollisionObject *larg1) {
  btBroadphaseProxy * lresult = (btBroadphaseProxy *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btBroadphaseProxy *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btBroadphaseProxy *)(arg1)->getBroadphaseHandle();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphaseProxy *)0;
  }
}


EXPORT btBroadphaseProxy *_wrap_btCollisionObject_getBroadphaseHandle__SWIG_1 (btCollisionObject *larg1) {
  btBroadphaseProxy * lresult = (btBroadphaseProxy *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btBroadphaseProxy *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btBroadphaseProxy *)((btCollisionObject const *)arg1)->getBroadphaseHandle();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphaseProxy *)0;
  }
}


EXPORT void _wrap_btCollisionObject_setBroadphaseHandle (btCollisionObject *larg1, btBroadphaseProxy *larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setBroadphaseHandle(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btTransform *_wrap_btCollisionObject_getInterpolationWorldTransform__SWIG_0 (btCollisionObject *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btCollisionObject const *)arg1)->getInterpolationWorldTransform();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btCollisionObject_getInterpolationWorldTransform__SWIG_1 (btCollisionObject *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &(arg1)->getInterpolationWorldTransform();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT void _wrap_btCollisionObject_setInterpolationWorldTransform (btCollisionObject *larg1, btTransform *larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setInterpolationWorldTransform((btTransform const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionObject_setInterpolationLinearVelocity (btCollisionObject *larg1, btVector3 *larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setInterpolationLinearVelocity((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionObject_setInterpolationAngularVelocity (btCollisionObject *larg1, btVector3 *larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setInterpolationAngularVelocity((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btCollisionObject_getInterpolationLinearVelocity (btCollisionObject *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btCollisionObject const *)arg1)->getInterpolationLinearVelocity();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btCollisionObject_getInterpolationAngularVelocity (btCollisionObject *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btCollisionObject const *)arg1)->getInterpolationAngularVelocity();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT int _wrap_btCollisionObject_getIslandTag (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCollisionObject const *)arg1)->getIslandTag();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btCollisionObject_setIslandTag (btCollisionObject *larg1, int larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setIslandTag(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btCollisionObject_getCompanionId (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCollisionObject const *)arg1)->getCompanionId();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btCollisionObject_setCompanionId (btCollisionObject *larg1, int larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setCompanionId(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btCollisionObject_getHitFraction (btCollisionObject *larg1) {
  btScalar lresult = (btScalar)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btCollisionObject const *)arg1)->getHitFraction();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btCollisionObject_setHitFraction (btCollisionObject *larg1, btScalar larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setHitFraction(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btCollisionObject_getCollisionFlags (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCollisionObject const *)arg1)->getCollisionFlags();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btCollisionObject_setCollisionFlags (btCollisionObject *larg1, int larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setCollisionFlags(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btCollisionObject_getCcdSweptSphereRadius (btCollisionObject *larg1) {
  btScalar lresult = (btScalar)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btCollisionObject const *)arg1)->getCcdSweptSphereRadius();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btCollisionObject_setCcdSweptSphereRadius (btCollisionObject *larg1, btScalar larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setCcdSweptSphereRadius(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btCollisionObject_getCcdMotionThreshold (btCollisionObject *larg1) {
  btScalar lresult = (btScalar)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btCollisionObject const *)arg1)->getCcdMotionThreshold();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btCollisionObject_getCcdSquareMotionThreshold (btCollisionObject *larg1) {
  btScalar lresult = (btScalar)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btCollisionObject const *)arg1)->getCcdSquareMotionThreshold();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btCollisionObject_setCcdMotionThreshold (btCollisionObject *larg1, btScalar larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setCcdMotionThreshold(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void *_wrap_btCollisionObject_getUserPointer (btCollisionObject *larg1) {
  void * lresult = (void *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  void *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (void *)((btCollisionObject const *)arg1)->getUserPointer();
    lresult = result;
    return lresult;
  } catch (...) {
    return (void *)0;
  }
}


EXPORT int _wrap_btCollisionObject_getUserIndex (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCollisionObject const *)arg1)->getUserIndex();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btCollisionObject_setUserPointer (btCollisionObject *larg1, void *larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setUserPointer(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionObject_setUserIndex (btCollisionObject *larg1, int larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setUserIndex(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btCollisionObject_getUpdateRevisionInternal (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCollisionObject const *)arg1)->getUpdateRevisionInternal();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionObject_checkCollideWith (btCollisionObject *larg1, btCollisionObject *larg2) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)((btCollisionObject const *)arg1)->checkCollideWith((btCollisionObject const *)arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionObject_calculateSerializeBufferSize (btCollisionObject *larg1) {
  int lresult = (int)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCollisionObject const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btCollisionObject_serialize (btCollisionObject *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btCollisionObject const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_btCollisionObject_serializeSingleObject (btCollisionObject *larg1, btSerializer *larg2) {
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btCollisionObject const *)arg1)->serializeSingleObject(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btCollisionWorld *_wrap_new_btCollisionWorld (btDispatcher *larg1, btBroadphaseInterface *larg2, btCollisionConfiguration *larg3) {
  btCollisionWorld * lresult = (btCollisionWorld *)0 ;
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btBroadphaseInterface *arg2 = (btBroadphaseInterface *) 0 ;
  btCollisionConfiguration *arg3 = (btCollisionConfiguration *) 0 ;
  btCollisionWorld *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btCollisionWorld *)new btCollisionWorld(arg1,arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionWorld *)0;
  }
}


EXPORT void _wrap_delete_btCollisionWorld (btCollisionWorld *larg1) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_setBroadphase (btCollisionWorld *larg1, btBroadphaseInterface *larg2) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btBroadphaseInterface *arg2 = (btBroadphaseInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setBroadphase(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btBroadphaseInterface *_wrap_btCollisionWorld_getBroadphase__SWIG_0 (btCollisionWorld *larg1) {
  btBroadphaseInterface * lresult = (btBroadphaseInterface *)0 ;
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btBroadphaseInterface *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btBroadphaseInterface *)((btCollisionWorld const *)arg1)->getBroadphase();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphaseInterface *)0;
  }
}


EXPORT btBroadphaseInterface *_wrap_btCollisionWorld_getBroadphase__SWIG_1 (btCollisionWorld *larg1) {
  btBroadphaseInterface * lresult = (btBroadphaseInterface *)0 ;
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btBroadphaseInterface *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btBroadphaseInterface *)(arg1)->getBroadphase();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphaseInterface *)0;
  }
}


EXPORT btOverlappingPairCache *_wrap_btCollisionWorld_getPairCache (btCollisionWorld *larg1) {
  btOverlappingPairCache * lresult = (btOverlappingPairCache *)0 ;
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btOverlappingPairCache *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btOverlappingPairCache *)(arg1)->getPairCache();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btOverlappingPairCache *)0;
  }
}


EXPORT btDispatcher *_wrap_btCollisionWorld_getDispatcher__SWIG_0 (btCollisionWorld *larg1) {
  btDispatcher * lresult = (btDispatcher *)0 ;
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btDispatcher *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btDispatcher *)(arg1)->getDispatcher();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDispatcher *)0;
  }
}


EXPORT btDispatcher *_wrap_btCollisionWorld_getDispatcher__SWIG_1 (btCollisionWorld *larg1) {
  btDispatcher * lresult = (btDispatcher *)0 ;
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btDispatcher *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btDispatcher *)((btCollisionWorld const *)arg1)->getDispatcher();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDispatcher *)0;
  }
}


EXPORT void _wrap_btCollisionWorld_updateSingleAabb (btCollisionWorld *larg1, btCollisionObject *larg2) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->updateSingleAabb(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_updateAabbs (btCollisionWorld *larg1) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->updateAabbs();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_computeOverlappingPairs (btCollisionWorld *larg1) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->computeOverlappingPairs();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_setDebugDrawer (btCollisionWorld *larg1, btIDebugDraw *larg2) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btIDebugDraw *arg2 = (btIDebugDraw *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setDebugDrawer(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btIDebugDraw *_wrap_btCollisionWorld_getDebugDrawer (btCollisionWorld *larg1) {
  btIDebugDraw * lresult = (btIDebugDraw *)0 ;
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btIDebugDraw *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btIDebugDraw *)(arg1)->getDebugDrawer();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btIDebugDraw *)0;
  }
}


EXPORT void _wrap_btCollisionWorld_debugDrawWorld (btCollisionWorld *larg1) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->debugDrawWorld();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_debugDrawObject (btCollisionWorld *larg1, btTransform *larg2, btCollisionShape *larg3, btVector3 *larg4) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btTransform *arg2 = 0 ;
  btCollisionShape *arg3 = (btCollisionShape *) 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->debugDrawObject((btTransform const &)*arg2,(btCollisionShape const *)arg3,(btVector3 const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btCollisionWorld_getNumCollisionObjects (btCollisionWorld *larg1) {
  int lresult = (int)0 ;
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCollisionWorld const *)arg1)->getNumCollisionObjects();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btCollisionWorld_rayTest (btCollisionWorld *larg1, btVector3 *larg2, btVector3 *larg3, btCollisionWorld::RayResultCallback *larg4) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btCollisionWorld::RayResultCallback *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btCollisionWorld const *)arg1)->rayTest((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_convexSweepTest__SWIG_0 (btCollisionWorld *larg1, btConvexShape *larg2, btTransform *larg3, btTransform *larg4, btCollisionWorld::ConvexResultCallback *larg5, btScalar larg6) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btConvexShape *arg2 = (btConvexShape *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btCollisionWorld::ConvexResultCallback *arg5 = 0 ;
  btScalar arg6 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    ((btCollisionWorld const *)arg1)->convexSweepTest((btConvexShape const *)arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,*arg5,arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_convexSweepTest__SWIG_1 (btCollisionWorld *larg1, btConvexShape *larg2, btTransform *larg3, btTransform *larg4, btCollisionWorld::ConvexResultCallback *larg5) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btConvexShape *arg2 = (btConvexShape *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btCollisionWorld::ConvexResultCallback *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    ((btCollisionWorld const *)arg1)->convexSweepTest((btConvexShape const *)arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,*arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_contactTest (btCollisionWorld *larg1, btCollisionObject *larg2, btCollisionWorld::ContactResultCallback *larg3) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btCollisionWorld::ContactResultCallback *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->contactTest(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_contactPairTest (btCollisionWorld *larg1, btCollisionObject *larg2, btCollisionObject *larg3, btCollisionWorld::ContactResultCallback *larg4) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  btCollisionWorld::ContactResultCallback *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->contactPairTest(arg2,arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_rayTestSingle (btTransform *larg1, btTransform *larg2, btCollisionObject *larg3, btCollisionShape *larg4, btTransform *larg5, btCollisionWorld::RayResultCallback *larg6) {
  btTransform *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  btCollisionShape *arg4 = (btCollisionShape *) 0 ;
  btTransform *arg5 = 0 ;
  btCollisionWorld::RayResultCallback *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    btCollisionWorld::rayTestSingle((btTransform const &)*arg1,(btTransform const &)*arg2,arg3,(btCollisionShape const *)arg4,(btTransform const &)*arg5,*arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_rayTestSingleInternal (btTransform *larg1, btTransform *larg2, btCollisionObjectWrapper *larg3, btCollisionWorld::RayResultCallback *larg4) {
  btTransform *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  btCollisionObjectWrapper *arg3 = (btCollisionObjectWrapper *) 0 ;
  btCollisionWorld::RayResultCallback *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    btCollisionWorld::rayTestSingleInternal((btTransform const &)*arg1,(btTransform const &)*arg2,(btCollisionObjectWrapper const *)arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_objectQuerySingle (btConvexShape *larg1, btTransform *larg2, btTransform *larg3, btCollisionObject *larg4, btCollisionShape *larg5, btTransform *larg6, btCollisionWorld::ConvexResultCallback *larg7, btScalar larg8) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btCollisionObject *arg4 = (btCollisionObject *) 0 ;
  btCollisionShape *arg5 = (btCollisionShape *) 0 ;
  btTransform *arg6 = 0 ;
  btCollisionWorld::ConvexResultCallback *arg7 = 0 ;
  btScalar arg8 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  try {
    btCollisionWorld::objectQuerySingle((btConvexShape const *)arg1,(btTransform const &)*arg2,(btTransform const &)*arg3,arg4,(btCollisionShape const *)arg5,(btTransform const &)*arg6,*arg7,arg8);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_objectQuerySingleInternal (btConvexShape *larg1, btTransform *larg2, btTransform *larg3, btCollisionObjectWrapper *larg4, btCollisionWorld::ConvexResultCallback *larg5, btScalar larg6) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btCollisionObjectWrapper *arg4 = (btCollisionObjectWrapper *) 0 ;
  btCollisionWorld::ConvexResultCallback *arg5 = 0 ;
  btScalar arg6 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    btCollisionWorld::objectQuerySingleInternal((btConvexShape const *)arg1,(btTransform const &)*arg2,(btTransform const &)*arg3,(btCollisionObjectWrapper const *)arg4,*arg5,arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_addCollisionObject__SWIG_0 (btCollisionWorld *larg1, btCollisionObject *larg2, short larg3, short larg4) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  short arg3 ;
  short arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->addCollisionObject(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_addCollisionObject__SWIG_1 (btCollisionWorld *larg1, btCollisionObject *larg2, short larg3) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  short arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->addCollisionObject(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_addCollisionObject__SWIG_2 (btCollisionWorld *larg1, btCollisionObject *larg2) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addCollisionObject(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btCollisionObjectArray *_wrap_btCollisionWorld_getCollisionObjectArray__SWIG_0 (btCollisionWorld *larg1) {
  btCollisionObjectArray * lresult = (btCollisionObjectArray *)0 ;
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObjectArray *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btCollisionObjectArray *) &(arg1)->getCollisionObjectArray();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionObjectArray *)0;
  }
}


EXPORT btCollisionObjectArray *_wrap_btCollisionWorld_getCollisionObjectArray__SWIG_1 (btCollisionWorld *larg1) {
  btCollisionObjectArray * lresult = (btCollisionObjectArray *)0 ;
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObjectArray *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btCollisionObjectArray *) &((btCollisionWorld const *)arg1)->getCollisionObjectArray();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionObjectArray *)0;
  }
}


EXPORT void _wrap_btCollisionWorld_removeCollisionObject (btCollisionWorld *larg1, btCollisionObject *larg2) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeCollisionObject(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_performDiscreteCollisionDetection (btCollisionWorld *larg1) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->performDiscreteCollisionDetection();
    
  } catch (...) {
    
  }
}


EXPORT btDispatcherInfo *_wrap_btCollisionWorld_getDispatchInfo__SWIG_0 (btCollisionWorld *larg1) {
  btDispatcherInfo * lresult = (btDispatcherInfo *)0 ;
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btDispatcherInfo *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btDispatcherInfo *) &(arg1)->getDispatchInfo();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDispatcherInfo *)0;
  }
}


EXPORT btDispatcherInfo *_wrap_btCollisionWorld_getDispatchInfo__SWIG_1 (btCollisionWorld *larg1) {
  btDispatcherInfo * lresult = (btDispatcherInfo *)0 ;
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btDispatcherInfo *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btDispatcherInfo *) &((btCollisionWorld const *)arg1)->getDispatchInfo();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDispatcherInfo *)0;
  }
}


EXPORT int _wrap_btCollisionWorld_getForceUpdateAllAabbs (btCollisionWorld *larg1) {
  int lresult = (int)0 ;
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionWorld const *)arg1)->getForceUpdateAllAabbs();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btCollisionWorld_setForceUpdateAllAabbs (btCollisionWorld *larg1, int larg2) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->setForceUpdateAllAabbs(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionWorld_serialize (btCollisionWorld *larg1, btSerializer *larg2) {
  btCollisionWorld *arg1 = (btCollisionWorld *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->serialize(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btCollisionShape (btCollisionShape *larg1) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionShape_getAabb (btCollisionShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btCollisionShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btCollisionShape_getBoundingSphere (btCollisionShape *larg1, btVector3 *larg2, btScalar *larg3) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btCollisionShape const *)arg1)->getBoundingSphere(*arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btCollisionShape_getAngularMotionDisc (btCollisionShape *larg1) {
  btScalar lresult = (btScalar)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btCollisionShape const *)arg1)->getAngularMotionDisc();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btCollisionShape_getContactBreakingThreshold (btCollisionShape *larg1, btScalar larg2) {
  btScalar lresult = (btScalar)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btScalar arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btCollisionShape const *)arg1)->getContactBreakingThreshold(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btCollisionShape_calculateTemporalAabb (btCollisionShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4, btScalar larg5, btVector3 *larg6, btVector3 *larg7) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  try {
    ((btCollisionShape const *)arg1)->calculateTemporalAabb((btTransform const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5,*arg6,*arg7);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btCollisionShape_isPolyhedral (btCollisionShape *larg1) {
  int lresult = (int)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionShape const *)arg1)->isPolyhedral();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionShape_isConvex2d (btCollisionShape *larg1) {
  int lresult = (int)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionShape const *)arg1)->isConvex2d();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionShape_isConvex (btCollisionShape *larg1) {
  int lresult = (int)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionShape const *)arg1)->isConvex();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionShape_isNonMoving (btCollisionShape *larg1) {
  int lresult = (int)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionShape const *)arg1)->isNonMoving();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionShape_isConcave (btCollisionShape *larg1) {
  int lresult = (int)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionShape const *)arg1)->isConcave();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionShape_isCompound (btCollisionShape *larg1) {
  int lresult = (int)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionShape const *)arg1)->isCompound();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionShape_isSoftBody (btCollisionShape *larg1) {
  int lresult = (int)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionShape const *)arg1)->isSoftBody();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionShape_isInfinite (btCollisionShape *larg1) {
  int lresult = (int)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btCollisionShape const *)arg1)->isInfinite();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btCollisionShape_setLocalScaling (btCollisionShape *larg1, btVector3 *larg2) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLocalScaling((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btCollisionShape_getLocalScaling (btCollisionShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btCollisionShape const *)arg1)->getLocalScaling();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btCollisionShape_calculateLocalInertia (btCollisionShape *larg1, btScalar larg2, btVector3 *larg3) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btCollisionShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT char *_wrap_btCollisionShape_getName (btCollisionShape *larg1) {
  char * lresult = (char *)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (char *)((btCollisionShape const *)arg1)->getName();
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT int _wrap_btCollisionShape_getShapeType (btCollisionShape *larg1) {
  int lresult = (int)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCollisionShape const *)arg1)->getShapeType();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btVector3 *_wrap_btCollisionShape_getAnisotropicRollingFrictionDirection (btCollisionShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  try {
    result = ((btCollisionShape const *)arg1)->getAnisotropicRollingFrictionDirection();
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btCollisionShape_setMargin (btCollisionShape *larg1, btScalar larg2) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMargin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btCollisionShape_getMargin (btCollisionShape *larg1) {
  btScalar lresult = (btScalar)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btCollisionShape const *)arg1)->getMargin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btCollisionShape_setUserPointer (btCollisionShape *larg1, void *larg2) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setUserPointer(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void *_wrap_btCollisionShape_getUserPointer (btCollisionShape *larg1) {
  void * lresult = (void *)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  void *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (void *)((btCollisionShape const *)arg1)->getUserPointer();
    lresult = result;
    return lresult;
  } catch (...) {
    return (void *)0;
  }
}


EXPORT void _wrap_btCollisionShape_setUserIndex (btCollisionShape *larg1, int larg2) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setUserIndex(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btCollisionShape_getUserIndex (btCollisionShape *larg1) {
  int lresult = (int)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCollisionShape const *)arg1)->getUserIndex();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btCollisionShape_calculateSerializeBufferSize (btCollisionShape *larg1) {
  int lresult = (int)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btCollisionShape const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btCollisionShape_serialize (btCollisionShape *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btCollisionShape const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_btCollisionShape_serializeSingleShape (btCollisionShape *larg1, btSerializer *larg2) {
  btCollisionShape *arg1 = (btCollisionShape *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btCollisionShape const *)arg1)->serializeSingleShape(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btConvexShape (btConvexShape *larg1) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btConvexShape_localGetSupportingVertex (btConvexShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btConvexShape const *)arg1)->localGetSupportingVertex((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btConvexShape_localGetSupportingVertexWithoutMargin (btConvexShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btConvexShape const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btConvexShape_localGetSupportVertexWithoutMarginNonVirtual (btConvexShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btConvexShape const *)arg1)->localGetSupportVertexWithoutMarginNonVirtual((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btConvexShape_localGetSupportVertexNonVirtual (btConvexShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btConvexShape const *)arg1)->localGetSupportVertexNonVirtual((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btScalar _wrap_btConvexShape_getMarginNonVirtual (btConvexShape *larg1) {
  btScalar lresult = (btScalar)0 ;
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btConvexShape const *)arg1)->getMarginNonVirtual();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btConvexShape_getAabbNonVirtual (btConvexShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btConvexShape const *)arg1)->getAabbNonVirtual((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexShape_project (btConvexShape *larg1, btTransform *larg2, btVector3 *larg3, btScalar *larg4, btScalar *larg5, btVector3 *larg6, btVector3 *larg7) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  try {
    ((btConvexShape const *)arg1)->project((btTransform const &)*arg2,(btVector3 const &)*arg3,*arg4,*arg5,*arg6,*arg7);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexShape_batchedUnitVectorGetSupportingVertexWithoutMargin (btConvexShape *larg1, btVector3 *larg2, btVector3 *larg3, int larg4) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btConvexShape const *)arg1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexShape_getAabb (btConvexShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btConvexShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexShape_getAabbSlow (btConvexShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btConvexShape const *)arg1)->getAabbSlow((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexShape_setLocalScaling (btConvexShape *larg1, btVector3 *larg2) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLocalScaling((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btConvexShape_getLocalScaling (btConvexShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btConvexShape const *)arg1)->getLocalScaling();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btConvexShape_setMargin (btConvexShape *larg1, btScalar larg2) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMargin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btConvexShape_getMargin (btConvexShape *larg1) {
  btScalar lresult = (btScalar)0 ;
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btConvexShape const *)arg1)->getMargin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btConvexShape_getNumPreferredPenetrationDirections (btConvexShape *larg1) {
  int lresult = (int)0 ;
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btConvexShape const *)arg1)->getNumPreferredPenetrationDirections();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btConvexShape_getPreferredPenetrationDirection (btConvexShape *larg1, int larg2, btVector3 *larg3) {
  btConvexShape *arg1 = (btConvexShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btConvexShape const *)arg1)->getPreferredPenetrationDirection(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btConvexInternalShape (btConvexInternalShape *larg1) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btConvexInternalShape_localGetSupportingVertex (btConvexInternalShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btConvexInternalShape const *)arg1)->localGetSupportingVertex((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btConvexInternalShape_getImplicitShapeDimensions (btConvexInternalShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btConvexInternalShape const *)arg1)->getImplicitShapeDimensions();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btConvexInternalShape_setImplicitShapeDimensions (btConvexInternalShape *larg1, btVector3 *larg2) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setImplicitShapeDimensions((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexInternalShape_setSafeMargin__SWIG_0 (btConvexInternalShape *larg1, btScalar larg2, btScalar larg3) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setSafeMargin(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexInternalShape_setSafeMargin__SWIG_1 (btConvexInternalShape *larg1, btScalar larg2) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setSafeMargin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexInternalShape_setSafeMargin__SWIG_2 (btConvexInternalShape *larg1, btVector3 *larg2, btScalar larg3) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setSafeMargin((btVector3 const &)*arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexInternalShape_setSafeMargin__SWIG_3 (btConvexInternalShape *larg1, btVector3 *larg2) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setSafeMargin((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexInternalShape_getAabb (btConvexInternalShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btConvexInternalShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexInternalShape_getAabbSlow (btConvexInternalShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btConvexInternalShape const *)arg1)->getAabbSlow((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexInternalShape_setLocalScaling (btConvexInternalShape *larg1, btVector3 *larg2) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLocalScaling((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btConvexInternalShape_getLocalScaling (btConvexInternalShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btConvexInternalShape const *)arg1)->getLocalScaling();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btConvexInternalShape_getLocalScalingNV (btConvexInternalShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btConvexInternalShape const *)arg1)->getLocalScalingNV();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btConvexInternalShape_setMargin (btConvexInternalShape *larg1, btScalar larg2) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMargin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btConvexInternalShape_getMargin (btConvexInternalShape *larg1) {
  btScalar lresult = (btScalar)0 ;
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btConvexInternalShape const *)arg1)->getMargin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btConvexInternalShape_getMarginNV (btConvexInternalShape *larg1) {
  btScalar lresult = (btScalar)0 ;
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btConvexInternalShape const *)arg1)->getMarginNV();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btConvexInternalShape_getNumPreferredPenetrationDirections (btConvexInternalShape *larg1) {
  int lresult = (int)0 ;
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btConvexInternalShape const *)arg1)->getNumPreferredPenetrationDirections();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btConvexInternalShape_getPreferredPenetrationDirection (btConvexInternalShape *larg1, int larg2, btVector3 *larg3) {
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btConvexInternalShape const *)arg1)->getPreferredPenetrationDirection(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btConvexInternalShape_calculateSerializeBufferSize (btConvexInternalShape *larg1) {
  int lresult = (int)0 ;
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btConvexInternalShape const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btConvexInternalShape_serialize (btConvexInternalShape *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btConvexInternalShape *arg1 = (btConvexInternalShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btConvexInternalShape const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_btConvexInternalAabbCachingShape_setLocalScaling (btConvexInternalAabbCachingShape *larg1, btVector3 *larg2) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLocalScaling((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexInternalAabbCachingShape_getAabb (btConvexInternalAabbCachingShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btConvexInternalAabbCachingShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexInternalAabbCachingShape_recalcLocalAabb (btConvexInternalAabbCachingShape *larg1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->recalcLocalAabb();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btConvexInternalAabbCachingShape (btConvexInternalAabbCachingShape *larg1) {
  btConvexInternalAabbCachingShape *arg1 = (btConvexInternalAabbCachingShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btPolyhedralConvexShape (btPolyhedralConvexShape *larg1) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btPolyhedralConvexShape_initializePolyhedralFeatures__SWIG_0 (btPolyhedralConvexShape *larg1, int larg2) {
  int lresult = (int)0 ;
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int arg2 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)(arg1)->initializePolyhedralFeatures(arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btPolyhedralConvexShape_initializePolyhedralFeatures__SWIG_1 (btPolyhedralConvexShape *larg1) {
  int lresult = (int)0 ;
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->initializePolyhedralFeatures();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btConvexPolyhedron *_wrap_btPolyhedralConvexShape_getConvexPolyhedron (btPolyhedralConvexShape *larg1) {
  btConvexPolyhedron * lresult = (btConvexPolyhedron *)0 ;
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btConvexPolyhedron *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btConvexPolyhedron *)((btPolyhedralConvexShape const *)arg1)->getConvexPolyhedron();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConvexPolyhedron *)0;
  }
}


EXPORT btVector3 *_wrap_btPolyhedralConvexShape_localGetSupportingVertexWithoutMargin (btPolyhedralConvexShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btPolyhedralConvexShape const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btPolyhedralConvexShape_batchedUnitVectorGetSupportingVertexWithoutMargin (btPolyhedralConvexShape *larg1, btVector3 *larg2, btVector3 *larg3, int larg4) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btPolyhedralConvexShape const *)arg1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPolyhedralConvexShape_calculateLocalInertia (btPolyhedralConvexShape *larg1, btScalar larg2, btVector3 *larg3) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btPolyhedralConvexShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btPolyhedralConvexShape_getNumVertices (btPolyhedralConvexShape *larg1) {
  int lresult = (int)0 ;
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btPolyhedralConvexShape const *)arg1)->getNumVertices();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btPolyhedralConvexShape_getNumEdges (btPolyhedralConvexShape *larg1) {
  int lresult = (int)0 ;
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btPolyhedralConvexShape const *)arg1)->getNumEdges();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btPolyhedralConvexShape_getEdge (btPolyhedralConvexShape *larg1, int larg2, btVector3 *larg3, btVector3 *larg4) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btPolyhedralConvexShape const *)arg1)->getEdge(arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPolyhedralConvexShape_getVertex (btPolyhedralConvexShape *larg1, int larg2, btVector3 *larg3) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btPolyhedralConvexShape const *)arg1)->getVertex(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btPolyhedralConvexShape_getNumPlanes (btPolyhedralConvexShape *larg1) {
  int lresult = (int)0 ;
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btPolyhedralConvexShape const *)arg1)->getNumPlanes();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btPolyhedralConvexShape_getPlane (btPolyhedralConvexShape *larg1, btVector3 *larg2, btVector3 *larg3, int larg4) {
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btPolyhedralConvexShape const *)arg1)->getPlane(*arg2,*arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btPolyhedralConvexShape_isInside (btPolyhedralConvexShape *larg1, btVector3 *larg2, btScalar larg3) {
  int lresult = (int)0 ;
  btPolyhedralConvexShape *arg1 = (btPolyhedralConvexShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (bool)((btPolyhedralConvexShape const *)arg1)->isInside((btVector3 const &)*arg2,arg3);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btPolyhedralConvexAabbCachingShape_getNonvirtualAabb (btPolyhedralConvexAabbCachingShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4, btScalar larg5) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btScalar arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    ((btPolyhedralConvexAabbCachingShape const *)arg1)->getNonvirtualAabb((btTransform const &)*arg2,*arg3,*arg4,arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPolyhedralConvexAabbCachingShape_setLocalScaling (btPolyhedralConvexAabbCachingShape *larg1, btVector3 *larg2) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLocalScaling((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPolyhedralConvexAabbCachingShape_getAabb (btPolyhedralConvexAabbCachingShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btPolyhedralConvexAabbCachingShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPolyhedralConvexAabbCachingShape_recalcLocalAabb (btPolyhedralConvexAabbCachingShape *larg1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->recalcLocalAabb();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btPolyhedralConvexAabbCachingShape (btPolyhedralConvexAabbCachingShape *larg1) {
  btPolyhedralConvexAabbCachingShape *arg1 = (btPolyhedralConvexAabbCachingShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btConvexHullShape *_wrap_new_btConvexHullShape__SWIG_0 (btScalar *larg1, int larg2, int larg3) {
  btConvexHullShape * lresult = (btConvexHullShape *)0 ;
  btScalar *arg1 = (btScalar *) 0 ;
  int arg2 ;
  int arg3 ;
  btConvexHullShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btConvexHullShape *)new btConvexHullShape((btScalar const *)arg1,arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConvexHullShape *)0;
  }
}


EXPORT btConvexHullShape *_wrap_new_btConvexHullShape__SWIG_1 (btScalar *larg1, int larg2) {
  btConvexHullShape * lresult = (btConvexHullShape *)0 ;
  btScalar *arg1 = (btScalar *) 0 ;
  int arg2 ;
  btConvexHullShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btConvexHullShape *)new btConvexHullShape((btScalar const *)arg1,arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConvexHullShape *)0;
  }
}


EXPORT btConvexHullShape *_wrap_new_btConvexHullShape__SWIG_2 (btScalar *larg1) {
  btConvexHullShape * lresult = (btConvexHullShape *)0 ;
  btScalar *arg1 = (btScalar *) 0 ;
  btConvexHullShape *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btConvexHullShape *)new btConvexHullShape((btScalar const *)arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConvexHullShape *)0;
  }
}


EXPORT btConvexHullShape *_wrap_new_btConvexHullShape__SWIG_3 () {
  btConvexHullShape * lresult = (btConvexHullShape *)0 ;
  btConvexHullShape *result = 0 ;
  
  try {
    result = (btConvexHullShape *)new btConvexHullShape();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConvexHullShape *)0;
  }
}


EXPORT void _wrap_btConvexHullShape_addPoint__SWIG_0 (btConvexHullShape *larg1, btVector3 *larg2, int larg3) {
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  btVector3 *arg2 = 0 ;
  bool arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    (arg1)->addPoint((btVector3 const &)*arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexHullShape_addPoint__SWIG_1 (btConvexHullShape *larg1, btVector3 *larg2) {
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addPoint((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btConvexHullShape_getUnscaledPoints__SWIG_0 (btConvexHullShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)(arg1)->getUnscaledPoints();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btConvexHullShape_getUnscaledPoints__SWIG_1 (btConvexHullShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)((btConvexHullShape const *)arg1)->getUnscaledPoints();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btConvexHullShape_getPoints (btConvexHullShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)((btConvexHullShape const *)arg1)->getPoints();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btConvexHullShape_getScaledPoint (btConvexHullShape *larg1, int larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  int arg2 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btConvexHullShape const *)arg1)->getScaledPoint(arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT int _wrap_btConvexHullShape_getNumPoints (btConvexHullShape *larg1) {
  int lresult = (int)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btConvexHullShape const *)arg1)->getNumPoints();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btVector3 *_wrap_btConvexHullShape_localGetSupportingVertex (btConvexHullShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btConvexHullShape const *)arg1)->localGetSupportingVertex((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btConvexHullShape_localGetSupportingVertexWithoutMargin (btConvexHullShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btConvexHullShape const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btConvexHullShape_batchedUnitVectorGetSupportingVertexWithoutMargin (btConvexHullShape *larg1, btVector3 *larg2, btVector3 *larg3, int larg4) {
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btConvexHullShape const *)arg1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexHullShape_project (btConvexHullShape *larg1, btTransform *larg2, btVector3 *larg3, btScalar *larg4, btScalar *larg5, btVector3 *larg6, btVector3 *larg7) {
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btScalar *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  try {
    ((btConvexHullShape const *)arg1)->project((btTransform const &)*arg2,(btVector3 const &)*arg3,*arg4,*arg5,*arg6,*arg7);
    
  } catch (...) {
    
  }
}


EXPORT char *_wrap_btConvexHullShape_getName (btConvexHullShape *larg1) {
  char * lresult = (char *)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (char *)((btConvexHullShape const *)arg1)->getName();
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT int _wrap_btConvexHullShape_getNumVertices (btConvexHullShape *larg1) {
  int lresult = (int)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btConvexHullShape const *)arg1)->getNumVertices();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btConvexHullShape_getNumEdges (btConvexHullShape *larg1) {
  int lresult = (int)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btConvexHullShape const *)arg1)->getNumEdges();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btConvexHullShape_getEdge (btConvexHullShape *larg1, int larg2, btVector3 *larg3, btVector3 *larg4) {
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btConvexHullShape const *)arg1)->getEdge(arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConvexHullShape_getVertex (btConvexHullShape *larg1, int larg2, btVector3 *larg3) {
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btConvexHullShape const *)arg1)->getVertex(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btConvexHullShape_getNumPlanes (btConvexHullShape *larg1) {
  int lresult = (int)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btConvexHullShape const *)arg1)->getNumPlanes();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btConvexHullShape_getPlane (btConvexHullShape *larg1, btVector3 *larg2, btVector3 *larg3, int larg4) {
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btConvexHullShape const *)arg1)->getPlane(*arg2,*arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btConvexHullShape_isInside (btConvexHullShape *larg1, btVector3 *larg2, btScalar larg3) {
  int lresult = (int)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (bool)((btConvexHullShape const *)arg1)->isInside((btVector3 const &)*arg2,arg3);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btConvexHullShape_setLocalScaling (btConvexHullShape *larg1, btVector3 *larg2) {
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLocalScaling((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btConvexHullShape_calculateSerializeBufferSize (btConvexHullShape *larg1) {
  int lresult = (int)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btConvexHullShape const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btConvexHullShape_serialize (btConvexHullShape *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btConvexHullShape const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_delete_btConvexHullShape (btConvexHullShape *larg1) {
  btConvexHullShape *arg1 = (btConvexHullShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btSphereShape *_wrap_new_btSphereShape (btScalar larg1) {
  btSphereShape * lresult = (btSphereShape *)0 ;
  btScalar arg1 ;
  btSphereShape *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSphereShape *)new btSphereShape(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSphereShape *)0;
  }
}


EXPORT btVector3 *_wrap_btSphereShape_localGetSupportingVertex (btSphereShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btSphereShape const *)arg1)->localGetSupportingVertex((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btSphereShape_localGetSupportingVertexWithoutMargin (btSphereShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btSphereShape const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btSphereShape_batchedUnitVectorGetSupportingVertexWithoutMargin (btSphereShape *larg1, btVector3 *larg2, btVector3 *larg3, int larg4) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btSphereShape const *)arg1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSphereShape_calculateLocalInertia (btSphereShape *larg1, btScalar larg2, btVector3 *larg3) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btSphereShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSphereShape_getAabb (btSphereShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btSphereShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btSphereShape_getRadius (btSphereShape *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btSphereShape const *)arg1)->getRadius();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btSphereShape_setUnscaledRadius (btSphereShape *larg1, btScalar larg2) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setUnscaledRadius(arg2);
    
  } catch (...) {
    
  }
}


EXPORT char *_wrap_btSphereShape_getName (btSphereShape *larg1) {
  char * lresult = (char *)0 ;
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (char *)((btSphereShape const *)arg1)->getName();
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_btSphereShape_setMargin (btSphereShape *larg1, btScalar larg2) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMargin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btSphereShape_getMargin (btSphereShape *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btSphereShape const *)arg1)->getMargin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_delete_btSphereShape (btSphereShape *larg1) {
  btSphereShape *arg1 = (btSphereShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btMultiSphereShape *_wrap_new_btMultiSphereShape (btVector3 *larg1, btScalar *larg2, int larg3) {
  btMultiSphereShape * lresult = (btMultiSphereShape *)0 ;
  btVector3 *arg1 = (btVector3 *) 0 ;
  btScalar *arg2 = (btScalar *) 0 ;
  int arg3 ;
  btMultiSphereShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btMultiSphereShape *)new btMultiSphereShape((btVector3 const *)arg1,(btScalar const *)arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMultiSphereShape *)0;
  }
}


EXPORT void _wrap_btMultiSphereShape_calculateLocalInertia (btMultiSphereShape *larg1, btScalar larg2, btVector3 *larg3) {
  btMultiSphereShape *arg1 = (btMultiSphereShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btMultiSphereShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btMultiSphereShape_localGetSupportingVertexWithoutMargin (btMultiSphereShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btMultiSphereShape *arg1 = (btMultiSphereShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btMultiSphereShape const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btMultiSphereShape_batchedUnitVectorGetSupportingVertexWithoutMargin (btMultiSphereShape *larg1, btVector3 *larg2, btVector3 *larg3, int larg4) {
  btMultiSphereShape *arg1 = (btMultiSphereShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btMultiSphereShape const *)arg1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btMultiSphereShape_getSphereCount (btMultiSphereShape *larg1) {
  int lresult = (int)0 ;
  btMultiSphereShape *arg1 = (btMultiSphereShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btMultiSphereShape const *)arg1)->getSphereCount();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btVector3 *_wrap_btMultiSphereShape_getSpherePosition (btMultiSphereShape *larg1, int larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btMultiSphereShape *arg1 = (btMultiSphereShape *) 0 ;
  int arg2 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btVector3 *) &((btMultiSphereShape const *)arg1)->getSpherePosition(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btScalar _wrap_btMultiSphereShape_getSphereRadius (btMultiSphereShape *larg1, int larg2) {
  btScalar lresult = (btScalar)0 ;
  btMultiSphereShape *arg1 = (btMultiSphereShape *) 0 ;
  int arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btMultiSphereShape const *)arg1)->getSphereRadius(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT char *_wrap_btMultiSphereShape_getName (btMultiSphereShape *larg1) {
  char * lresult = (char *)0 ;
  btMultiSphereShape *arg1 = (btMultiSphereShape *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (char *)((btMultiSphereShape const *)arg1)->getName();
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT int _wrap_btMultiSphereShape_calculateSerializeBufferSize (btMultiSphereShape *larg1) {
  int lresult = (int)0 ;
  btMultiSphereShape *arg1 = (btMultiSphereShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btMultiSphereShape const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btMultiSphereShape_serialize (btMultiSphereShape *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btMultiSphereShape *arg1 = (btMultiSphereShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btMultiSphereShape const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_delete_btMultiSphereShape (btMultiSphereShape *larg1) {
  btMultiSphereShape *arg1 = (btMultiSphereShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btConcaveShape (btConcaveShape *larg1) {
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConcaveShape_processAllTriangles (btConcaveShape *larg1, btTriangleCallback *larg2, btVector3 *larg3, btVector3 *larg4) {
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  btTriangleCallback *arg2 = (btTriangleCallback *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btConcaveShape const *)arg1)->processAllTriangles(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btConcaveShape_getMargin (btConcaveShape *larg1) {
  btScalar lresult = (btScalar)0 ;
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btConcaveShape const *)arg1)->getMargin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btConcaveShape_setMargin (btConcaveShape *larg1, btScalar larg2) {
  btConcaveShape *arg1 = (btConcaveShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMargin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btStaticPlaneShape *_wrap_new_btStaticPlaneShape (btVector3 *larg1, btScalar larg2) {
  btStaticPlaneShape * lresult = (btStaticPlaneShape *)0 ;
  btVector3 *arg1 = 0 ;
  btScalar arg2 ;
  btStaticPlaneShape *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btStaticPlaneShape *)new btStaticPlaneShape((btVector3 const &)*arg1,arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btStaticPlaneShape *)0;
  }
}


EXPORT void _wrap_delete_btStaticPlaneShape (btStaticPlaneShape *larg1) {
  btStaticPlaneShape *arg1 = (btStaticPlaneShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btStaticPlaneShape_getAabb (btStaticPlaneShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btStaticPlaneShape *arg1 = (btStaticPlaneShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btStaticPlaneShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btStaticPlaneShape_processAllTriangles (btStaticPlaneShape *larg1, btTriangleCallback *larg2, btVector3 *larg3, btVector3 *larg4) {
  btStaticPlaneShape *arg1 = (btStaticPlaneShape *) 0 ;
  btTriangleCallback *arg2 = (btTriangleCallback *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btStaticPlaneShape const *)arg1)->processAllTriangles(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btStaticPlaneShape_calculateLocalInertia (btStaticPlaneShape *larg1, btScalar larg2, btVector3 *larg3) {
  btStaticPlaneShape *arg1 = (btStaticPlaneShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btStaticPlaneShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btStaticPlaneShape_setLocalScaling (btStaticPlaneShape *larg1, btVector3 *larg2) {
  btStaticPlaneShape *arg1 = (btStaticPlaneShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLocalScaling((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btStaticPlaneShape_getLocalScaling (btStaticPlaneShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btStaticPlaneShape *arg1 = (btStaticPlaneShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btStaticPlaneShape const *)arg1)->getLocalScaling();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btStaticPlaneShape_getPlaneNormal (btStaticPlaneShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btStaticPlaneShape *arg1 = (btStaticPlaneShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btStaticPlaneShape const *)arg1)->getPlaneNormal();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btScalar *_wrap_btStaticPlaneShape_getPlaneConstant (btStaticPlaneShape *larg1) {
  btScalar * lresult = (btScalar *)0 ;
  btStaticPlaneShape *arg1 = (btStaticPlaneShape *) 0 ;
  btScalar *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btScalar *) &((btStaticPlaneShape const *)arg1)->getPlaneConstant();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar *)0;
  }
}


EXPORT char *_wrap_btStaticPlaneShape_getName (btStaticPlaneShape *larg1) {
  char * lresult = (char *)0 ;
  btStaticPlaneShape *arg1 = (btStaticPlaneShape *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (char *)((btStaticPlaneShape const *)arg1)->getName();
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT int _wrap_btStaticPlaneShape_calculateSerializeBufferSize (btStaticPlaneShape *larg1) {
  int lresult = (int)0 ;
  btStaticPlaneShape *arg1 = (btStaticPlaneShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btStaticPlaneShape const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btStaticPlaneShape_serialize (btStaticPlaneShape *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btStaticPlaneShape *arg1 = (btStaticPlaneShape *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btStaticPlaneShape const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT btVector3 *_wrap_btBoxShape_getHalfExtentsWithMargin (btBoxShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  try {
    result = ((btBoxShape const *)arg1)->getHalfExtentsWithMargin();
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btBoxShape_getHalfExtentsWithoutMargin (btBoxShape *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btBoxShape const *)arg1)->getHalfExtentsWithoutMargin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btBoxShape_localGetSupportingVertex (btBoxShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btBoxShape const *)arg1)->localGetSupportingVertex((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btBoxShape_localGetSupportingVertexWithoutMargin (btBoxShape *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btBoxShape const *)arg1)->localGetSupportingVertexWithoutMargin((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btBoxShape_batchedUnitVectorGetSupportingVertexWithoutMargin (btBoxShape *larg1, btVector3 *larg2, btVector3 *larg3, int larg4) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btBoxShape const *)arg1)->batchedUnitVectorGetSupportingVertexWithoutMargin((btVector3 const *)arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT btBoxShape *_wrap_new_btBoxShape (btVector3 *larg1) {
  btBoxShape * lresult = (btBoxShape *)0 ;
  btVector3 *arg1 = 0 ;
  btBoxShape *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btBoxShape *)new btBoxShape((btVector3 const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBoxShape *)0;
  }
}


EXPORT void _wrap_btBoxShape_setMargin (btBoxShape *larg1, btScalar larg2) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMargin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBoxShape_setLocalScaling (btBoxShape *larg1, btVector3 *larg2) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLocalScaling((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBoxShape_getAabb (btBoxShape *larg1, btTransform *larg2, btVector3 *larg3, btVector3 *larg4) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btTransform *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btBoxShape const *)arg1)->getAabb((btTransform const &)*arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBoxShape_calculateLocalInertia (btBoxShape *larg1, btScalar larg2, btVector3 *larg3) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btBoxShape const *)arg1)->calculateLocalInertia(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBoxShape_getPlane (btBoxShape *larg1, btVector3 *larg2, btVector3 *larg3, int larg4) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btBoxShape const *)arg1)->getPlane(*arg2,*arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btBoxShape_getNumPlanes (btBoxShape *larg1) {
  int lresult = (int)0 ;
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btBoxShape const *)arg1)->getNumPlanes();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btBoxShape_getNumVertices (btBoxShape *larg1) {
  int lresult = (int)0 ;
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btBoxShape const *)arg1)->getNumVertices();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btBoxShape_getNumEdges (btBoxShape *larg1) {
  int lresult = (int)0 ;
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btBoxShape const *)arg1)->getNumEdges();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btBoxShape_getVertex (btBoxShape *larg1, int larg2, btVector3 *larg3) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btBoxShape const *)arg1)->getVertex(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBoxShape_getPlaneEquation (btBoxShape *larg1, btVector4 *larg2, int larg3) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector4 *arg2 = 0 ;
  int arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btBoxShape const *)arg1)->getPlaneEquation(*arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btBoxShape_getEdge (btBoxShape *larg1, int larg2, btVector3 *larg3, btVector3 *larg4) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btBoxShape const *)arg1)->getEdge(arg2,*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btBoxShape_isInside (btBoxShape *larg1, btVector3 *larg2, btScalar larg3) {
  int lresult = (int)0 ;
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (bool)((btBoxShape const *)arg1)->isInside((btVector3 const &)*arg2,arg3);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btBoxShape_getName (btBoxShape *larg1) {
  char * lresult = (char *)0 ;
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (char *)((btBoxShape const *)arg1)->getName();
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT int _wrap_btBoxShape_getNumPreferredPenetrationDirections (btBoxShape *larg1) {
  int lresult = (int)0 ;
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btBoxShape const *)arg1)->getNumPreferredPenetrationDirections();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btBoxShape_getPreferredPenetrationDirection (btBoxShape *larg1, int larg2, btVector3 *larg3) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btBoxShape const *)arg1)->getPreferredPenetrationDirection(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btBoxShape (btBoxShape *larg1) {
  btBoxShape *arg1 = (btBoxShape *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btDynamicsWorld (btDynamicsWorld *larg1) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btDynamicsWorld_stepSimulation__SWIG_0 (btDynamicsWorld *larg1, btScalar larg2, int larg3, btScalar larg4) {
  int lresult = (int)0 ;
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btScalar arg2 ;
  int arg3 ;
  btScalar arg4 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (int)(arg1)->stepSimulation(arg2,arg3,arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btDynamicsWorld_stepSimulation__SWIG_1 (btDynamicsWorld *larg1, btScalar larg2, int larg3) {
  int lresult = (int)0 ;
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btScalar arg2 ;
  int arg3 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (int)(arg1)->stepSimulation(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btDynamicsWorld_stepSimulation__SWIG_2 (btDynamicsWorld *larg1, btScalar larg2) {
  int lresult = (int)0 ;
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btScalar arg2 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (int)(arg1)->stepSimulation(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btDynamicsWorld_debugDrawWorld (btDynamicsWorld *larg1) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->debugDrawWorld();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_addConstraint__SWIG_0 (btDynamicsWorld *larg1, btTypedConstraint *larg2, int larg3) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  bool arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    (arg1)->addConstraint(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_addConstraint__SWIG_1 (btDynamicsWorld *larg1, btTypedConstraint *larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addConstraint(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_removeConstraint (btDynamicsWorld *larg1, btTypedConstraint *larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeConstraint(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_addAction (btDynamicsWorld *larg1, btActionInterface *larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addAction(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_removeAction (btDynamicsWorld *larg1, btActionInterface *larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeAction(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_setGravity (btDynamicsWorld *larg1, btVector3 *larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setGravity((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btDynamicsWorld_getGravity (btDynamicsWorld *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  try {
    result = ((btDynamicsWorld const *)arg1)->getGravity();
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btDynamicsWorld_synchronizeMotionStates (btDynamicsWorld *larg1) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->synchronizeMotionStates();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_addRigidBody__SWIG_0 (btDynamicsWorld *larg1, btRigidBody *larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addRigidBody(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_addRigidBody__SWIG_1 (btDynamicsWorld *larg1, btRigidBody *larg2, short larg3, short larg4) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  short arg3 ;
  short arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->addRigidBody(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_removeRigidBody (btDynamicsWorld *larg1, btRigidBody *larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeRigidBody(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_setConstraintSolver (btDynamicsWorld *larg1, btConstraintSolver *larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btConstraintSolver *arg2 = (btConstraintSolver *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setConstraintSolver(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btConstraintSolver *_wrap_btDynamicsWorld_getConstraintSolver (btDynamicsWorld *larg1) {
  btConstraintSolver * lresult = (btConstraintSolver *)0 ;
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btConstraintSolver *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btConstraintSolver *)(arg1)->getConstraintSolver();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConstraintSolver *)0;
  }
}


EXPORT int _wrap_btDynamicsWorld_getNumConstraints (btDynamicsWorld *larg1) {
  int lresult = (int)0 ;
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btDynamicsWorld const *)arg1)->getNumConstraints();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btTypedConstraint *_wrap_btDynamicsWorld_getConstraint__SWIG_0 (btDynamicsWorld *larg1, int larg2) {
  btTypedConstraint * lresult = (btTypedConstraint *)0 ;
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  int arg2 ;
  btTypedConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btTypedConstraint *)(arg1)->getConstraint(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTypedConstraint *)0;
  }
}


EXPORT btTypedConstraint *_wrap_btDynamicsWorld_getConstraint__SWIG_1 (btDynamicsWorld *larg1, int larg2) {
  btTypedConstraint * lresult = (btTypedConstraint *)0 ;
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  int arg2 ;
  btTypedConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btTypedConstraint *)((btDynamicsWorld const *)arg1)->getConstraint(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTypedConstraint *)0;
  }
}


EXPORT btDynamicsWorldType _wrap_btDynamicsWorld_getWorldType (btDynamicsWorld *larg1) {
  btDynamicsWorldType lresult = (btDynamicsWorldType)0 ;
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btDynamicsWorldType result;
  
  arg1 = larg1;
  try {
    result = (btDynamicsWorldType)((btDynamicsWorld const *)arg1)->getWorldType();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDynamicsWorldType)0;
  }
}


EXPORT void _wrap_btDynamicsWorld_clearForces (btDynamicsWorld *larg1) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->clearForces();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_setInternalTickCallback__SWIG_0 (btDynamicsWorld *larg1, btInternalTickCallback larg2, void *larg3, int larg4) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btInternalTickCallback arg2 = (btInternalTickCallback) 0 ;
  void *arg3 = (void *) 0 ;
  bool arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  try {
    (arg1)->setInternalTickCallback(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_setInternalTickCallback__SWIG_1 (btDynamicsWorld *larg1, btInternalTickCallback larg2, void *larg3) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btInternalTickCallback arg2 = (btInternalTickCallback) 0 ;
  void *arg3 = (void *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setInternalTickCallback(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_setInternalTickCallback__SWIG_2 (btDynamicsWorld *larg1, btInternalTickCallback larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btInternalTickCallback arg2 = (btInternalTickCallback) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setInternalTickCallback(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_setWorldUserInfo (btDynamicsWorld *larg1, void *larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setWorldUserInfo(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void *_wrap_btDynamicsWorld_getWorldUserInfo (btDynamicsWorld *larg1) {
  void * lresult = (void *)0 ;
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  void *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (void *)((btDynamicsWorld const *)arg1)->getWorldUserInfo();
    lresult = result;
    return lresult;
  } catch (...) {
    return (void *)0;
  }
}


EXPORT btContactSolverInfo *_wrap_btDynamicsWorld_getSolverInfo (btDynamicsWorld *larg1) {
  btContactSolverInfo * lresult = (btContactSolverInfo *)0 ;
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btContactSolverInfo *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btContactSolverInfo *) &(arg1)->getSolverInfo();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btContactSolverInfo *)0;
  }
}


EXPORT void _wrap_btDynamicsWorld_addVehicle (btDynamicsWorld *larg1, btActionInterface *larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addVehicle(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_removeVehicle (btDynamicsWorld *larg1, btActionInterface *larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeVehicle(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_addCharacter (btDynamicsWorld *larg1, btActionInterface *larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addCharacter(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDynamicsWorld_removeCharacter (btDynamicsWorld *larg1, btActionInterface *larg2) {
  btDynamicsWorld *arg1 = (btDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeCharacter(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btDiscreteDynamicsWorld *_wrap_new_btDiscreteDynamicsWorld (btDispatcher *larg1, btBroadphaseInterface *larg2, btConstraintSolver *larg3, btCollisionConfiguration *larg4) {
  btDiscreteDynamicsWorld * lresult = (btDiscreteDynamicsWorld *)0 ;
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btBroadphaseInterface *arg2 = (btBroadphaseInterface *) 0 ;
  btConstraintSolver *arg3 = (btConstraintSolver *) 0 ;
  btCollisionConfiguration *arg4 = (btCollisionConfiguration *) 0 ;
  btDiscreteDynamicsWorld *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btDiscreteDynamicsWorld *)new btDiscreteDynamicsWorld(arg1,arg2,arg3,arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDiscreteDynamicsWorld *)0;
  }
}


EXPORT void _wrap_delete_btDiscreteDynamicsWorld (btDiscreteDynamicsWorld *larg1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btDiscreteDynamicsWorld_stepSimulation__SWIG_0 (btDiscreteDynamicsWorld *larg1, btScalar larg2, int larg3, btScalar larg4) {
  int lresult = (int)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btScalar arg2 ;
  int arg3 ;
  btScalar arg4 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (int)(arg1)->stepSimulation(arg2,arg3,arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btDiscreteDynamicsWorld_stepSimulation__SWIG_1 (btDiscreteDynamicsWorld *larg1, btScalar larg2, int larg3) {
  int lresult = (int)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btScalar arg2 ;
  int arg3 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (int)(arg1)->stepSimulation(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btDiscreteDynamicsWorld_stepSimulation__SWIG_2 (btDiscreteDynamicsWorld *larg1, btScalar larg2) {
  int lresult = (int)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btScalar arg2 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (int)(arg1)->stepSimulation(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_synchronizeMotionStates (btDiscreteDynamicsWorld *larg1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->synchronizeMotionStates();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_synchronizeSingleMotionState (btDiscreteDynamicsWorld *larg1, btRigidBody *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->synchronizeSingleMotionState(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_addConstraint__SWIG_0 (btDiscreteDynamicsWorld *larg1, btTypedConstraint *larg2, int larg3) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  bool arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    (arg1)->addConstraint(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_addConstraint__SWIG_1 (btDiscreteDynamicsWorld *larg1, btTypedConstraint *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addConstraint(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_removeConstraint (btDiscreteDynamicsWorld *larg1, btTypedConstraint *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeConstraint(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_addAction (btDiscreteDynamicsWorld *larg1, btActionInterface *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addAction(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_removeAction (btDiscreteDynamicsWorld *larg1, btActionInterface *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeAction(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btSimulationIslandManager *_wrap_btDiscreteDynamicsWorld_getSimulationIslandManager__SWIG_0 (btDiscreteDynamicsWorld *larg1) {
  btSimulationIslandManager * lresult = (btSimulationIslandManager *)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btSimulationIslandManager *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSimulationIslandManager *)(arg1)->getSimulationIslandManager();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSimulationIslandManager *)0;
  }
}


EXPORT btSimulationIslandManager *_wrap_btDiscreteDynamicsWorld_getSimulationIslandManager__SWIG_1 (btDiscreteDynamicsWorld *larg1) {
  btSimulationIslandManager * lresult = (btSimulationIslandManager *)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btSimulationIslandManager *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSimulationIslandManager *)((btDiscreteDynamicsWorld const *)arg1)->getSimulationIslandManager();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSimulationIslandManager *)0;
  }
}


EXPORT btCollisionWorld *_wrap_btDiscreteDynamicsWorld_getCollisionWorld (btDiscreteDynamicsWorld *larg1) {
  btCollisionWorld * lresult = (btCollisionWorld *)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btCollisionWorld *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btCollisionWorld *)(arg1)->getCollisionWorld();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionWorld *)0;
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_setGravity (btDiscreteDynamicsWorld *larg1, btVector3 *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setGravity((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btDiscreteDynamicsWorld_getGravity (btDiscreteDynamicsWorld *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  try {
    result = ((btDiscreteDynamicsWorld const *)arg1)->getGravity();
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_addCollisionObject__SWIG_0 (btDiscreteDynamicsWorld *larg1, btCollisionObject *larg2, short larg3, short larg4) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  short arg3 ;
  short arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->addCollisionObject(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_addCollisionObject__SWIG_1 (btDiscreteDynamicsWorld *larg1, btCollisionObject *larg2, short larg3) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  short arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->addCollisionObject(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_addCollisionObject__SWIG_2 (btDiscreteDynamicsWorld *larg1, btCollisionObject *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addCollisionObject(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_addRigidBody__SWIG_0 (btDiscreteDynamicsWorld *larg1, btRigidBody *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addRigidBody(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_addRigidBody__SWIG_1 (btDiscreteDynamicsWorld *larg1, btRigidBody *larg2, short larg3, short larg4) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  short arg3 ;
  short arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->addRigidBody(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_removeRigidBody (btDiscreteDynamicsWorld *larg1, btRigidBody *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeRigidBody(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_removeCollisionObject (btDiscreteDynamicsWorld *larg1, btCollisionObject *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeCollisionObject(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_debugDrawConstraint (btDiscreteDynamicsWorld *larg1, btTypedConstraint *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->debugDrawConstraint(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_debugDrawWorld (btDiscreteDynamicsWorld *larg1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->debugDrawWorld();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_setConstraintSolver (btDiscreteDynamicsWorld *larg1, btConstraintSolver *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btConstraintSolver *arg2 = (btConstraintSolver *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setConstraintSolver(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btConstraintSolver *_wrap_btDiscreteDynamicsWorld_getConstraintSolver (btDiscreteDynamicsWorld *larg1) {
  btConstraintSolver * lresult = (btConstraintSolver *)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btConstraintSolver *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btConstraintSolver *)(arg1)->getConstraintSolver();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConstraintSolver *)0;
  }
}


EXPORT int _wrap_btDiscreteDynamicsWorld_getNumConstraints (btDiscreteDynamicsWorld *larg1) {
  int lresult = (int)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btDiscreteDynamicsWorld const *)arg1)->getNumConstraints();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btTypedConstraint *_wrap_btDiscreteDynamicsWorld_getConstraint__SWIG_0 (btDiscreteDynamicsWorld *larg1, int larg2) {
  btTypedConstraint * lresult = (btTypedConstraint *)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  int arg2 ;
  btTypedConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btTypedConstraint *)(arg1)->getConstraint(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTypedConstraint *)0;
  }
}


EXPORT btTypedConstraint *_wrap_btDiscreteDynamicsWorld_getConstraint__SWIG_1 (btDiscreteDynamicsWorld *larg1, int larg2) {
  btTypedConstraint * lresult = (btTypedConstraint *)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  int arg2 ;
  btTypedConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btTypedConstraint *)((btDiscreteDynamicsWorld const *)arg1)->getConstraint(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTypedConstraint *)0;
  }
}


EXPORT btDynamicsWorldType _wrap_btDiscreteDynamicsWorld_getWorldType (btDiscreteDynamicsWorld *larg1) {
  btDynamicsWorldType lresult = (btDynamicsWorldType)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btDynamicsWorldType result;
  
  arg1 = larg1;
  try {
    result = (btDynamicsWorldType)((btDiscreteDynamicsWorld const *)arg1)->getWorldType();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDynamicsWorldType)0;
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_clearForces (btDiscreteDynamicsWorld *larg1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->clearForces();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_applyGravity (btDiscreteDynamicsWorld *larg1) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->applyGravity();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_setNumTasks (btDiscreteDynamicsWorld *larg1, int larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setNumTasks(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_updateVehicles (btDiscreteDynamicsWorld *larg1, btScalar larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->updateVehicles(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_addVehicle (btDiscreteDynamicsWorld *larg1, btActionInterface *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addVehicle(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_removeVehicle (btDiscreteDynamicsWorld *larg1, btActionInterface *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeVehicle(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_addCharacter (btDiscreteDynamicsWorld *larg1, btActionInterface *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addCharacter(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_removeCharacter (btDiscreteDynamicsWorld *larg1, btActionInterface *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeCharacter(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_setSynchronizeAllMotionStates (btDiscreteDynamicsWorld *larg1, int larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->setSynchronizeAllMotionStates(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btDiscreteDynamicsWorld_getSynchronizeAllMotionStates (btDiscreteDynamicsWorld *larg1) {
  int lresult = (int)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btDiscreteDynamicsWorld const *)arg1)->getSynchronizeAllMotionStates();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_setApplySpeculativeContactRestitution (btDiscreteDynamicsWorld *larg1, int larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->setApplySpeculativeContactRestitution(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btDiscreteDynamicsWorld_getApplySpeculativeContactRestitution (btDiscreteDynamicsWorld *larg1) {
  int lresult = (int)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btDiscreteDynamicsWorld const *)arg1)->getApplySpeculativeContactRestitution();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_serialize (btDiscreteDynamicsWorld *larg1, btSerializer *larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->serialize(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDiscreteDynamicsWorld_setLatencyMotionStateInterpolation (btDiscreteDynamicsWorld *larg1, int larg2) {
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->setLatencyMotionStateInterpolation(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btDiscreteDynamicsWorld_getLatencyMotionStateInterpolation (btDiscreteDynamicsWorld *larg1) {
  int lresult = (int)0 ;
  btDiscreteDynamicsWorld *arg1 = (btDiscreteDynamicsWorld *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btDiscreteDynamicsWorld const *)arg1)->getLatencyMotionStateInterpolation();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btSimpleDynamicsWorld *_wrap_new_btSimpleDynamicsWorld (btDispatcher *larg1, btBroadphaseInterface *larg2, btConstraintSolver *larg3, btCollisionConfiguration *larg4) {
  btSimpleDynamicsWorld * lresult = (btSimpleDynamicsWorld *)0 ;
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btBroadphaseInterface *arg2 = (btBroadphaseInterface *) 0 ;
  btConstraintSolver *arg3 = (btConstraintSolver *) 0 ;
  btCollisionConfiguration *arg4 = (btCollisionConfiguration *) 0 ;
  btSimpleDynamicsWorld *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btSimpleDynamicsWorld *)new btSimpleDynamicsWorld(arg1,arg2,arg3,arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSimpleDynamicsWorld *)0;
  }
}


EXPORT void _wrap_delete_btSimpleDynamicsWorld (btSimpleDynamicsWorld *larg1) {
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btSimpleDynamicsWorld_stepSimulation__SWIG_0 (btSimpleDynamicsWorld *larg1, btScalar larg2, int larg3, btScalar larg4) {
  int lresult = (int)0 ;
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btScalar arg2 ;
  int arg3 ;
  btScalar arg4 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (int)(arg1)->stepSimulation(arg2,arg3,arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btSimpleDynamicsWorld_stepSimulation__SWIG_1 (btSimpleDynamicsWorld *larg1, btScalar larg2, int larg3) {
  int lresult = (int)0 ;
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btScalar arg2 ;
  int arg3 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (int)(arg1)->stepSimulation(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btSimpleDynamicsWorld_stepSimulation__SWIG_2 (btSimpleDynamicsWorld *larg1, btScalar larg2) {
  int lresult = (int)0 ;
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btScalar arg2 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (int)(arg1)->stepSimulation(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btSimpleDynamicsWorld_setGravity (btSimpleDynamicsWorld *larg1, btVector3 *larg2) {
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setGravity((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btSimpleDynamicsWorld_getGravity (btSimpleDynamicsWorld *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  try {
    result = ((btSimpleDynamicsWorld const *)arg1)->getGravity();
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btSimpleDynamicsWorld_addRigidBody__SWIG_0 (btSimpleDynamicsWorld *larg1, btRigidBody *larg2) {
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addRigidBody(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSimpleDynamicsWorld_addRigidBody__SWIG_1 (btSimpleDynamicsWorld *larg1, btRigidBody *larg2, short larg3, short larg4) {
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  short arg3 ;
  short arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->addRigidBody(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSimpleDynamicsWorld_removeRigidBody (btSimpleDynamicsWorld *larg1, btRigidBody *larg2) {
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btRigidBody *arg2 = (btRigidBody *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeRigidBody(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSimpleDynamicsWorld_debugDrawWorld (btSimpleDynamicsWorld *larg1) {
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->debugDrawWorld();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSimpleDynamicsWorld_addAction (btSimpleDynamicsWorld *larg1, btActionInterface *larg2) {
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addAction(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSimpleDynamicsWorld_removeAction (btSimpleDynamicsWorld *larg1, btActionInterface *larg2) {
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btActionInterface *arg2 = (btActionInterface *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeAction(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSimpleDynamicsWorld_removeCollisionObject (btSimpleDynamicsWorld *larg1, btCollisionObject *larg2) {
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeCollisionObject(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSimpleDynamicsWorld_updateAabbs (btSimpleDynamicsWorld *larg1) {
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->updateAabbs();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSimpleDynamicsWorld_synchronizeMotionStates (btSimpleDynamicsWorld *larg1) {
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->synchronizeMotionStates();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSimpleDynamicsWorld_setConstraintSolver (btSimpleDynamicsWorld *larg1, btConstraintSolver *larg2) {
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btConstraintSolver *arg2 = (btConstraintSolver *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setConstraintSolver(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btConstraintSolver *_wrap_btSimpleDynamicsWorld_getConstraintSolver (btSimpleDynamicsWorld *larg1) {
  btConstraintSolver * lresult = (btConstraintSolver *)0 ;
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btConstraintSolver *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btConstraintSolver *)(arg1)->getConstraintSolver();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConstraintSolver *)0;
  }
}


EXPORT btDynamicsWorldType _wrap_btSimpleDynamicsWorld_getWorldType (btSimpleDynamicsWorld *larg1) {
  btDynamicsWorldType lresult = (btDynamicsWorldType)0 ;
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  btDynamicsWorldType result;
  
  arg1 = larg1;
  try {
    result = (btDynamicsWorldType)((btSimpleDynamicsWorld const *)arg1)->getWorldType();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDynamicsWorldType)0;
  }
}


EXPORT void _wrap_btSimpleDynamicsWorld_clearForces (btSimpleDynamicsWorld *larg1) {
  btSimpleDynamicsWorld *arg1 = (btSimpleDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->clearForces();
    
  } catch (...) {
    
  }
}


EXPORT btRigidBody *_wrap_new_btRigidBody__SWIG_0 (btRigidBody::btRigidBodyConstructionInfo *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btRigidBody::btRigidBodyConstructionInfo *arg1 = 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *)new btRigidBody((btRigidBody::btRigidBodyConstructionInfo const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT btRigidBody *_wrap_new_btRigidBody__SWIG_1 (btScalar larg1, btMotionState *larg2, btCollisionShape *larg3, btVector3 *larg4) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btScalar arg1 ;
  btMotionState *arg2 = (btMotionState *) 0 ;
  btCollisionShape *arg3 = (btCollisionShape *) 0 ;
  btVector3 *arg4 = 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btRigidBody *)new btRigidBody(arg1,arg2,arg3,(btVector3 const &)*arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT btRigidBody *_wrap_new_btRigidBody__SWIG_2 (btScalar larg1, btMotionState *larg2, btCollisionShape *larg3) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btScalar arg1 ;
  btMotionState *arg2 = (btMotionState *) 0 ;
  btCollisionShape *arg3 = (btCollisionShape *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btRigidBody *)new btRigidBody(arg1,arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT void _wrap_delete_btRigidBody (btRigidBody *larg1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_proceedToTransform (btRigidBody *larg1, btTransform *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->proceedToTransform((btTransform const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btRigidBody *_wrap_btRigidBody_upcast__SWIG_0 (btCollisionObject *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *)btRigidBody::upcast((btCollisionObject const *)arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT btRigidBody *_wrap_btRigidBody_upcast__SWIG_1 (btCollisionObject *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *)btRigidBody::upcast(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT void _wrap_btRigidBody_predictIntegratedTransform (btRigidBody *larg1, btScalar larg2, btTransform *larg3) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  btTransform *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->predictIntegratedTransform(arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_saveKinematicState (btRigidBody *larg1, btScalar larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->saveKinematicState(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_applyGravity (btRigidBody *larg1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->applyGravity();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_setGravity (btRigidBody *larg1, btVector3 *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setGravity((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btRigidBody_getGravity (btRigidBody *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btRigidBody const *)arg1)->getGravity();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btRigidBody_setDamping (btRigidBody *larg1, btScalar larg2, btScalar larg3) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setDamping(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRigidBody_getLinearDamping (btRigidBody *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btRigidBody const *)arg1)->getLinearDamping();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btRigidBody_getAngularDamping (btRigidBody *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btRigidBody const *)arg1)->getAngularDamping();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btRigidBody_getLinearSleepingThreshold (btRigidBody *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btRigidBody const *)arg1)->getLinearSleepingThreshold();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btRigidBody_getAngularSleepingThreshold (btRigidBody *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btRigidBody const *)arg1)->getAngularSleepingThreshold();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRigidBody_applyDamping (btRigidBody *larg1, btScalar larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->applyDamping(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btCollisionShape *_wrap_btRigidBody_getCollisionShape__SWIG_0 (btRigidBody *larg1) {
  btCollisionShape * lresult = (btCollisionShape *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btCollisionShape *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btCollisionShape *)((btRigidBody const *)arg1)->getCollisionShape();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionShape *)0;
  }
}


EXPORT btCollisionShape *_wrap_btRigidBody_getCollisionShape__SWIG_1 (btRigidBody *larg1) {
  btCollisionShape * lresult = (btCollisionShape *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btCollisionShape *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btCollisionShape *)(arg1)->getCollisionShape();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionShape *)0;
  }
}


EXPORT void _wrap_btRigidBody_setMassProps (btRigidBody *larg1, btScalar larg2, btVector3 *larg3) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setMassProps(arg2,(btVector3 const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btRigidBody_getLinearFactor (btRigidBody *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btRigidBody const *)arg1)->getLinearFactor();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btRigidBody_setLinearFactor (btRigidBody *larg1, btVector3 *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLinearFactor((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRigidBody_getInvMass (btRigidBody *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btRigidBody const *)arg1)->getInvMass();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btMatrix3x3 *_wrap_btRigidBody_getInvInertiaTensorWorld (btRigidBody *larg1) {
  btMatrix3x3 * lresult = (btMatrix3x3 *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btMatrix3x3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btMatrix3x3 *) &((btRigidBody const *)arg1)->getInvInertiaTensorWorld();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMatrix3x3 *)0;
  }
}


EXPORT void _wrap_btRigidBody_integrateVelocities (btRigidBody *larg1, btScalar larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->integrateVelocities(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_setCenterOfMassTransform (btRigidBody *larg1, btTransform *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setCenterOfMassTransform((btTransform const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_applyCentralForce (btRigidBody *larg1, btVector3 *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->applyCentralForce((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btRigidBody_getTotalForce (btRigidBody *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btRigidBody const *)arg1)->getTotalForce();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btRigidBody_getTotalTorque (btRigidBody *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btRigidBody const *)arg1)->getTotalTorque();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btRigidBody_getInvInertiaDiagLocal (btRigidBody *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btRigidBody const *)arg1)->getInvInertiaDiagLocal();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btRigidBody_setInvInertiaDiagLocal (btRigidBody *larg1, btVector3 *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setInvInertiaDiagLocal((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_setSleepingThresholds (btRigidBody *larg1, btScalar larg2, btScalar larg3) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setSleepingThresholds(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_applyTorque (btRigidBody *larg1, btVector3 *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->applyTorque((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_applyForce (btRigidBody *larg1, btVector3 *larg2, btVector3 *larg3) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->applyForce((btVector3 const &)*arg2,(btVector3 const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_applyCentralImpulse (btRigidBody *larg1, btVector3 *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->applyCentralImpulse((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_applyTorqueImpulse (btRigidBody *larg1, btVector3 *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->applyTorqueImpulse((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_applyImpulse (btRigidBody *larg1, btVector3 *larg2, btVector3 *larg3) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->applyImpulse((btVector3 const &)*arg2,(btVector3 const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_clearForces (btRigidBody *larg1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->clearForces();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_updateInertiaTensor (btRigidBody *larg1) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->updateInertiaTensor();
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btRigidBody_getCenterOfMassPosition (btRigidBody *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btRigidBody const *)arg1)->getCenterOfMassPosition();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btQuaternion *_wrap_btRigidBody_getOrientation (btRigidBody *larg1) {
  btQuaternion * lresult = (btQuaternion *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btQuaternion result;
  
  arg1 = larg1;
  try {
    result = ((btRigidBody const *)arg1)->getOrientation();
    lresult = new btQuaternion(result);
    return lresult;
  } catch (...) {
    return (btQuaternion *)0;
  }
}


EXPORT btTransform *_wrap_btRigidBody_getCenterOfMassTransform (btRigidBody *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btRigidBody const *)arg1)->getCenterOfMassTransform();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btVector3 *_wrap_btRigidBody_getLinearVelocity (btRigidBody *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btRigidBody const *)arg1)->getLinearVelocity();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btRigidBody_getAngularVelocity (btRigidBody *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btRigidBody const *)arg1)->getAngularVelocity();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btRigidBody_setLinearVelocity (btRigidBody *larg1, btVector3 *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLinearVelocity((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_setAngularVelocity (btRigidBody *larg1, btVector3 *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setAngularVelocity((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btRigidBody_getVelocityInLocalPoint (btRigidBody *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btRigidBody const *)arg1)->getVelocityInLocalPoint((btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btRigidBody_translate (btRigidBody *larg1, btVector3 *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->translate((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_getAabb (btRigidBody *larg1, btVector3 *larg2, btVector3 *larg3) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btRigidBody const *)arg1)->getAabb(*arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRigidBody_computeImpulseDenominator (btRigidBody *larg1, btVector3 *larg2, btVector3 *larg3) {
  btScalar lresult = (btScalar)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)((btRigidBody const *)arg1)->computeImpulseDenominator((btVector3 const &)*arg2,(btVector3 const &)*arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btRigidBody_computeAngularImpulseDenominator (btRigidBody *larg1, btVector3 *larg2) {
  btScalar lresult = (btScalar)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btRigidBody const *)arg1)->computeAngularImpulseDenominator((btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRigidBody_updateDeactivation (btRigidBody *larg1, btScalar larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->updateDeactivation(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btRigidBody_wantsSleeping (btRigidBody *larg1) {
  int lresult = (int)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->wantsSleeping();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btBroadphaseProxy *_wrap_btRigidBody_getBroadphaseProxy__SWIG_0 (btRigidBody *larg1) {
  btBroadphaseProxy * lresult = (btBroadphaseProxy *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btBroadphaseProxy *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btBroadphaseProxy *)((btRigidBody const *)arg1)->getBroadphaseProxy();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphaseProxy *)0;
  }
}


EXPORT btBroadphaseProxy *_wrap_btRigidBody_getBroadphaseProxy__SWIG_1 (btRigidBody *larg1) {
  btBroadphaseProxy * lresult = (btBroadphaseProxy *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btBroadphaseProxy *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btBroadphaseProxy *)(arg1)->getBroadphaseProxy();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btBroadphaseProxy *)0;
  }
}


EXPORT void _wrap_btRigidBody_setNewBroadphaseProxy (btRigidBody *larg1, btBroadphaseProxy *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btBroadphaseProxy *arg2 = (btBroadphaseProxy *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setNewBroadphaseProxy(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btMotionState *_wrap_btRigidBody_getMotionState__SWIG_0 (btRigidBody *larg1) {
  btMotionState * lresult = (btMotionState *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btMotionState *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btMotionState *)(arg1)->getMotionState();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMotionState *)0;
  }
}


EXPORT btMotionState *_wrap_btRigidBody_getMotionState__SWIG_1 (btRigidBody *larg1) {
  btMotionState * lresult = (btMotionState *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btMotionState *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btMotionState *)((btRigidBody const *)arg1)->getMotionState();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btMotionState *)0;
  }
}


EXPORT void _wrap_btRigidBody_setMotionState (btRigidBody *larg1, btMotionState *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btMotionState *arg2 = (btMotionState *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMotionState(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_m_contactSolverType_set (btRigidBody *larg1, int larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_contactSolverType = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btRigidBody_m_contactSolverType_get (btRigidBody *larg1) {
  int lresult = (int)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int) ((arg1)->m_contactSolverType);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btRigidBody_m_frictionSolverType_set (btRigidBody *larg1, int larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_frictionSolverType = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btRigidBody_m_frictionSolverType_get (btRigidBody *larg1) {
  int lresult = (int)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int) ((arg1)->m_frictionSolverType);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btRigidBody_setAngularFactor__SWIG_0 (btRigidBody *larg1, btVector3 *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setAngularFactor((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_setAngularFactor__SWIG_1 (btRigidBody *larg1, btScalar larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setAngularFactor(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btRigidBody_getAngularFactor (btRigidBody *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btRigidBody const *)arg1)->getAngularFactor();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT int _wrap_btRigidBody_isInWorld (btRigidBody *larg1) {
  int lresult = (int)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btRigidBody const *)arg1)->isInWorld();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btRigidBody_addConstraintRef (btRigidBody *larg1, btTypedConstraint *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addConstraintRef(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRigidBody_removeConstraintRef (btRigidBody *larg1, btTypedConstraint *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btTypedConstraint *arg2 = (btTypedConstraint *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeConstraintRef(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btTypedConstraint *_wrap_btRigidBody_getConstraintRef (btRigidBody *larg1, int larg2) {
  btTypedConstraint * lresult = (btTypedConstraint *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  btTypedConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btTypedConstraint *)(arg1)->getConstraintRef(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTypedConstraint *)0;
  }
}


EXPORT int _wrap_btRigidBody_getNumConstraintRefs (btRigidBody *larg1) {
  int lresult = (int)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btRigidBody const *)arg1)->getNumConstraintRefs();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btRigidBody_setFlags (btRigidBody *larg1, int larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setFlags(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btRigidBody_getFlags (btRigidBody *larg1) {
  int lresult = (int)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btRigidBody const *)arg1)->getFlags();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btVector3 *_wrap_btRigidBody_computeGyroscopicImpulseImplicit_World (btRigidBody *larg1, btScalar larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btRigidBody const *)arg1)->computeGyroscopicImpulseImplicit_World(arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btRigidBody_computeGyroscopicImpulseImplicit_Body (btRigidBody *larg1, btScalar larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btRigidBody const *)arg1)->computeGyroscopicImpulseImplicit_Body(arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btRigidBody_computeGyroscopicForceExplicit (btRigidBody *larg1, btScalar larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btScalar arg2 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btRigidBody const *)arg1)->computeGyroscopicForceExplicit(arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btRigidBody_getLocalInertia (btRigidBody *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  try {
    result = ((btRigidBody const *)arg1)->getLocalInertia();
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT int _wrap_btRigidBody_calculateSerializeBufferSize (btRigidBody *larg1) {
  int lresult = (int)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btRigidBody const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btRigidBody_serialize (btRigidBody *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btRigidBody const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_btRigidBody_serializeSingleObject (btRigidBody *larg1, btSerializer *larg2) {
  btRigidBody *arg1 = (btRigidBody *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btRigidBody const *)arg1)->serializeSingleObject(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btConstraintSolver (btConstraintSolver *larg1) {
  btConstraintSolver *arg1 = (btConstraintSolver *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConstraintSolver_prepareSolve (btConstraintSolver *larg1, int larg2, int larg3) {
  btConstraintSolver *arg1 = (btConstraintSolver *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->prepareSolve(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btConstraintSolver_solveGroup (btConstraintSolver *larg1, btCollisionObject **larg2, int larg3, btPersistentManifold **larg4, int larg5, btTypedConstraint **larg6, int larg7, btContactSolverInfo *larg8, btIDebugDraw *larg9, btDispatcher *larg10) {
  btScalar lresult = (btScalar)0 ;
  btConstraintSolver *arg1 = (btConstraintSolver *) 0 ;
  btCollisionObject **arg2 = (btCollisionObject **) 0 ;
  int arg3 ;
  btPersistentManifold **arg4 = (btPersistentManifold **) 0 ;
  int arg5 ;
  btTypedConstraint **arg6 = (btTypedConstraint **) 0 ;
  int arg7 ;
  btContactSolverInfo *arg8 = 0 ;
  btIDebugDraw *arg9 = (btIDebugDraw *) 0 ;
  btDispatcher *arg10 = (btDispatcher *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  arg10 = larg10;
  try {
    result = (btScalar)(arg1)->solveGroup(arg2,arg3,arg4,arg5,arg6,arg7,(btContactSolverInfo const &)*arg8,arg9,arg10);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btConstraintSolver_allSolved (btConstraintSolver *larg1, btContactSolverInfo *larg2, btIDebugDraw *larg3) {
  btConstraintSolver *arg1 = (btConstraintSolver *) 0 ;
  btContactSolverInfo *arg2 = 0 ;
  btIDebugDraw *arg3 = (btIDebugDraw *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->allSolved((btContactSolverInfo const &)*arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConstraintSolver_reset (btConstraintSolver *larg1) {
  btConstraintSolver *arg1 = (btConstraintSolver *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->reset();
    
  } catch (...) {
    
  }
}


EXPORT btConstraintSolverType _wrap_btConstraintSolver_getSolverType (btConstraintSolver *larg1) {
  btConstraintSolverType lresult = (btConstraintSolverType)0 ;
  btConstraintSolver *arg1 = (btConstraintSolver *) 0 ;
  btConstraintSolverType result;
  
  arg1 = larg1;
  try {
    result = (btConstraintSolverType)((btConstraintSolver const *)arg1)->getSolverType();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConstraintSolverType)0;
  }
}


EXPORT void _wrap_delete_btTypedConstraint (btTypedConstraint *larg1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btRigidBody *_wrap_btTypedConstraint_getFixedBody () {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btRigidBody *result = 0 ;
  
  try {
    result = (btRigidBody *) &btTypedConstraint::getFixedBody();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT int _wrap_btTypedConstraint_getOverrideNumSolverIterations (btTypedConstraint *larg1) {
  int lresult = (int)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btTypedConstraint const *)arg1)->getOverrideNumSolverIterations();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btTypedConstraint_setOverrideNumSolverIterations (btTypedConstraint *larg1, int larg2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setOverrideNumSolverIterations(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTypedConstraint_buildJacobian (btTypedConstraint *larg1) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->buildJacobian();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTypedConstraint_setupSolverConstraint (btTypedConstraint *larg1, btConstraintArray *larg2, int larg3, int larg4, btScalar larg5) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btConstraintArray *arg2 = 0 ;
  int arg3 ;
  int arg4 ;
  btScalar arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->setupSolverConstraint(*arg2,arg3,arg4,arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTypedConstraint_getInfo1 (btTypedConstraint *larg1, btTypedConstraint::btConstraintInfo1 *larg2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo1(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTypedConstraint_getInfo2 (btTypedConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo2(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTypedConstraint_internalSetAppliedImpulse (btTypedConstraint *larg1, btScalar larg2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->internalSetAppliedImpulse(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btTypedConstraint_internalGetAppliedImpulse (btTypedConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->internalGetAppliedImpulse();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btTypedConstraint_getBreakingImpulseThreshold (btTypedConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btTypedConstraint const *)arg1)->getBreakingImpulseThreshold();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btTypedConstraint_setBreakingImpulseThreshold (btTypedConstraint *larg1, btScalar larg2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setBreakingImpulseThreshold(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btTypedConstraint_isEnabled (btTypedConstraint *larg1) {
  int lresult = (int)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btTypedConstraint const *)arg1)->isEnabled();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btTypedConstraint_setEnabled (btTypedConstraint *larg1, int larg2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->setEnabled(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTypedConstraint_solveConstraintObsolete (btTypedConstraint *larg1, btSolverBody *larg2, btSolverBody *larg3, btScalar larg4) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btSolverBody *arg2 = 0 ;
  btSolverBody *arg3 = 0 ;
  btScalar arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->solveConstraintObsolete(*arg2,*arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT btRigidBody *_wrap_btTypedConstraint_getRigidBodyA__SWIG_0 (btTypedConstraint *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *) &((btTypedConstraint const *)arg1)->getRigidBodyA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT btRigidBody *_wrap_btTypedConstraint_getRigidBodyB__SWIG_0 (btTypedConstraint *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *) &((btTypedConstraint const *)arg1)->getRigidBodyB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT btRigidBody *_wrap_btTypedConstraint_getRigidBodyA__SWIG_1 (btTypedConstraint *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *) &(arg1)->getRigidBodyA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT btRigidBody *_wrap_btTypedConstraint_getRigidBodyB__SWIG_1 (btTypedConstraint *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *) &(arg1)->getRigidBodyB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT int _wrap_btTypedConstraint_getUserConstraintType (btTypedConstraint *larg1) {
  int lresult = (int)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btTypedConstraint const *)arg1)->getUserConstraintType();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btTypedConstraint_setUserConstraintType (btTypedConstraint *larg1, int larg2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setUserConstraintType(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTypedConstraint_setUserConstraintId (btTypedConstraint *larg1, int larg2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setUserConstraintId(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btTypedConstraint_getUserConstraintId (btTypedConstraint *larg1) {
  int lresult = (int)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btTypedConstraint const *)arg1)->getUserConstraintId();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btTypedConstraint_setUserConstraintPtr (btTypedConstraint *larg1, void *larg2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setUserConstraintPtr(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void *_wrap_btTypedConstraint_getUserConstraintPtr (btTypedConstraint *larg1) {
  void * lresult = (void *)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  void *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (void *)(arg1)->getUserConstraintPtr();
    lresult = result;
    return lresult;
  } catch (...) {
    return (void *)0;
  }
}


EXPORT void _wrap_btTypedConstraint_setJointFeedback (btTypedConstraint *larg1, btJointFeedback *larg2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btJointFeedback *arg2 = (btJointFeedback *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setJointFeedback(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btJointFeedback *_wrap_btTypedConstraint_getJointFeedback__SWIG_0 (btTypedConstraint *larg1) {
  btJointFeedback * lresult = (btJointFeedback *)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btJointFeedback *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btJointFeedback *)((btTypedConstraint const *)arg1)->getJointFeedback();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btJointFeedback *)0;
  }
}


EXPORT btJointFeedback *_wrap_btTypedConstraint_getJointFeedback__SWIG_1 (btTypedConstraint *larg1) {
  btJointFeedback * lresult = (btJointFeedback *)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btJointFeedback *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btJointFeedback *)(arg1)->getJointFeedback();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btJointFeedback *)0;
  }
}


EXPORT int _wrap_btTypedConstraint_getUid (btTypedConstraint *larg1) {
  int lresult = (int)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btTypedConstraint const *)arg1)->getUid();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btTypedConstraint_needsFeedback (btTypedConstraint *larg1) {
  int lresult = (int)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btTypedConstraint const *)arg1)->needsFeedback();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btTypedConstraint_enableFeedback (btTypedConstraint *larg1, int larg2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->enableFeedback(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btTypedConstraint_getAppliedImpulse (btTypedConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btTypedConstraint const *)arg1)->getAppliedImpulse();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btTypedConstraintType _wrap_btTypedConstraint_getConstraintType (btTypedConstraint *larg1) {
  btTypedConstraintType lresult = (btTypedConstraintType)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btTypedConstraintType result;
  
  arg1 = larg1;
  try {
    result = (btTypedConstraintType)((btTypedConstraint const *)arg1)->getConstraintType();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTypedConstraintType)0;
  }
}


EXPORT void _wrap_btTypedConstraint_setDbgDrawSize (btTypedConstraint *larg1, btScalar larg2) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setDbgDrawSize(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btTypedConstraint_getDbgDrawSize (btTypedConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getDbgDrawSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btTypedConstraint_setParam__SWIG_0 (btTypedConstraint *larg1, int larg2, btScalar larg3, int larg4) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setParam(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTypedConstraint_setParam__SWIG_1 (btTypedConstraint *larg1, int larg2, btScalar larg3) {
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setParam(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btTypedConstraint_getParam__SWIG_0 (btTypedConstraint *larg1, int larg2, int larg3) {
  btScalar lresult = (btScalar)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  int arg3 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)((btTypedConstraint const *)arg1)->getParam(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btTypedConstraint_getParam__SWIG_1 (btTypedConstraint *larg1, int larg2) {
  btScalar lresult = (btScalar)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btTypedConstraint const *)arg1)->getParam(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btTypedConstraint_calculateSerializeBufferSize (btTypedConstraint *larg1) {
  int lresult = (int)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btTypedConstraint const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btTypedConstraint_serialize (btTypedConstraint *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btTypedConstraint *arg1 = (btTypedConstraint *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btTypedConstraint const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT btScalar _wrap_btAdjustAngleToLimits (btScalar larg1, btScalar larg2, btScalar larg3) {
  btScalar lresult = (btScalar)0 ;
  btScalar arg1 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)btAdjustAngleToLimits(arg1,arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btAngularLimit *_wrap_new_btAngularLimit () {
  btAngularLimit * lresult = (btAngularLimit *)0 ;
  btAngularLimit *result = 0 ;
  
  try {
    result = (btAngularLimit *)new btAngularLimit();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btAngularLimit *)0;
  }
}


EXPORT void _wrap_btAngularLimit_set__SWIG_0 (btAngularLimit *larg1, btScalar larg2, btScalar larg3, btScalar larg4, btScalar larg5, btScalar larg6) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  btScalar arg5 ;
  btScalar arg6 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    (arg1)->set(arg2,arg3,arg4,arg5,arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btAngularLimit_set__SWIG_1 (btAngularLimit *larg1, btScalar larg2, btScalar larg3, btScalar larg4, btScalar larg5) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  btScalar arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->set(arg2,arg3,arg4,arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btAngularLimit_set__SWIG_2 (btAngularLimit *larg1, btScalar larg2, btScalar larg3, btScalar larg4) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->set(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btAngularLimit_set__SWIG_3 (btAngularLimit *larg1, btScalar larg2, btScalar larg3) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->set(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btAngularLimit_test (btAngularLimit *larg1, btScalar larg2) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->test(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btAngularLimit_getSoftness (btAngularLimit *larg1) {
  btScalar lresult = (btScalar)0 ;
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btAngularLimit const *)arg1)->getSoftness();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAngularLimit_getBiasFactor (btAngularLimit *larg1) {
  btScalar lresult = (btScalar)0 ;
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btAngularLimit const *)arg1)->getBiasFactor();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAngularLimit_getRelaxationFactor (btAngularLimit *larg1) {
  btScalar lresult = (btScalar)0 ;
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btAngularLimit const *)arg1)->getRelaxationFactor();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAngularLimit_getCorrection (btAngularLimit *larg1) {
  btScalar lresult = (btScalar)0 ;
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btAngularLimit const *)arg1)->getCorrection();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAngularLimit_getSign (btAngularLimit *larg1) {
  btScalar lresult = (btScalar)0 ;
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btAngularLimit const *)arg1)->getSign();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAngularLimit_getHalfRange (btAngularLimit *larg1) {
  btScalar lresult = (btScalar)0 ;
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btAngularLimit const *)arg1)->getHalfRange();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btAngularLimit_isLimit (btAngularLimit *larg1) {
  int lresult = (int)0 ;
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btAngularLimit const *)arg1)->isLimit();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btAngularLimit_fit (btAngularLimit *larg1, btScalar *larg2) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    ((btAngularLimit const *)arg1)->fit(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btAngularLimit_getError (btAngularLimit *larg1) {
  btScalar lresult = (btScalar)0 ;
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btAngularLimit const *)arg1)->getError();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAngularLimit_getLow (btAngularLimit *larg1) {
  btScalar lresult = (btScalar)0 ;
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btAngularLimit const *)arg1)->getLow();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btAngularLimit_getHigh (btAngularLimit *larg1) {
  btScalar lresult = (btScalar)0 ;
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btAngularLimit const *)arg1)->getHigh();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_delete_btAngularLimit (btAngularLimit *larg1) {
  btAngularLimit *arg1 = (btAngularLimit *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPoint2PointConstraint_m_useSolveConstraintObsolete_set (btPoint2PointConstraint *larg1, int larg2) {
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    if (arg1) (arg1)->m_useSolveConstraintObsolete = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btPoint2PointConstraint_m_useSolveConstraintObsolete_get (btPoint2PointConstraint *larg1) {
  int lresult = (int)0 ;
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool) ((arg1)->m_useSolveConstraintObsolete);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btPoint2PointConstraint_m_setting_set (btPoint2PointConstraint *larg1, btConstraintSetting *larg2) {
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  btConstraintSetting *arg2 = (btConstraintSetting *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_setting = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btConstraintSetting *_wrap_btPoint2PointConstraint_m_setting_get (btPoint2PointConstraint *larg1) {
  btConstraintSetting * lresult = (btConstraintSetting *)0 ;
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  btConstraintSetting *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btConstraintSetting *)& ((arg1)->m_setting);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConstraintSetting *)0;
  }
}


EXPORT btPoint2PointConstraint *_wrap_new_btPoint2PointConstraint__SWIG_0 (btRigidBody *larg1, btRigidBody *larg2, btVector3 *larg3, btVector3 *larg4) {
  btPoint2PointConstraint * lresult = (btPoint2PointConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btPoint2PointConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btPoint2PointConstraint *)new btPoint2PointConstraint(*arg1,*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPoint2PointConstraint *)0;
  }
}


EXPORT btPoint2PointConstraint *_wrap_new_btPoint2PointConstraint__SWIG_1 (btRigidBody *larg1, btVector3 *larg2) {
  btPoint2PointConstraint * lresult = (btPoint2PointConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btPoint2PointConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btPoint2PointConstraint *)new btPoint2PointConstraint(*arg1,(btVector3 const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btPoint2PointConstraint *)0;
  }
}


EXPORT void _wrap_btPoint2PointConstraint_buildJacobian (btPoint2PointConstraint *larg1) {
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->buildJacobian();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPoint2PointConstraint_getInfo1 (btPoint2PointConstraint *larg1, btTypedConstraint::btConstraintInfo1 *larg2) {
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo1(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPoint2PointConstraint_getInfo1NonVirtual (btPoint2PointConstraint *larg1, btTypedConstraint::btConstraintInfo1 *larg2) {
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo1NonVirtual(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPoint2PointConstraint_getInfo2 (btPoint2PointConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2) {
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo2(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPoint2PointConstraint_getInfo2NonVirtual (btPoint2PointConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2, btTransform *larg3, btTransform *larg4) {
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->getInfo2NonVirtual(arg2,(btTransform const &)*arg3,(btTransform const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPoint2PointConstraint_updateRHS (btPoint2PointConstraint *larg1, btScalar larg2) {
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->updateRHS(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPoint2PointConstraint_setPivotA (btPoint2PointConstraint *larg1, btVector3 *larg2) {
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setPivotA((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPoint2PointConstraint_setPivotB (btPoint2PointConstraint *larg1, btVector3 *larg2) {
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setPivotB((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btPoint2PointConstraint_getPivotInA (btPoint2PointConstraint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btPoint2PointConstraint const *)arg1)->getPivotInA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btPoint2PointConstraint_getPivotInB (btPoint2PointConstraint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &((btPoint2PointConstraint const *)arg1)->getPivotInB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btPoint2PointConstraint_setParam__SWIG_0 (btPoint2PointConstraint *larg1, int larg2, btScalar larg3, int larg4) {
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setParam(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btPoint2PointConstraint_setParam__SWIG_1 (btPoint2PointConstraint *larg1, int larg2, btScalar larg3) {
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setParam(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btPoint2PointConstraint_getParam__SWIG_0 (btPoint2PointConstraint *larg1, int larg2, int larg3) {
  btScalar lresult = (btScalar)0 ;
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  int arg2 ;
  int arg3 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)((btPoint2PointConstraint const *)arg1)->getParam(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btPoint2PointConstraint_getParam__SWIG_1 (btPoint2PointConstraint *larg1, int larg2) {
  btScalar lresult = (btScalar)0 ;
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  int arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btPoint2PointConstraint const *)arg1)->getParam(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btPoint2PointConstraint_calculateSerializeBufferSize (btPoint2PointConstraint *larg1) {
  int lresult = (int)0 ;
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btPoint2PointConstraint const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btPoint2PointConstraint_serialize (btPoint2PointConstraint *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btPoint2PointConstraint const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_delete_btPoint2PointConstraint (btPoint2PointConstraint *larg1) {
  btPoint2PointConstraint *arg1 = (btPoint2PointConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btHingeConstraint *_wrap_new_btHingeConstraint__SWIG_0 (btRigidBody *larg1, btRigidBody *larg2, btVector3 *larg3, btVector3 *larg4, btVector3 *larg5, btVector3 *larg6, int larg7) {
  btHingeConstraint * lresult = (btHingeConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  bool arg7 ;
  btHingeConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = (bool)larg7;
  try {
    result = (btHingeConstraint *)new btHingeConstraint(*arg1,*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6,arg7);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btHingeConstraint *)0;
  }
}


EXPORT btHingeConstraint *_wrap_new_btHingeConstraint__SWIG_1 (btRigidBody *larg1, btRigidBody *larg2, btVector3 *larg3, btVector3 *larg4, btVector3 *larg5, btVector3 *larg6) {
  btHingeConstraint * lresult = (btHingeConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btHingeConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    result = (btHingeConstraint *)new btHingeConstraint(*arg1,*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btHingeConstraint *)0;
  }
}


EXPORT btHingeConstraint *_wrap_new_btHingeConstraint__SWIG_2 (btRigidBody *larg1, btVector3 *larg2, btVector3 *larg3, int larg4) {
  btHingeConstraint * lresult = (btHingeConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  bool arg4 ;
  btHingeConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  try {
    result = (btHingeConstraint *)new btHingeConstraint(*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btHingeConstraint *)0;
  }
}


EXPORT btHingeConstraint *_wrap_new_btHingeConstraint__SWIG_3 (btRigidBody *larg1, btVector3 *larg2, btVector3 *larg3) {
  btHingeConstraint * lresult = (btHingeConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btHingeConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btHingeConstraint *)new btHingeConstraint(*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btHingeConstraint *)0;
  }
}


EXPORT btHingeConstraint *_wrap_new_btHingeConstraint__SWIG_4 (btRigidBody *larg1, btRigidBody *larg2, btTransform *larg3, btTransform *larg4, int larg5) {
  btHingeConstraint * lresult = (btHingeConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  bool arg5 ;
  btHingeConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = (bool)larg5;
  try {
    result = (btHingeConstraint *)new btHingeConstraint(*arg1,*arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,arg5);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btHingeConstraint *)0;
  }
}


EXPORT btHingeConstraint *_wrap_new_btHingeConstraint__SWIG_5 (btRigidBody *larg1, btRigidBody *larg2, btTransform *larg3, btTransform *larg4) {
  btHingeConstraint * lresult = (btHingeConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btHingeConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btHingeConstraint *)new btHingeConstraint(*arg1,*arg2,(btTransform const &)*arg3,(btTransform const &)*arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btHingeConstraint *)0;
  }
}


EXPORT btHingeConstraint *_wrap_new_btHingeConstraint__SWIG_6 (btRigidBody *larg1, btTransform *larg2, int larg3) {
  btHingeConstraint * lresult = (btHingeConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  bool arg3 ;
  btHingeConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    result = (btHingeConstraint *)new btHingeConstraint(*arg1,(btTransform const &)*arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btHingeConstraint *)0;
  }
}


EXPORT btHingeConstraint *_wrap_new_btHingeConstraint__SWIG_7 (btRigidBody *larg1, btTransform *larg2) {
  btHingeConstraint * lresult = (btHingeConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  btHingeConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btHingeConstraint *)new btHingeConstraint(*arg1,(btTransform const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btHingeConstraint *)0;
  }
}


EXPORT void _wrap_btHingeConstraint_buildJacobian (btHingeConstraint *larg1) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->buildJacobian();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_getInfo1 (btHingeConstraint *larg1, btTypedConstraint::btConstraintInfo1 *larg2) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo1(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_getInfo1NonVirtual (btHingeConstraint *larg1, btTypedConstraint::btConstraintInfo1 *larg2) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo1NonVirtual(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_getInfo2 (btHingeConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo2(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_getInfo2NonVirtual (btHingeConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2, btTransform *larg3, btTransform *larg4, btVector3 *larg5, btVector3 *larg6) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    (arg1)->getInfo2NonVirtual(arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_getInfo2Internal (btHingeConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2, btTransform *larg3, btTransform *larg4, btVector3 *larg5, btVector3 *larg6) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    (arg1)->getInfo2Internal(arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_getInfo2InternalUsingFrameOffset (btHingeConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2, btTransform *larg3, btTransform *larg4, btVector3 *larg5, btVector3 *larg6) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    (arg1)->getInfo2InternalUsingFrameOffset(arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_updateRHS (btHingeConstraint *larg1, btScalar larg2) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->updateRHS(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btRigidBody *_wrap_btHingeConstraint_getRigidBodyA__SWIG_0 (btHingeConstraint *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *) &((btHingeConstraint const *)arg1)->getRigidBodyA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT btRigidBody *_wrap_btHingeConstraint_getRigidBodyB__SWIG_0 (btHingeConstraint *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *) &((btHingeConstraint const *)arg1)->getRigidBodyB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT btRigidBody *_wrap_btHingeConstraint_getRigidBodyA__SWIG_1 (btHingeConstraint *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *) &(arg1)->getRigidBodyA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT btRigidBody *_wrap_btHingeConstraint_getRigidBodyB__SWIG_1 (btHingeConstraint *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *) &(arg1)->getRigidBodyB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT btTransform *_wrap_btHingeConstraint_getFrameOffsetA (btHingeConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &(arg1)->getFrameOffsetA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btHingeConstraint_getFrameOffsetB (btHingeConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &(arg1)->getFrameOffsetB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT void _wrap_btHingeConstraint_setFrames (btHingeConstraint *larg1, btTransform *larg2, btTransform *larg3) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setFrames((btTransform const &)*arg2,(btTransform const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_setAngularOnly (btHingeConstraint *larg1, int larg2) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->setAngularOnly(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_enableAngularMotor (btHingeConstraint *larg1, int larg2, btScalar larg3, btScalar larg4) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  bool arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->enableAngularMotor(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_enableMotor (btHingeConstraint *larg1, int larg2) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->enableMotor(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_setMaxMotorImpulse (btHingeConstraint *larg1, btScalar larg2) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMaxMotorImpulse(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_setMotorTarget__SWIG_0 (btHingeConstraint *larg1, btQuaternion *larg2, btScalar larg3) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btQuaternion *arg2 = 0 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setMotorTarget((btQuaternion const &)*arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_setMotorTarget__SWIG_1 (btHingeConstraint *larg1, btScalar larg2, btScalar larg3) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setMotorTarget(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_setLimit__SWIG_0 (btHingeConstraint *larg1, btScalar larg2, btScalar larg3, btScalar larg4, btScalar larg5, btScalar larg6) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  btScalar arg5 ;
  btScalar arg6 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    (arg1)->setLimit(arg2,arg3,arg4,arg5,arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_setLimit__SWIG_1 (btHingeConstraint *larg1, btScalar larg2, btScalar larg3, btScalar larg4, btScalar larg5) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  btScalar arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->setLimit(arg2,arg3,arg4,arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_setLimit__SWIG_2 (btHingeConstraint *larg1, btScalar larg2, btScalar larg3, btScalar larg4) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setLimit(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_setLimit__SWIG_3 (btHingeConstraint *larg1, btScalar larg2, btScalar larg3) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setLimit(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_setAxis (btHingeConstraint *larg1, btVector3 *larg2) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setAxis(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btHingeConstraint_hasLimit (btHingeConstraint *larg1) {
  int lresult = (int)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)((btHingeConstraint const *)arg1)->hasLimit();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btScalar _wrap_btHingeConstraint_getLowerLimit (btHingeConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btHingeConstraint const *)arg1)->getLowerLimit();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btHingeConstraint_getUpperLimit (btHingeConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btHingeConstraint const *)arg1)->getUpperLimit();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btHingeConstraint_getHingeAngle__SWIG_0 (btHingeConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getHingeAngle();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btHingeConstraint_getHingeAngle__SWIG_1 (btHingeConstraint *larg1, btTransform *larg2, btTransform *larg3) {
  btScalar lresult = (btScalar)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)(arg1)->getHingeAngle((btTransform const &)*arg2,(btTransform const &)*arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btHingeConstraint_testLimit (btHingeConstraint *larg1, btTransform *larg2, btTransform *larg3) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->testLimit((btTransform const &)*arg2,(btTransform const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT btTransform *_wrap_btHingeConstraint_getAFrame__SWIG_0 (btHingeConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btHingeConstraint const *)arg1)->getAFrame();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btHingeConstraint_getBFrame__SWIG_0 (btHingeConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btHingeConstraint const *)arg1)->getBFrame();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btHingeConstraint_getAFrame__SWIG_1 (btHingeConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &(arg1)->getAFrame();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btHingeConstraint_getBFrame__SWIG_1 (btHingeConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &(arg1)->getBFrame();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT int _wrap_btHingeConstraint_getSolveLimit (btHingeConstraint *larg1) {
  int lresult = (int)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)(arg1)->getSolveLimit();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btScalar _wrap_btHingeConstraint_getLimitSign (btHingeConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getLimitSign();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btHingeConstraint_getAngularOnly (btHingeConstraint *larg1) {
  int lresult = (int)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->getAngularOnly();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btHingeConstraint_getEnableAngularMotor (btHingeConstraint *larg1) {
  int lresult = (int)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->getEnableAngularMotor();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btScalar _wrap_btHingeConstraint_getMotorTargetVelosity (btHingeConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getMotorTargetVelosity();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btHingeConstraint_getMaxMotorImpulse (btHingeConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getMaxMotorImpulse();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btHingeConstraint_getUseFrameOffset (btHingeConstraint *larg1) {
  int lresult = (int)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->getUseFrameOffset();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btHingeConstraint_setUseFrameOffset (btHingeConstraint *larg1, int larg2) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->setUseFrameOffset(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_setParam__SWIG_0 (btHingeConstraint *larg1, int larg2, btScalar larg3, int larg4) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setParam(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeConstraint_setParam__SWIG_1 (btHingeConstraint *larg1, int larg2, btScalar larg3) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setParam(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btHingeConstraint_getParam__SWIG_0 (btHingeConstraint *larg1, int larg2, int larg3) {
  btScalar lresult = (btScalar)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  int arg2 ;
  int arg3 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)((btHingeConstraint const *)arg1)->getParam(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btHingeConstraint_getParam__SWIG_1 (btHingeConstraint *larg1, int larg2) {
  btScalar lresult = (btScalar)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  int arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btHingeConstraint const *)arg1)->getParam(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btHingeConstraint_calculateSerializeBufferSize (btHingeConstraint *larg1) {
  int lresult = (int)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btHingeConstraint const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btHingeConstraint_serialize (btHingeConstraint *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btHingeConstraint const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_delete_btHingeConstraint (btHingeConstraint *larg1) {
  btHingeConstraint *arg1 = (btHingeConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btHingeAccumulatedAngleConstraint *_wrap_new_btHingeAccumulatedAngleConstraint__SWIG_0 (btRigidBody *larg1, btRigidBody *larg2, btVector3 *larg3, btVector3 *larg4, btVector3 *larg5, btVector3 *larg6, int larg7) {
  btHingeAccumulatedAngleConstraint * lresult = (btHingeAccumulatedAngleConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  bool arg7 ;
  btHingeAccumulatedAngleConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = (bool)larg7;
  try {
    result = (btHingeAccumulatedAngleConstraint *)new btHingeAccumulatedAngleConstraint(*arg1,*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6,arg7);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btHingeAccumulatedAngleConstraint *)0;
  }
}


EXPORT btHingeAccumulatedAngleConstraint *_wrap_new_btHingeAccumulatedAngleConstraint__SWIG_1 (btRigidBody *larg1, btRigidBody *larg2, btVector3 *larg3, btVector3 *larg4, btVector3 *larg5, btVector3 *larg6) {
  btHingeAccumulatedAngleConstraint * lresult = (btHingeAccumulatedAngleConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btHingeAccumulatedAngleConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    result = (btHingeAccumulatedAngleConstraint *)new btHingeAccumulatedAngleConstraint(*arg1,*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btHingeAccumulatedAngleConstraint *)0;
  }
}


EXPORT btHingeAccumulatedAngleConstraint *_wrap_new_btHingeAccumulatedAngleConstraint__SWIG_2 (btRigidBody *larg1, btVector3 *larg2, btVector3 *larg3, int larg4) {
  btHingeAccumulatedAngleConstraint * lresult = (btHingeAccumulatedAngleConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  bool arg4 ;
  btHingeAccumulatedAngleConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  try {
    result = (btHingeAccumulatedAngleConstraint *)new btHingeAccumulatedAngleConstraint(*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btHingeAccumulatedAngleConstraint *)0;
  }
}


EXPORT btHingeAccumulatedAngleConstraint *_wrap_new_btHingeAccumulatedAngleConstraint__SWIG_3 (btRigidBody *larg1, btVector3 *larg2, btVector3 *larg3) {
  btHingeAccumulatedAngleConstraint * lresult = (btHingeAccumulatedAngleConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btHingeAccumulatedAngleConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btHingeAccumulatedAngleConstraint *)new btHingeAccumulatedAngleConstraint(*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btHingeAccumulatedAngleConstraint *)0;
  }
}


EXPORT btHingeAccumulatedAngleConstraint *_wrap_new_btHingeAccumulatedAngleConstraint__SWIG_4 (btRigidBody *larg1, btRigidBody *larg2, btTransform *larg3, btTransform *larg4, int larg5) {
  btHingeAccumulatedAngleConstraint * lresult = (btHingeAccumulatedAngleConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  bool arg5 ;
  btHingeAccumulatedAngleConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = (bool)larg5;
  try {
    result = (btHingeAccumulatedAngleConstraint *)new btHingeAccumulatedAngleConstraint(*arg1,*arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,arg5);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btHingeAccumulatedAngleConstraint *)0;
  }
}


EXPORT btHingeAccumulatedAngleConstraint *_wrap_new_btHingeAccumulatedAngleConstraint__SWIG_5 (btRigidBody *larg1, btRigidBody *larg2, btTransform *larg3, btTransform *larg4) {
  btHingeAccumulatedAngleConstraint * lresult = (btHingeAccumulatedAngleConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btHingeAccumulatedAngleConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btHingeAccumulatedAngleConstraint *)new btHingeAccumulatedAngleConstraint(*arg1,*arg2,(btTransform const &)*arg3,(btTransform const &)*arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btHingeAccumulatedAngleConstraint *)0;
  }
}


EXPORT btHingeAccumulatedAngleConstraint *_wrap_new_btHingeAccumulatedAngleConstraint__SWIG_6 (btRigidBody *larg1, btTransform *larg2, int larg3) {
  btHingeAccumulatedAngleConstraint * lresult = (btHingeAccumulatedAngleConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  bool arg3 ;
  btHingeAccumulatedAngleConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    result = (btHingeAccumulatedAngleConstraint *)new btHingeAccumulatedAngleConstraint(*arg1,(btTransform const &)*arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btHingeAccumulatedAngleConstraint *)0;
  }
}


EXPORT btHingeAccumulatedAngleConstraint *_wrap_new_btHingeAccumulatedAngleConstraint__SWIG_7 (btRigidBody *larg1, btTransform *larg2) {
  btHingeAccumulatedAngleConstraint * lresult = (btHingeAccumulatedAngleConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  btHingeAccumulatedAngleConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btHingeAccumulatedAngleConstraint *)new btHingeAccumulatedAngleConstraint(*arg1,(btTransform const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btHingeAccumulatedAngleConstraint *)0;
  }
}


EXPORT btScalar _wrap_btHingeAccumulatedAngleConstraint_getAccumulatedHingeAngle (btHingeAccumulatedAngleConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btHingeAccumulatedAngleConstraint *arg1 = (btHingeAccumulatedAngleConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getAccumulatedHingeAngle();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btHingeAccumulatedAngleConstraint_setAccumulatedHingeAngle (btHingeAccumulatedAngleConstraint *larg1, btScalar larg2) {
  btHingeAccumulatedAngleConstraint *arg1 = (btHingeAccumulatedAngleConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setAccumulatedHingeAngle(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHingeAccumulatedAngleConstraint_getInfo1 (btHingeAccumulatedAngleConstraint *larg1, btTypedConstraint::btConstraintInfo1 *larg2) {
  btHingeAccumulatedAngleConstraint *arg1 = (btHingeAccumulatedAngleConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo1(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btHingeAccumulatedAngleConstraint (btHingeAccumulatedAngleConstraint *larg1) {
  btHingeAccumulatedAngleConstraint *arg1 = (btHingeAccumulatedAngleConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btConeTwistConstraint *_wrap_new_btConeTwistConstraint__SWIG_0 (btRigidBody *larg1, btRigidBody *larg2, btTransform *larg3, btTransform *larg4) {
  btConeTwistConstraint * lresult = (btConeTwistConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btConeTwistConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btConeTwistConstraint *)new btConeTwistConstraint(*arg1,*arg2,(btTransform const &)*arg3,(btTransform const &)*arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConeTwistConstraint *)0;
  }
}


EXPORT btConeTwistConstraint *_wrap_new_btConeTwistConstraint__SWIG_1 (btRigidBody *larg1, btTransform *larg2) {
  btConeTwistConstraint * lresult = (btConeTwistConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  btConeTwistConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btConeTwistConstraint *)new btConeTwistConstraint(*arg1,(btTransform const &)*arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btConeTwistConstraint *)0;
  }
}


EXPORT void _wrap_btConeTwistConstraint_buildJacobian (btConeTwistConstraint *larg1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->buildJacobian();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_getInfo1 (btConeTwistConstraint *larg1, btTypedConstraint::btConstraintInfo1 *larg2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo1(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_getInfo1NonVirtual (btConeTwistConstraint *larg1, btTypedConstraint::btConstraintInfo1 *larg2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo1NonVirtual(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_getInfo2 (btConeTwistConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo2(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_getInfo2NonVirtual (btConeTwistConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2, btTransform *larg3, btTransform *larg4, btMatrix3x3 *larg5, btMatrix3x3 *larg6) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btMatrix3x3 *arg5 = 0 ;
  btMatrix3x3 *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    (arg1)->getInfo2NonVirtual(arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,(btMatrix3x3 const &)*arg5,(btMatrix3x3 const &)*arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_solveConstraintObsolete (btConeTwistConstraint *larg1, btSolverBody *larg2, btSolverBody *larg3, btScalar larg4) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btSolverBody *arg2 = 0 ;
  btSolverBody *arg3 = 0 ;
  btScalar arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->solveConstraintObsolete(*arg2,*arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_updateRHS (btConeTwistConstraint *larg1, btScalar larg2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->updateRHS(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btRigidBody *_wrap_btConeTwistConstraint_getRigidBodyA (btConeTwistConstraint *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *) &((btConeTwistConstraint const *)arg1)->getRigidBodyA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT btRigidBody *_wrap_btConeTwistConstraint_getRigidBodyB (btConeTwistConstraint *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *) &((btConeTwistConstraint const *)arg1)->getRigidBodyB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT void _wrap_btConeTwistConstraint_setAngularOnly (btConeTwistConstraint *larg1, int larg2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->setAngularOnly(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_setLimit__SWIG_0 (btConeTwistConstraint *larg1, int larg2, btScalar larg3) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setLimit(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_setLimit__SWIG_1 (btConeTwistConstraint *larg1, btScalar larg2, btScalar larg3, btScalar larg4, btScalar larg5, btScalar larg6, btScalar larg7) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  btScalar arg5 ;
  btScalar arg6 ;
  btScalar arg7 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  try {
    (arg1)->setLimit(arg2,arg3,arg4,arg5,arg6,arg7);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_setLimit__SWIG_2 (btConeTwistConstraint *larg1, btScalar larg2, btScalar larg3, btScalar larg4, btScalar larg5, btScalar larg6) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  btScalar arg5 ;
  btScalar arg6 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    (arg1)->setLimit(arg2,arg3,arg4,arg5,arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_setLimit__SWIG_3 (btConeTwistConstraint *larg1, btScalar larg2, btScalar larg3, btScalar larg4, btScalar larg5) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  btScalar arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->setLimit(arg2,arg3,arg4,arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_setLimit__SWIG_4 (btConeTwistConstraint *larg1, btScalar larg2, btScalar larg3, btScalar larg4) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setLimit(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT btTransform *_wrap_btConeTwistConstraint_getAFrame (btConeTwistConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &(arg1)->getAFrame();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btConeTwistConstraint_getBFrame (btConeTwistConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &(arg1)->getBFrame();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT int _wrap_btConeTwistConstraint_getSolveTwistLimit (btConeTwistConstraint *larg1) {
  int lresult = (int)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)(arg1)->getSolveTwistLimit();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btConeTwistConstraint_getSolveSwingLimit (btConeTwistConstraint *larg1) {
  int lresult = (int)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)(arg1)->getSolveSwingLimit();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btScalar _wrap_btConeTwistConstraint_getTwistLimitSign (btConeTwistConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getTwistLimitSign();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btConeTwistConstraint_calcAngleInfo (btConeTwistConstraint *larg1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->calcAngleInfo();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_calcAngleInfo2 (btConeTwistConstraint *larg1, btTransform *larg2, btTransform *larg3, btMatrix3x3 *larg4, btMatrix3x3 *larg5) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btMatrix3x3 *arg4 = 0 ;
  btMatrix3x3 *arg5 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->calcAngleInfo2((btTransform const &)*arg2,(btTransform const &)*arg3,(btMatrix3x3 const &)*arg4,(btMatrix3x3 const &)*arg5);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btConeTwistConstraint_getSwingSpan1 (btConeTwistConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getSwingSpan1();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btConeTwistConstraint_getSwingSpan2 (btConeTwistConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getSwingSpan2();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btConeTwistConstraint_getTwistSpan (btConeTwistConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getTwistSpan();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btConeTwistConstraint_getTwistAngle (btConeTwistConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getTwistAngle();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btConeTwistConstraint_isPastSwingLimit (btConeTwistConstraint *larg1) {
  int lresult = (int)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->isPastSwingLimit();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btConeTwistConstraint_setDamping (btConeTwistConstraint *larg1, btScalar larg2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setDamping(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_enableMotor (btConeTwistConstraint *larg1, int larg2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->enableMotor(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_setMaxMotorImpulse (btConeTwistConstraint *larg1, btScalar larg2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMaxMotorImpulse(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_setMaxMotorImpulseNormalized (btConeTwistConstraint *larg1, btScalar larg2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMaxMotorImpulseNormalized(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btConeTwistConstraint_getFixThresh (btConeTwistConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getFixThresh();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btConeTwistConstraint_setFixThresh (btConeTwistConstraint *larg1, btScalar larg2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setFixThresh(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_setMotorTarget (btConeTwistConstraint *larg1, btQuaternion *larg2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btQuaternion *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMotorTarget((btQuaternion const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_setMotorTargetInConstraintSpace (btConeTwistConstraint *larg1, btQuaternion *larg2) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btQuaternion *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMotorTargetInConstraintSpace((btQuaternion const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btConeTwistConstraint_GetPointForAngle (btConeTwistConstraint *larg1, btScalar larg2, btScalar larg3) {
  btVector3 * lresult = (btVector3 *)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = ((btConeTwistConstraint const *)arg1)->GetPointForAngle(arg2,arg3);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btConeTwistConstraint_setParam__SWIG_0 (btConeTwistConstraint *larg1, int larg2, btScalar larg3, int larg4) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setParam(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_setParam__SWIG_1 (btConeTwistConstraint *larg1, int larg2, btScalar larg3) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setParam(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btConeTwistConstraint_setFrames (btConeTwistConstraint *larg1, btTransform *larg2, btTransform *larg3) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setFrames((btTransform const &)*arg2,(btTransform const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT btTransform *_wrap_btConeTwistConstraint_getFrameOffsetA (btConeTwistConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btConeTwistConstraint const *)arg1)->getFrameOffsetA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btConeTwistConstraint_getFrameOffsetB (btConeTwistConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btConeTwistConstraint const *)arg1)->getFrameOffsetB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btScalar _wrap_btConeTwistConstraint_getParam__SWIG_0 (btConeTwistConstraint *larg1, int larg2, int larg3) {
  btScalar lresult = (btScalar)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int arg2 ;
  int arg3 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)((btConeTwistConstraint const *)arg1)->getParam(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btConeTwistConstraint_getParam__SWIG_1 (btConeTwistConstraint *larg1, int larg2) {
  btScalar lresult = (btScalar)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btConeTwistConstraint const *)arg1)->getParam(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btConeTwistConstraint_calculateSerializeBufferSize (btConeTwistConstraint *larg1) {
  int lresult = (int)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btConeTwistConstraint const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btConeTwistConstraint_serialize (btConeTwistConstraint *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btConeTwistConstraint const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_delete_btConeTwistConstraint (btConeTwistConstraint *larg1) {
  btConeTwistConstraint *arg1 = (btConeTwistConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_loLimit_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_loLimit = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_loLimit_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_loLimit);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_hiLimit_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_hiLimit = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_hiLimit_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_hiLimit);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_targetVelocity_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_targetVelocity = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_targetVelocity_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_targetVelocity);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_maxMotorForce_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_maxMotorForce = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_maxMotorForce_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_maxMotorForce);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_maxLimitForce_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_maxLimitForce = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_maxLimitForce_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_maxLimitForce);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_damping_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_damping = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_damping_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_damping);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_limitSoftness_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_limitSoftness = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_limitSoftness_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_limitSoftness);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_normalCFM_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_normalCFM = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_normalCFM_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_normalCFM);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_stopERP_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_stopERP = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_stopERP_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_stopERP);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_stopCFM_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_stopCFM = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_stopCFM_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_stopCFM);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_bounce_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_bounce = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_bounce_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_bounce);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_enableMotor_set (btRotationalLimitMotor *larg1, int larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    if (arg1) (arg1)->m_enableMotor = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btRotationalLimitMotor_m_enableMotor_get (btRotationalLimitMotor *larg1) {
  int lresult = (int)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool) ((arg1)->m_enableMotor);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_currentLimitError_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_currentLimitError = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_currentLimitError_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_currentLimitError);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_currentPosition_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_currentPosition = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_currentPosition_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_currentPosition);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_currentLimit_set (btRotationalLimitMotor *larg1, int larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_currentLimit = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btRotationalLimitMotor_m_currentLimit_get (btRotationalLimitMotor *larg1) {
  int lresult = (int)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int) ((arg1)->m_currentLimit);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btRotationalLimitMotor_m_accumulatedImpulse_set (btRotationalLimitMotor *larg1, btScalar larg2) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_accumulatedImpulse = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_m_accumulatedImpulse_get (btRotationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_accumulatedImpulse);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btRotationalLimitMotor *_wrap_new_btRotationalLimitMotor__SWIG_0 () {
  btRotationalLimitMotor * lresult = (btRotationalLimitMotor *)0 ;
  btRotationalLimitMotor *result = 0 ;
  
  try {
    result = (btRotationalLimitMotor *)new btRotationalLimitMotor();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRotationalLimitMotor *)0;
  }
}


EXPORT btRotationalLimitMotor *_wrap_new_btRotationalLimitMotor__SWIG_1 (btRotationalLimitMotor *larg1) {
  btRotationalLimitMotor * lresult = (btRotationalLimitMotor *)0 ;
  btRotationalLimitMotor *arg1 = 0 ;
  btRotationalLimitMotor *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRotationalLimitMotor *)new btRotationalLimitMotor((btRotationalLimitMotor const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRotationalLimitMotor *)0;
  }
}


EXPORT int _wrap_btRotationalLimitMotor_isLimited (btRotationalLimitMotor *larg1) {
  int lresult = (int)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->isLimited();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btRotationalLimitMotor_needApplyTorques (btRotationalLimitMotor *larg1) {
  int lresult = (int)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->needApplyTorques();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btRotationalLimitMotor_testLimitValue (btRotationalLimitMotor *larg1, btScalar larg2) {
  int lresult = (int)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (int)(arg1)->testLimitValue(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btScalar _wrap_btRotationalLimitMotor_solveAngularLimits (btRotationalLimitMotor *larg1, btScalar larg2, btVector3 *larg3, btScalar larg4, btRigidBody *larg5, btRigidBody *larg6) {
  btScalar lresult = (btScalar)0 ;
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  btScalar arg2 ;
  btVector3 *arg3 = 0 ;
  btScalar arg4 ;
  btRigidBody *arg5 = (btRigidBody *) 0 ;
  btRigidBody *arg6 = (btRigidBody *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    result = (btScalar)(arg1)->solveAngularLimits(arg2,*arg3,arg4,arg5,arg6);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_delete_btRotationalLimitMotor (btRotationalLimitMotor *larg1) {
  btRotationalLimitMotor *arg1 = (btRotationalLimitMotor *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_lowerLimit_set (btTranslationalLimitMotor *larg1, btVector3 *larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_lowerLimit = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btTranslationalLimitMotor_m_lowerLimit_get (btTranslationalLimitMotor *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_lowerLimit);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_upperLimit_set (btTranslationalLimitMotor *larg1, btVector3 *larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_upperLimit = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btTranslationalLimitMotor_m_upperLimit_get (btTranslationalLimitMotor *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_upperLimit);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_accumulatedImpulse_set (btTranslationalLimitMotor *larg1, btVector3 *larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_accumulatedImpulse = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btTranslationalLimitMotor_m_accumulatedImpulse_get (btTranslationalLimitMotor *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_accumulatedImpulse);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_limitSoftness_set (btTranslationalLimitMotor *larg1, btScalar larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_limitSoftness = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btTranslationalLimitMotor_m_limitSoftness_get (btTranslationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_limitSoftness);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_damping_set (btTranslationalLimitMotor *larg1, btScalar larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_damping = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btTranslationalLimitMotor_m_damping_get (btTranslationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_damping);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_restitution_set (btTranslationalLimitMotor *larg1, btScalar larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_restitution = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btTranslationalLimitMotor_m_restitution_get (btTranslationalLimitMotor *larg1) {
  btScalar lresult = (btScalar)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_restitution);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_normalCFM_set (btTranslationalLimitMotor *larg1, btVector3 *larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_normalCFM = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btTranslationalLimitMotor_m_normalCFM_get (btTranslationalLimitMotor *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_normalCFM);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_stopERP_set (btTranslationalLimitMotor *larg1, btVector3 *larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_stopERP = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btTranslationalLimitMotor_m_stopERP_get (btTranslationalLimitMotor *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_stopERP);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_stopCFM_set (btTranslationalLimitMotor *larg1, btVector3 *larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_stopCFM = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btTranslationalLimitMotor_m_stopCFM_get (btTranslationalLimitMotor *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_stopCFM);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_enableMotor_set (btTranslationalLimitMotor *larg1, bool *larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  bool *arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      size_t ii;
      bool *b = (bool *) arg1->m_enableMotor;
      for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((bool *) arg2 + ii);
    }
    
  } catch (...) {
    
  }
}


EXPORT bool *_wrap_btTranslationalLimitMotor_m_enableMotor_get (btTranslationalLimitMotor *larg1) {
  bool * lresult = (bool *)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  bool *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (bool *)(bool *) ((arg1)->m_enableMotor);
    lresult = result;
    return lresult;
  } catch (...) {
    return (bool *)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_targetVelocity_set (btTranslationalLimitMotor *larg1, btVector3 *larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_targetVelocity = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btTranslationalLimitMotor_m_targetVelocity_get (btTranslationalLimitMotor *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_targetVelocity);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_maxMotorForce_set (btTranslationalLimitMotor *larg1, btVector3 *larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_maxMotorForce = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btTranslationalLimitMotor_m_maxMotorForce_get (btTranslationalLimitMotor *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_maxMotorForce);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_currentLimitError_set (btTranslationalLimitMotor *larg1, btVector3 *larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_currentLimitError = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btTranslationalLimitMotor_m_currentLimitError_get (btTranslationalLimitMotor *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_currentLimitError);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_currentLinearDiff_set (btTranslationalLimitMotor *larg1, btVector3 *larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_currentLinearDiff = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btTranslationalLimitMotor_m_currentLinearDiff_get (btTranslationalLimitMotor *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_currentLinearDiff);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btTranslationalLimitMotor_m_currentLimit_set (btTranslationalLimitMotor *larg1, int *larg2) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  int *arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      size_t ii;
      int *b = (int *) arg1->m_currentLimit;
      for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((int *) arg2 + ii);
    }
    
  } catch (...) {
    
  }
}


EXPORT int *_wrap_btTranslationalLimitMotor_m_currentLimit_get (btTranslationalLimitMotor *larg1) {
  int * lresult = (int *)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  int *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (int *)(int *) ((arg1)->m_currentLimit);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int *)0;
  }
}


EXPORT btTranslationalLimitMotor *_wrap_new_btTranslationalLimitMotor__SWIG_0 () {
  btTranslationalLimitMotor * lresult = (btTranslationalLimitMotor *)0 ;
  btTranslationalLimitMotor *result = 0 ;
  
  try {
    result = (btTranslationalLimitMotor *)new btTranslationalLimitMotor();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTranslationalLimitMotor *)0;
  }
}


EXPORT btTranslationalLimitMotor *_wrap_new_btTranslationalLimitMotor__SWIG_1 (btTranslationalLimitMotor *larg1) {
  btTranslationalLimitMotor * lresult = (btTranslationalLimitMotor *)0 ;
  btTranslationalLimitMotor *arg1 = 0 ;
  btTranslationalLimitMotor *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTranslationalLimitMotor *)new btTranslationalLimitMotor((btTranslationalLimitMotor const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTranslationalLimitMotor *)0;
  }
}


EXPORT int _wrap_btTranslationalLimitMotor_isLimited (btTranslationalLimitMotor *larg1, int larg2) {
  int lresult = (int)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  int arg2 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)(arg1)->isLimited(arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btTranslationalLimitMotor_needApplyForce (btTranslationalLimitMotor *larg1, int larg2) {
  int lresult = (int)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  int arg2 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)(arg1)->needApplyForce(arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btTranslationalLimitMotor_testLimitValue (btTranslationalLimitMotor *larg1, int larg2, btScalar larg3) {
  int lresult = (int)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (int)(arg1)->testLimitValue(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btScalar _wrap_btTranslationalLimitMotor_solveLinearAxis (btTranslationalLimitMotor *larg1, btScalar larg2, btScalar larg3, btRigidBody *larg4, btVector3 *larg5, btRigidBody *larg6, btVector3 *larg7, int larg8, btVector3 *larg9, btVector3 *larg10) {
  btScalar lresult = (btScalar)0 ;
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  btRigidBody *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btRigidBody *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  int arg8 ;
  btVector3 *arg9 = 0 ;
  btVector3 *arg10 = 0 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  arg10 = larg10;
  try {
    result = (btScalar)(arg1)->solveLinearAxis(arg2,arg3,*arg4,(btVector3 const &)*arg5,*arg6,(btVector3 const &)*arg7,arg8,(btVector3 const &)*arg9,(btVector3 const &)*arg10);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_delete_btTranslationalLimitMotor (btTranslationalLimitMotor *larg1) {
  btTranslationalLimitMotor *arg1 = (btTranslationalLimitMotor *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_m_useSolveConstraintObsolete_set (btGeneric6DofConstraint *larg1, int larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    if (arg1) (arg1)->m_useSolveConstraintObsolete = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btGeneric6DofConstraint_m_useSolveConstraintObsolete_get (btGeneric6DofConstraint *larg1) {
  int lresult = (int)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool) ((arg1)->m_useSolveConstraintObsolete);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btGeneric6DofConstraint *_wrap_new_btGeneric6DofConstraint__SWIG_0 (btRigidBody *larg1, btRigidBody *larg2, btTransform *larg3, btTransform *larg4, int larg5) {
  btGeneric6DofConstraint * lresult = (btGeneric6DofConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  bool arg5 ;
  btGeneric6DofConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = (bool)larg5;
  try {
    result = (btGeneric6DofConstraint *)new btGeneric6DofConstraint(*arg1,*arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,arg5);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btGeneric6DofConstraint *)0;
  }
}


EXPORT btGeneric6DofConstraint *_wrap_new_btGeneric6DofConstraint__SWIG_1 (btRigidBody *larg1, btTransform *larg2, int larg3) {
  btGeneric6DofConstraint * lresult = (btGeneric6DofConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  bool arg3 ;
  btGeneric6DofConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    result = (btGeneric6DofConstraint *)new btGeneric6DofConstraint(*arg1,(btTransform const &)*arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btGeneric6DofConstraint *)0;
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_calculateTransforms__SWIG_0 (btGeneric6DofConstraint *larg1, btTransform *larg2, btTransform *larg3) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->calculateTransforms((btTransform const &)*arg2,(btTransform const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_calculateTransforms__SWIG_1 (btGeneric6DofConstraint *larg1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->calculateTransforms();
    
  } catch (...) {
    
  }
}


EXPORT btTransform *_wrap_btGeneric6DofConstraint_getCalculatedTransformA (btGeneric6DofConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btGeneric6DofConstraint const *)arg1)->getCalculatedTransformA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btGeneric6DofConstraint_getCalculatedTransformB (btGeneric6DofConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btGeneric6DofConstraint const *)arg1)->getCalculatedTransformB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btGeneric6DofConstraint_getFrameOffsetA__SWIG_0 (btGeneric6DofConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btGeneric6DofConstraint const *)arg1)->getFrameOffsetA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btGeneric6DofConstraint_getFrameOffsetB__SWIG_0 (btGeneric6DofConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btGeneric6DofConstraint const *)arg1)->getFrameOffsetB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btGeneric6DofConstraint_getFrameOffsetA__SWIG_1 (btGeneric6DofConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &(arg1)->getFrameOffsetA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btGeneric6DofConstraint_getFrameOffsetB__SWIG_1 (btGeneric6DofConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &(arg1)->getFrameOffsetB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_buildJacobian (btGeneric6DofConstraint *larg1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->buildJacobian();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_getInfo1 (btGeneric6DofConstraint *larg1, btTypedConstraint::btConstraintInfo1 *larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo1(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_getInfo1NonVirtual (btGeneric6DofConstraint *larg1, btTypedConstraint::btConstraintInfo1 *larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo1NonVirtual(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_getInfo2 (btGeneric6DofConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo2(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_getInfo2NonVirtual (btGeneric6DofConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2, btTransform *larg3, btTransform *larg4, btVector3 *larg5, btVector3 *larg6, btVector3 *larg7, btVector3 *larg8) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  btVector3 *arg8 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  try {
    (arg1)->getInfo2NonVirtual(arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6,(btVector3 const &)*arg7,(btVector3 const &)*arg8);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_updateRHS (btGeneric6DofConstraint *larg1, btScalar larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->updateRHS(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btGeneric6DofConstraint_getAxis (btGeneric6DofConstraint *larg1, int larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btGeneric6DofConstraint const *)arg1)->getAxis(arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btScalar _wrap_btGeneric6DofConstraint_getAngle (btGeneric6DofConstraint *larg1, int larg2) {
  btScalar lresult = (btScalar)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btGeneric6DofConstraint const *)arg1)->getAngle(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btGeneric6DofConstraint_getRelativePivotPosition (btGeneric6DofConstraint *larg1, int larg2) {
  btScalar lresult = (btScalar)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btGeneric6DofConstraint const *)arg1)->getRelativePivotPosition(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_setFrames (btGeneric6DofConstraint *larg1, btTransform *larg2, btTransform *larg3) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setFrames((btTransform const &)*arg2,(btTransform const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btGeneric6DofConstraint_testAngularLimitMotor (btGeneric6DofConstraint *larg1, int larg2) {
  int lresult = (int)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)(arg1)->testAngularLimitMotor(arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_setLinearLowerLimit (btGeneric6DofConstraint *larg1, btVector3 *larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLinearLowerLimit((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_getLinearLowerLimit (btGeneric6DofConstraint *larg1, btVector3 *larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getLinearLowerLimit(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_setLinearUpperLimit (btGeneric6DofConstraint *larg1, btVector3 *larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLinearUpperLimit((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_getLinearUpperLimit (btGeneric6DofConstraint *larg1, btVector3 *larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getLinearUpperLimit(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_setAngularLowerLimit (btGeneric6DofConstraint *larg1, btVector3 *larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setAngularLowerLimit((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_getAngularLowerLimit (btGeneric6DofConstraint *larg1, btVector3 *larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getAngularLowerLimit(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_setAngularUpperLimit (btGeneric6DofConstraint *larg1, btVector3 *larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setAngularUpperLimit((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_getAngularUpperLimit (btGeneric6DofConstraint *larg1, btVector3 *larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getAngularUpperLimit(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btRotationalLimitMotor *_wrap_btGeneric6DofConstraint_getRotationalLimitMotor (btGeneric6DofConstraint *larg1, int larg2) {
  btRotationalLimitMotor * lresult = (btRotationalLimitMotor *)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  btRotationalLimitMotor *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btRotationalLimitMotor *)(arg1)->getRotationalLimitMotor(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRotationalLimitMotor *)0;
  }
}


EXPORT btTranslationalLimitMotor *_wrap_btGeneric6DofConstraint_getTranslationalLimitMotor (btGeneric6DofConstraint *larg1) {
  btTranslationalLimitMotor * lresult = (btTranslationalLimitMotor *)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btTranslationalLimitMotor *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTranslationalLimitMotor *)(arg1)->getTranslationalLimitMotor();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTranslationalLimitMotor *)0;
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_setLimit (btGeneric6DofConstraint *larg1, int larg2, btScalar larg3, btScalar larg4) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  btScalar arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setLimit(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btGeneric6DofConstraint_isLimited (btGeneric6DofConstraint *larg1, int larg2) {
  int lresult = (int)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (bool)(arg1)->isLimited(arg2);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_calcAnchorPos (btGeneric6DofConstraint *larg1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->calcAnchorPos();
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btGeneric6DofConstraint_get_limit_motor_info2__SWIG_0 (btGeneric6DofConstraint *larg1, btRotationalLimitMotor *larg2, btTransform *larg3, btTransform *larg4, btVector3 *larg5, btVector3 *larg6, btVector3 *larg7, btVector3 *larg8, btTypedConstraint::btConstraintInfo2 *larg9, int larg10, btVector3 *larg11, int larg12, int larg13) {
  int lresult = (int)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btRotationalLimitMotor *arg2 = (btRotationalLimitMotor *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  btVector3 *arg8 = 0 ;
  btTypedConstraint::btConstraintInfo2 *arg9 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  int arg10 ;
  btVector3 *arg11 = 0 ;
  int arg12 ;
  int arg13 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  arg10 = larg10;
  arg11 = larg11;
  arg12 = larg12;
  arg13 = larg13;
  try {
    result = (int)(arg1)->get_limit_motor_info2(arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6,(btVector3 const &)*arg7,(btVector3 const &)*arg8,arg9,arg10,*arg11,arg12,arg13);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btGeneric6DofConstraint_get_limit_motor_info2__SWIG_1 (btGeneric6DofConstraint *larg1, btRotationalLimitMotor *larg2, btTransform *larg3, btTransform *larg4, btVector3 *larg5, btVector3 *larg6, btVector3 *larg7, btVector3 *larg8, btTypedConstraint::btConstraintInfo2 *larg9, int larg10, btVector3 *larg11, int larg12) {
  int lresult = (int)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btRotationalLimitMotor *arg2 = (btRotationalLimitMotor *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btVector3 *arg7 = 0 ;
  btVector3 *arg8 = 0 ;
  btTypedConstraint::btConstraintInfo2 *arg9 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  int arg10 ;
  btVector3 *arg11 = 0 ;
  int arg12 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  arg9 = larg9;
  arg10 = larg10;
  arg11 = larg11;
  arg12 = larg12;
  try {
    result = (int)(arg1)->get_limit_motor_info2(arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6,(btVector3 const &)*arg7,(btVector3 const &)*arg8,arg9,arg10,*arg11,arg12);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btGeneric6DofConstraint_getUseFrameOffset (btGeneric6DofConstraint *larg1) {
  int lresult = (int)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->getUseFrameOffset();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_setUseFrameOffset (btGeneric6DofConstraint *larg1, int larg2) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->setUseFrameOffset(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_setParam__SWIG_0 (btGeneric6DofConstraint *larg1, int larg2, btScalar larg3, int larg4) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setParam(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_setParam__SWIG_1 (btGeneric6DofConstraint *larg1, int larg2, btScalar larg3) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setParam(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btGeneric6DofConstraint_getParam__SWIG_0 (btGeneric6DofConstraint *larg1, int larg2, int larg3) {
  btScalar lresult = (btScalar)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  int arg3 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)((btGeneric6DofConstraint const *)arg1)->getParam(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btGeneric6DofConstraint_getParam__SWIG_1 (btGeneric6DofConstraint *larg1, int larg2) {
  btScalar lresult = (btScalar)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btGeneric6DofConstraint const *)arg1)->getParam(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btGeneric6DofConstraint_setAxis (btGeneric6DofConstraint *larg1, btVector3 *larg2, btVector3 *larg3) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setAxis((btVector3 const &)*arg2,(btVector3 const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btGeneric6DofConstraint_calculateSerializeBufferSize (btGeneric6DofConstraint *larg1) {
  int lresult = (int)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btGeneric6DofConstraint const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btGeneric6DofConstraint_serialize (btGeneric6DofConstraint *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btGeneric6DofConstraint const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_delete_btGeneric6DofConstraint (btGeneric6DofConstraint *larg1) {
  btGeneric6DofConstraint *arg1 = (btGeneric6DofConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btSliderConstraint *_wrap_new_btSliderConstraint__SWIG_0 (btRigidBody *larg1, btRigidBody *larg2, btTransform *larg3, btTransform *larg4, int larg5) {
  btSliderConstraint * lresult = (btSliderConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  bool arg5 ;
  btSliderConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = (bool)larg5;
  try {
    result = (btSliderConstraint *)new btSliderConstraint(*arg1,*arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,arg5);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSliderConstraint *)0;
  }
}


EXPORT btSliderConstraint *_wrap_new_btSliderConstraint__SWIG_1 (btRigidBody *larg1, btTransform *larg2, int larg3) {
  btSliderConstraint * lresult = (btSliderConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  bool arg3 ;
  btSliderConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    result = (btSliderConstraint *)new btSliderConstraint(*arg1,(btTransform const &)*arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSliderConstraint *)0;
  }
}


EXPORT void _wrap_btSliderConstraint_getInfo1 (btSliderConstraint *larg1, btTypedConstraint::btConstraintInfo1 *larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo1(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_getInfo1NonVirtual (btSliderConstraint *larg1, btTypedConstraint::btConstraintInfo1 *larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo1 *arg2 = (btTypedConstraint::btConstraintInfo1 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo1NonVirtual(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_getInfo2 (btSliderConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo2(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_getInfo2NonVirtual (btSliderConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2, btTransform *larg3, btTransform *larg4, btVector3 *larg5, btVector3 *larg6, btScalar larg7, btScalar larg8) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btVector3 *arg6 = 0 ;
  btScalar arg7 ;
  btScalar arg8 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  try {
    (arg1)->getInfo2NonVirtual(arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,(btVector3 const &)*arg5,(btVector3 const &)*arg6,arg7,arg8);
    
  } catch (...) {
    
  }
}


EXPORT btRigidBody *_wrap_btSliderConstraint_getRigidBodyA (btSliderConstraint *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *) &((btSliderConstraint const *)arg1)->getRigidBodyA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT btRigidBody *_wrap_btSliderConstraint_getRigidBodyB (btSliderConstraint *larg1) {
  btRigidBody * lresult = (btRigidBody *)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btRigidBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btRigidBody *) &((btSliderConstraint const *)arg1)->getRigidBodyB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btRigidBody *)0;
  }
}


EXPORT btTransform *_wrap_btSliderConstraint_getCalculatedTransformA (btSliderConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btSliderConstraint const *)arg1)->getCalculatedTransformA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btSliderConstraint_getCalculatedTransformB (btSliderConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btSliderConstraint const *)arg1)->getCalculatedTransformB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btSliderConstraint_getFrameOffsetA__SWIG_0 (btSliderConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btSliderConstraint const *)arg1)->getFrameOffsetA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btSliderConstraint_getFrameOffsetB__SWIG_0 (btSliderConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &((btSliderConstraint const *)arg1)->getFrameOffsetB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btSliderConstraint_getFrameOffsetA__SWIG_1 (btSliderConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &(arg1)->getFrameOffsetA();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btTransform *_wrap_btSliderConstraint_getFrameOffsetB__SWIG_1 (btSliderConstraint *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *) &(arg1)->getFrameOffsetB();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getLowerLinLimit (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getLowerLinLimit();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btSliderConstraint_setLowerLinLimit (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLowerLinLimit(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getUpperLinLimit (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getUpperLinLimit();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btSliderConstraint_setUpperLinLimit (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setUpperLinLimit(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getLowerAngLimit (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getLowerAngLimit();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btSliderConstraint_setLowerAngLimit (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLowerAngLimit(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getUpperAngLimit (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getUpperAngLimit();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btSliderConstraint_setUpperAngLimit (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setUpperAngLimit(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btSliderConstraint_getUseLinearReferenceFrameA (btSliderConstraint *larg1) {
  int lresult = (int)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->getUseLinearReferenceFrameA();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getSoftnessDirLin (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getSoftnessDirLin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getRestitutionDirLin (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getRestitutionDirLin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getDampingDirLin (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getDampingDirLin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getSoftnessDirAng (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getSoftnessDirAng();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getRestitutionDirAng (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getRestitutionDirAng();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getDampingDirAng (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getDampingDirAng();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getSoftnessLimLin (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getSoftnessLimLin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getRestitutionLimLin (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getRestitutionLimLin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getDampingLimLin (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getDampingLimLin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getSoftnessLimAng (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getSoftnessLimAng();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getRestitutionLimAng (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getRestitutionLimAng();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getDampingLimAng (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getDampingLimAng();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getSoftnessOrthoLin (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getSoftnessOrthoLin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getRestitutionOrthoLin (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getRestitutionOrthoLin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getDampingOrthoLin (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getDampingOrthoLin();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getSoftnessOrthoAng (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getSoftnessOrthoAng();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getRestitutionOrthoAng (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getRestitutionOrthoAng();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getDampingOrthoAng (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getDampingOrthoAng();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btSliderConstraint_setSoftnessDirLin (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setSoftnessDirLin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setRestitutionDirLin (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setRestitutionDirLin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setDampingDirLin (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setDampingDirLin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setSoftnessDirAng (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setSoftnessDirAng(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setRestitutionDirAng (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setRestitutionDirAng(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setDampingDirAng (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setDampingDirAng(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setSoftnessLimLin (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setSoftnessLimLin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setRestitutionLimLin (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setRestitutionLimLin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setDampingLimLin (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setDampingLimLin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setSoftnessLimAng (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setSoftnessLimAng(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setRestitutionLimAng (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setRestitutionLimAng(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setDampingLimAng (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setDampingLimAng(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setSoftnessOrthoLin (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setSoftnessOrthoLin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setRestitutionOrthoLin (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setRestitutionOrthoLin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setDampingOrthoLin (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setDampingOrthoLin(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setSoftnessOrthoAng (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setSoftnessOrthoAng(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setRestitutionOrthoAng (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setRestitutionOrthoAng(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setDampingOrthoAng (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setDampingOrthoAng(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setPoweredLinMotor (btSliderConstraint *larg1, int larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->setPoweredLinMotor(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btSliderConstraint_getPoweredLinMotor (btSliderConstraint *larg1) {
  int lresult = (int)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->getPoweredLinMotor();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btSliderConstraint_setTargetLinMotorVelocity (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setTargetLinMotorVelocity(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getTargetLinMotorVelocity (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getTargetLinMotorVelocity();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btSliderConstraint_setMaxLinMotorForce (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMaxLinMotorForce(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getMaxLinMotorForce (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getMaxLinMotorForce();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btSliderConstraint_setPoweredAngMotor (btSliderConstraint *larg1, int larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->setPoweredAngMotor(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btSliderConstraint_getPoweredAngMotor (btSliderConstraint *larg1) {
  int lresult = (int)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->getPoweredAngMotor();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btSliderConstraint_setTargetAngMotorVelocity (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setTargetAngMotorVelocity(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getTargetAngMotorVelocity (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getTargetAngMotorVelocity();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btSliderConstraint_setMaxAngMotorForce (btSliderConstraint *larg1, btScalar larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setMaxAngMotorForce(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getMaxAngMotorForce (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getMaxAngMotorForce();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getLinearPos (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btSliderConstraint const *)arg1)->getLinearPos();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getAngularPos (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btSliderConstraint const *)arg1)->getAngularPos();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btSliderConstraint_getSolveLinLimit (btSliderConstraint *larg1) {
  int lresult = (int)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->getSolveLinLimit();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getLinDepth (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getLinDepth();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btSliderConstraint_getSolveAngLimit (btSliderConstraint *larg1) {
  int lresult = (int)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->getSolveAngLimit();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getAngDepth (btSliderConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getAngDepth();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btSliderConstraint_calculateTransforms (btSliderConstraint *larg1, btTransform *larg2, btTransform *larg3) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->calculateTransforms((btTransform const &)*arg2,(btTransform const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_testLinLimits (btSliderConstraint *larg1) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->testLinLimits();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_testAngLimits (btSliderConstraint *larg1) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->testAngLimits();
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btSliderConstraint_getAncorInA (btSliderConstraint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  try {
    result = (arg1)->getAncorInA();
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btSliderConstraint_getAncorInB (btSliderConstraint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  try {
    result = (arg1)->getAncorInB();
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT int _wrap_btSliderConstraint_getUseFrameOffset (btSliderConstraint *larg1) {
  int lresult = (int)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->getUseFrameOffset();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btSliderConstraint_setUseFrameOffset (btSliderConstraint *larg1, int larg2) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->setUseFrameOffset(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setFrames (btSliderConstraint *larg1, btTransform *larg2, btTransform *larg3) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  btTransform *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setFrames((btTransform const &)*arg2,(btTransform const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setParam__SWIG_0 (btSliderConstraint *larg1, int larg2, btScalar larg3, int larg4) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->setParam(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSliderConstraint_setParam__SWIG_1 (btSliderConstraint *larg1, int larg2, btScalar larg3) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setParam(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getParam__SWIG_0 (btSliderConstraint *larg1, int larg2, int larg3) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  int arg2 ;
  int arg3 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btScalar)((btSliderConstraint const *)arg1)->getParam(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSliderConstraint_getParam__SWIG_1 (btSliderConstraint *larg1, int larg2) {
  btScalar lresult = (btScalar)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  int arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btSliderConstraint const *)arg1)->getParam(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btSliderConstraint_calculateSerializeBufferSize (btSliderConstraint *larg1) {
  int lresult = (int)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btSliderConstraint const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btSliderConstraint_serialize (btSliderConstraint *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btSliderConstraint const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_delete_btSliderConstraint (btSliderConstraint *larg1) {
  btSliderConstraint *arg1 = (btSliderConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btGeneric6DofSpringConstraint *_wrap_new_btGeneric6DofSpringConstraint__SWIG_0 (btRigidBody *larg1, btRigidBody *larg2, btTransform *larg3, btTransform *larg4, int larg5) {
  btGeneric6DofSpringConstraint * lresult = (btGeneric6DofSpringConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btTransform *arg3 = 0 ;
  btTransform *arg4 = 0 ;
  bool arg5 ;
  btGeneric6DofSpringConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = (bool)larg5;
  try {
    result = (btGeneric6DofSpringConstraint *)new btGeneric6DofSpringConstraint(*arg1,*arg2,(btTransform const &)*arg3,(btTransform const &)*arg4,arg5);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btGeneric6DofSpringConstraint *)0;
  }
}


EXPORT btGeneric6DofSpringConstraint *_wrap_new_btGeneric6DofSpringConstraint__SWIG_1 (btRigidBody *larg1, btTransform *larg2, int larg3) {
  btGeneric6DofSpringConstraint * lresult = (btGeneric6DofSpringConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  bool arg3 ;
  btGeneric6DofSpringConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    result = (btGeneric6DofSpringConstraint *)new btGeneric6DofSpringConstraint(*arg1,(btTransform const &)*arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btGeneric6DofSpringConstraint *)0;
  }
}


EXPORT void _wrap_btGeneric6DofSpringConstraint_enableSpring (btGeneric6DofSpringConstraint *larg1, int larg2, int larg3) {
  btGeneric6DofSpringConstraint *arg1 = (btGeneric6DofSpringConstraint *) 0 ;
  int arg2 ;
  bool arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    (arg1)->enableSpring(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofSpringConstraint_setStiffness (btGeneric6DofSpringConstraint *larg1, int larg2, btScalar larg3) {
  btGeneric6DofSpringConstraint *arg1 = (btGeneric6DofSpringConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setStiffness(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofSpringConstraint_setDamping (btGeneric6DofSpringConstraint *larg1, int larg2, btScalar larg3) {
  btGeneric6DofSpringConstraint *arg1 = (btGeneric6DofSpringConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setDamping(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofSpringConstraint_setEquilibriumPoint__SWIG_0 (btGeneric6DofSpringConstraint *larg1) {
  btGeneric6DofSpringConstraint *arg1 = (btGeneric6DofSpringConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->setEquilibriumPoint();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofSpringConstraint_setEquilibriumPoint__SWIG_1 (btGeneric6DofSpringConstraint *larg1, int larg2) {
  btGeneric6DofSpringConstraint *arg1 = (btGeneric6DofSpringConstraint *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setEquilibriumPoint(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofSpringConstraint_setEquilibriumPoint__SWIG_2 (btGeneric6DofSpringConstraint *larg1, int larg2, btScalar larg3) {
  btGeneric6DofSpringConstraint *arg1 = (btGeneric6DofSpringConstraint *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setEquilibriumPoint(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofSpringConstraint_setAxis (btGeneric6DofSpringConstraint *larg1, btVector3 *larg2, btVector3 *larg3) {
  btGeneric6DofSpringConstraint *arg1 = (btGeneric6DofSpringConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setAxis((btVector3 const &)*arg2,(btVector3 const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btGeneric6DofSpringConstraint_getInfo2 (btGeneric6DofSpringConstraint *larg1, btTypedConstraint::btConstraintInfo2 *larg2) {
  btGeneric6DofSpringConstraint *arg1 = (btGeneric6DofSpringConstraint *) 0 ;
  btTypedConstraint::btConstraintInfo2 *arg2 = (btTypedConstraint::btConstraintInfo2 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->getInfo2(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btGeneric6DofSpringConstraint_calculateSerializeBufferSize (btGeneric6DofSpringConstraint *larg1) {
  int lresult = (int)0 ;
  btGeneric6DofSpringConstraint *arg1 = (btGeneric6DofSpringConstraint *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btGeneric6DofSpringConstraint const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btGeneric6DofSpringConstraint_serialize (btGeneric6DofSpringConstraint *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btGeneric6DofSpringConstraint *arg1 = (btGeneric6DofSpringConstraint *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btGeneric6DofSpringConstraint const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT void _wrap_delete_btGeneric6DofSpringConstraint (btGeneric6DofSpringConstraint *larg1) {
  btGeneric6DofSpringConstraint *arg1 = (btGeneric6DofSpringConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btUniversalConstraint *_wrap_new_btUniversalConstraint (btRigidBody *larg1, btRigidBody *larg2, btVector3 *larg3, btVector3 *larg4, btVector3 *larg5) {
  btUniversalConstraint * lresult = (btUniversalConstraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btUniversalConstraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    result = (btUniversalConstraint *)new btUniversalConstraint(*arg1,*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btUniversalConstraint *)0;
  }
}


EXPORT btVector3 *_wrap_btUniversalConstraint_getAnchor (btUniversalConstraint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btUniversalConstraint *arg1 = (btUniversalConstraint *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &(arg1)->getAnchor();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btUniversalConstraint_getAnchor2 (btUniversalConstraint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btUniversalConstraint *arg1 = (btUniversalConstraint *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &(arg1)->getAnchor2();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btUniversalConstraint_getAxis1 (btUniversalConstraint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btUniversalConstraint *arg1 = (btUniversalConstraint *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &(arg1)->getAxis1();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btUniversalConstraint_getAxis2 (btUniversalConstraint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btUniversalConstraint *arg1 = (btUniversalConstraint *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &(arg1)->getAxis2();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btScalar _wrap_btUniversalConstraint_getAngle1 (btUniversalConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btUniversalConstraint *arg1 = (btUniversalConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getAngle1();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btUniversalConstraint_getAngle2 (btUniversalConstraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btUniversalConstraint *arg1 = (btUniversalConstraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getAngle2();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btUniversalConstraint_setUpperLimit (btUniversalConstraint *larg1, btScalar larg2, btScalar larg3) {
  btUniversalConstraint *arg1 = (btUniversalConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setUpperLimit(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btUniversalConstraint_setLowerLimit (btUniversalConstraint *larg1, btScalar larg2, btScalar larg3) {
  btUniversalConstraint *arg1 = (btUniversalConstraint *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setLowerLimit(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btUniversalConstraint_setAxis (btUniversalConstraint *larg1, btVector3 *larg2, btVector3 *larg3) {
  btUniversalConstraint *arg1 = (btUniversalConstraint *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setAxis((btVector3 const &)*arg2,(btVector3 const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btUniversalConstraint (btUniversalConstraint *larg1) {
  btUniversalConstraint *arg1 = (btUniversalConstraint *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btHinge2Constraint *_wrap_new_btHinge2Constraint (btRigidBody *larg1, btRigidBody *larg2, btVector3 *larg3, btVector3 *larg4, btVector3 *larg5) {
  btHinge2Constraint * lresult = (btHinge2Constraint *)0 ;
  btRigidBody *arg1 = 0 ;
  btRigidBody *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btVector3 *arg4 = 0 ;
  btVector3 *arg5 = 0 ;
  btHinge2Constraint *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    result = (btHinge2Constraint *)new btHinge2Constraint(*arg1,*arg2,*arg3,*arg4,*arg5);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btHinge2Constraint *)0;
  }
}


EXPORT btVector3 *_wrap_btHinge2Constraint_getAnchor (btHinge2Constraint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btHinge2Constraint *arg1 = (btHinge2Constraint *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &(arg1)->getAnchor();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btHinge2Constraint_getAnchor2 (btHinge2Constraint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btHinge2Constraint *arg1 = (btHinge2Constraint *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &(arg1)->getAnchor2();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btHinge2Constraint_getAxis1 (btHinge2Constraint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btHinge2Constraint *arg1 = (btHinge2Constraint *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &(arg1)->getAxis1();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btHinge2Constraint_getAxis2 (btHinge2Constraint *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btHinge2Constraint *arg1 = (btHinge2Constraint *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &(arg1)->getAxis2();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btScalar _wrap_btHinge2Constraint_getAngle1 (btHinge2Constraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btHinge2Constraint *arg1 = (btHinge2Constraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getAngle1();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btHinge2Constraint_getAngle2 (btHinge2Constraint *larg1) {
  btScalar lresult = (btScalar)0 ;
  btHinge2Constraint *arg1 = (btHinge2Constraint *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getAngle2();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btHinge2Constraint_setUpperLimit (btHinge2Constraint *larg1, btScalar larg2) {
  btHinge2Constraint *arg1 = (btHinge2Constraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setUpperLimit(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btHinge2Constraint_setLowerLimit (btHinge2Constraint *larg1, btScalar larg2) {
  btHinge2Constraint *arg1 = (btHinge2Constraint *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setLowerLimit(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btHinge2Constraint (btHinge2Constraint *larg1) {
  btHinge2Constraint *arg1 = (btHinge2Constraint *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_m_collisionDisabledObjects_set (btSoftBody *larg1, btAlignedObjectArray< btCollisionObject const * > *larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btAlignedObjectArray< btCollisionObject const * > *arg2 = (btAlignedObjectArray< btCollisionObject const * > *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_collisionDisabledObjects = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btAlignedObjectArray< btCollisionObject const * > *_wrap_btSoftBody_m_collisionDisabledObjects_get (btSoftBody *larg1) {
  btAlignedObjectArray< btCollisionObject const * > * lresult = (btAlignedObjectArray< btCollisionObject const * > *)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btAlignedObjectArray< btCollisionObject const * > *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btAlignedObjectArray< btCollisionObject const * > *)& ((arg1)->m_collisionDisabledObjects);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btAlignedObjectArray< btCollisionObject const * > *)0;
  }
}


EXPORT void _wrap_btSoftBody_m_softBodySolver_set (btSoftBody *larg1, btSoftBodySolver *larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBodySolver *arg2 = (btSoftBodySolver *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_softBodySolver = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btSoftBodySolver *_wrap_btSoftBody_m_softBodySolver_get (btSoftBody *larg1) {
  btSoftBodySolver * lresult = (btSoftBodySolver *)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBodySolver *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSoftBodySolver *) ((arg1)->m_softBodySolver);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftBodySolver *)0;
  }
}


EXPORT void _wrap_btSoftBody_m_cfg_set (btSoftBody *larg1, Config *larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  Config *arg2 = (Config *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_cfg = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT Config *_wrap_btSoftBody_m_cfg_get (btSoftBody *larg1) {
  Config * lresult = (Config *)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  Config *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (Config *)& ((arg1)->m_cfg);
    lresult = result;
    return lresult;
  } catch (...) {
    return (Config *)0;
  }
}


EXPORT void _wrap_btSoftBody_m_sst_set (btSoftBody *larg1, btSoftBody::SolverState *larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBody::SolverState *arg2 = (btSoftBody::SolverState *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_sst = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btSoftBody::SolverState *_wrap_btSoftBody_m_sst_get (btSoftBody *larg1) {
  btSoftBody::SolverState * lresult = (btSoftBody::SolverState *)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBody::SolverState *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSoftBody::SolverState *)& ((arg1)->m_sst);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftBody::SolverState *)0;
  }
}


EXPORT void _wrap_btSoftBody_m_pose_set (btSoftBody *larg1, btSoftBody::Pose *larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBody::Pose *arg2 = (btSoftBody::Pose *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_pose = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btSoftBody::Pose *_wrap_btSoftBody_m_pose_get (btSoftBody *larg1) {
  btSoftBody::Pose * lresult = (btSoftBody::Pose *)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBody::Pose *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSoftBody::Pose *)& ((arg1)->m_pose);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftBody::Pose *)0;
  }
}


EXPORT void _wrap_btSoftBody_m_tag_set (btSoftBody *larg1, void *larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  void *arg2 = (void *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_tag = arg2;
    
  } catch (...) {
    
  }
}


EXPORT void *_wrap_btSoftBody_m_tag_get (btSoftBody *larg1) {
  void * lresult = (void *)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  void *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (void *) ((arg1)->m_tag);
    lresult = result;
    return lresult;
  } catch (...) {
    return (void *)0;
  }
}


EXPORT void _wrap_btSoftBody_m_worldInfo_set (btSoftBody *larg1, btSoftBodyWorldInfo *larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBodyWorldInfo *arg2 = (btSoftBodyWorldInfo *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_worldInfo = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btSoftBodyWorldInfo *_wrap_btSoftBody_m_worldInfo_get (btSoftBody *larg1) {
  btSoftBodyWorldInfo * lresult = (btSoftBodyWorldInfo *)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBodyWorldInfo *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSoftBodyWorldInfo *) ((arg1)->m_worldInfo);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftBodyWorldInfo *)0;
  }
}


EXPORT void _wrap_btSoftBody_m_notes_set (btSoftBody *larg1, btSoftBody::tNoteArray *larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBody::tNoteArray *arg2 = (btSoftBody::tNoteArray *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_notes = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btSoftBody::tNoteArray *_wrap_btSoftBody_m_notes_get (btSoftBody *larg1) {
  btSoftBody::tNoteArray * lresult = (btSoftBody::tNoteArray *)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBody::tNoteArray *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSoftBody::tNoteArray *)& ((arg1)->m_notes);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftBody::tNoteArray *)0;
  }
}


EXPORT void _wrap_btSoftBody_m_nodes_set (btSoftBody *larg1, btSoftBody::tNodeArray *larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBody::tNodeArray *arg2 = (btSoftBody::tNodeArray *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_nodes = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btSoftBody::tNodeArray *_wrap_btSoftBody_m_nodes_get (btSoftBody *larg1) {
  btSoftBody::tNodeArray * lresult = (btSoftBody::tNodeArray *)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBody::tNodeArray *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSoftBody::tNodeArray *)& ((arg1)->m_nodes);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftBody::tNodeArray *)0;
  }
}


EXPORT void _wrap_btSoftBody_m_links_set (btSoftBody *larg1, btSoftBody::tLinkArray *larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBody::tLinkArray *arg2 = (btSoftBody::tLinkArray *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_links = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btSoftBody::tLinkArray *_wrap_btSoftBody_m_links_get (btSoftBody *larg1) {
  btSoftBody::tLinkArray * lresult = (btSoftBody::tLinkArray *)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBody::tLinkArray *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSoftBody::tLinkArray *)& ((arg1)->m_links);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftBody::tLinkArray *)0;
  }
}


EXPORT void _wrap_btSoftBody_m_faces_set (btSoftBody *larg1, btSoftBody::tFaceArray *larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBody::tFaceArray *arg2 = (btSoftBody::tFaceArray *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_faces = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btSoftBody::tFaceArray *_wrap_btSoftBody_m_faces_get (btSoftBody *larg1) {
  btSoftBody::tFaceArray * lresult = (btSoftBody::tFaceArray *)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBody::tFaceArray *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSoftBody::tFaceArray *)& ((arg1)->m_faces);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftBody::tFaceArray *)0;
  }
}


EXPORT void _wrap_btSoftBody_m_tetras_set (btSoftBody *larg1, btSoftBody::tTetraArray *larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBody::tTetraArray *arg2 = (btSoftBody::tTetraArray *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_tetras = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btSoftBody::tTetraArray *_wrap_btSoftBody_m_tetras_get (btSoftBody *larg1) {
  btSoftBody::tTetraArray * lresult = (btSoftBody::tTetraArray *)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBody::tTetraArray *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSoftBody::tTetraArray *)& ((arg1)->m_tetras);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftBody::tTetraArray *)0;
  }
}


EXPORT void _wrap_btSoftBody_m_anchors_set (btSoftBody *larg1, btSoftBody::tAnchorArray *larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBody::tAnchorArray *arg2 = (btSoftBody::tAnchorArray *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_anchors = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btSoftBody::tAnchorArray *_wrap_btSoftBody_m_anchors_get (btSoftBody *larg1) {
  btSoftBody::tAnchorArray * lresult = (btSoftBody::tAnchorArray *)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBody::tAnchorArray *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSoftBody::tAnchorArray *)& ((arg1)->m_anchors);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftBody::tAnchorArray *)0;
  }
}


EXPORT void _wrap_btSoftBody_m_rcontacts_set (btSoftBody *larg1, btSoftBody::tRContactArray *larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBody::tRContactArray *arg2 = (btSoftBody::tRContactArray *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_rcontacts = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btSoftBody::tRContactArray *_wrap_btSoftBody_m_rcontacts_get (btSoftBody *larg1) {
  btSoftBody::tRContactArray * lresult = (btSoftBody::tRContactArray *)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBody::tRContactArray *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSoftBody::tRContactArray *)& ((arg1)->m_rcontacts);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftBody::tRContactArray *)0;
  }
}


EXPORT void _wrap_btSoftBody_m_scontacts_set (btSoftBody *larg1, btSoftBody::tSContactArray *larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBody::tSContactArray *arg2 = (btSoftBody::tSContactArray *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_scontacts = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btSoftBody::tSContactArray *_wrap_btSoftBody_m_scontacts_get (btSoftBody *larg1) {
  btSoftBody::tSContactArray * lresult = (btSoftBody::tSContactArray *)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBody::tSContactArray *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSoftBody::tSContactArray *)& ((arg1)->m_scontacts);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftBody::tSContactArray *)0;
  }
}


EXPORT void _wrap_btSoftBody_m_joints_set (btSoftBody *larg1, btSoftBody::tJointArray *larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBody::tJointArray *arg2 = (btSoftBody::tJointArray *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_joints = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btSoftBody::tJointArray *_wrap_btSoftBody_m_joints_get (btSoftBody *larg1) {
  btSoftBody::tJointArray * lresult = (btSoftBody::tJointArray *)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBody::tJointArray *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSoftBody::tJointArray *)& ((arg1)->m_joints);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftBody::tJointArray *)0;
  }
}


EXPORT void _wrap_btSoftBody_m_materials_set (btSoftBody *larg1, btSoftBody::tMaterialArray *larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBody::tMaterialArray *arg2 = (btSoftBody::tMaterialArray *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_materials = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btSoftBody::tMaterialArray *_wrap_btSoftBody_m_materials_get (btSoftBody *larg1) {
  btSoftBody::tMaterialArray * lresult = (btSoftBody::tMaterialArray *)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBody::tMaterialArray *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSoftBody::tMaterialArray *)& ((arg1)->m_materials);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftBody::tMaterialArray *)0;
  }
}


EXPORT void _wrap_btSoftBody_m_timeacc_set (btSoftBody *larg1, btScalar larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_timeacc = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btSoftBody_m_timeacc_get (btSoftBody *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_timeacc);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btSoftBody_m_bounds_set (btSoftBody *larg1, btVector3 *larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btVector3 *arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    {
      size_t ii;
      btVector3 *b = (btVector3 *) arg1->m_bounds;
      for (ii = 0; ii < (size_t)2; ii++) b[ii] = *((btVector3 *) arg2 + ii);
    }
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btSoftBody_m_bounds_get (btSoftBody *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)(btVector3 *) ((arg1)->m_bounds);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btSoftBody_m_bUpdateRtCst_set (btSoftBody *larg1, int larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    if (arg1) (arg1)->m_bUpdateRtCst = arg2;
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btSoftBody_m_bUpdateRtCst_get (btSoftBody *larg1) {
  int lresult = (int)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool) ((arg1)->m_bUpdateRtCst);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btSoftBody_m_clusters_set (btSoftBody *larg1, btSoftBody::tClusterArray *larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBody::tClusterArray *arg2 = (btSoftBody::tClusterArray *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_clusters = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btSoftBody::tClusterArray *_wrap_btSoftBody_m_clusters_get (btSoftBody *larg1) {
  btSoftBody::tClusterArray * lresult = (btSoftBody::tClusterArray *)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBody::tClusterArray *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSoftBody::tClusterArray *)& ((arg1)->m_clusters);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftBody::tClusterArray *)0;
  }
}


EXPORT void _wrap_btSoftBody_m_clusterConnectivity_set (btSoftBody *larg1, btAlignedObjectArray< bool > *larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btAlignedObjectArray< bool > *arg2 = (btAlignedObjectArray< bool > *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_clusterConnectivity = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btAlignedObjectArray< bool > *_wrap_btSoftBody_m_clusterConnectivity_get (btSoftBody *larg1) {
  btAlignedObjectArray< bool > * lresult = (btAlignedObjectArray< bool > *)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btAlignedObjectArray< bool > *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btAlignedObjectArray< bool > *)& ((arg1)->m_clusterConnectivity);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btAlignedObjectArray< bool > *)0;
  }
}


EXPORT void _wrap_btSoftBody_m_initialWorldTransform_set (btSoftBody *larg1, btTransform *larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btTransform *arg2 = (btTransform *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_initialWorldTransform = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btTransform *_wrap_btSoftBody_m_initialWorldTransform_get (btSoftBody *larg1) {
  btTransform * lresult = (btTransform *)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btTransform *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btTransform *)& ((arg1)->m_initialWorldTransform);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btTransform *)0;
  }
}


EXPORT void _wrap_btSoftBody_m_windVelocity_set (btSoftBody *larg1, btVector3 *larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btVector3 *arg2 = (btVector3 *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_windVelocity = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btSoftBody_m_windVelocity_get (btSoftBody *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *)& ((arg1)->m_windVelocity);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btSoftBody_m_restLengthScale_set (btSoftBody *larg1, btScalar larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_restLengthScale = arg2;
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btSoftBody_m_restLengthScale_get (btSoftBody *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar) ((arg1)->m_restLengthScale);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btSoftBody *_wrap_new_btSoftBody__SWIG_0 (btSoftBodyWorldInfo *larg1, int larg2, btVector3 *larg3, btScalar *larg4) {
  btSoftBody * lresult = (btSoftBody *)0 ;
  btSoftBodyWorldInfo *arg1 = (btSoftBodyWorldInfo *) 0 ;
  int arg2 ;
  btVector3 *arg3 = (btVector3 *) 0 ;
  btScalar *arg4 = (btScalar *) 0 ;
  btSoftBody *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btSoftBody *)new btSoftBody(arg1,arg2,(btVector3 const *)arg3,(btScalar const *)arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftBody *)0;
  }
}


EXPORT btSoftBody *_wrap_new_btSoftBody__SWIG_1 (btSoftBodyWorldInfo *larg1) {
  btSoftBody * lresult = (btSoftBody *)0 ;
  btSoftBodyWorldInfo *arg1 = (btSoftBodyWorldInfo *) 0 ;
  btSoftBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSoftBody *)new btSoftBody(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftBody *)0;
  }
}


EXPORT void _wrap_btSoftBody_initDefaults (btSoftBody *larg1) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->initDefaults();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btSoftBody (btSoftBody *larg1) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_m_userIndexMapping_set (btSoftBody *larg1, btAlignedObjectArray< int > *larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btAlignedObjectArray< int > *arg2 = (btAlignedObjectArray< int > *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    if (arg1) (arg1)->m_userIndexMapping = *arg2;
    
  } catch (...) {
    
  }
}


EXPORT btAlignedObjectArray< int > *_wrap_btSoftBody_m_userIndexMapping_get (btSoftBody *larg1) {
  btAlignedObjectArray< int > * lresult = (btAlignedObjectArray< int > *)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btAlignedObjectArray< int > *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btAlignedObjectArray< int > *)& ((arg1)->m_userIndexMapping);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btAlignedObjectArray< int > *)0;
  }
}


EXPORT btSoftBodyWorldInfo *_wrap_btSoftBody_getWorldInfo (btSoftBody *larg1) {
  btSoftBodyWorldInfo * lresult = (btSoftBodyWorldInfo *)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBodyWorldInfo *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSoftBodyWorldInfo *)(arg1)->getWorldInfo();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftBodyWorldInfo *)0;
  }
}


EXPORT void _wrap_btSoftBody_setCollisionShape (btSoftBody *larg1, btCollisionShape *larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btCollisionShape *arg2 = (btCollisionShape *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setCollisionShape(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btSoftBody_checkLink__SWIG_0 (btSoftBody *larg1, int larg2, int larg3) {
  int lresult = (int)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  int arg2 ;
  int arg3 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (bool)((btSoftBody const *)arg1)->checkLink(arg2,arg3);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btSoftBody_checkLink__SWIG_1 (btSoftBody *larg1, Node *larg2, Node *larg3) {
  int lresult = (int)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  Node *arg2 = (Node *) 0 ;
  Node *arg3 = (Node *) 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (bool)((btSoftBody const *)arg1)->checkLink((Node const *)arg2,(Node const *)arg3);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btSoftBody_checkFace (btSoftBody *larg1, int larg2, int larg3, int larg4) {
  int lresult = (int)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (bool)((btSoftBody const *)arg1)->checkFace(arg2,arg3,arg4);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT Material *_wrap_btSoftBody_appendMaterial (btSoftBody *larg1) {
  Material * lresult = (Material *)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  Material *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (Material *)(arg1)->appendMaterial();
    lresult = result;
    return lresult;
  } catch (...) {
    return (Material *)0;
  }
}


EXPORT void _wrap_btSoftBody_appendNote__SWIG_0 (btSoftBody *larg1, char *larg2, btVector3 *larg3, btVector4 *larg4, Node *larg5, Node *larg6, Node *larg7, Node *larg8) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  char *arg2 = (char *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector4 *arg4 = 0 ;
  Node *arg5 = (Node *) 0 ;
  Node *arg6 = (Node *) 0 ;
  Node *arg7 = (Node *) 0 ;
  Node *arg8 = (Node *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  arg8 = larg8;
  try {
    (arg1)->appendNote((char const *)arg2,(btVector3 const &)*arg3,(btVector4 const &)*arg4,arg5,arg6,arg7,arg8);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_appendNote__SWIG_1 (btSoftBody *larg1, char *larg2, btVector3 *larg3, btVector4 *larg4, Node *larg5, Node *larg6, Node *larg7) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  char *arg2 = (char *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector4 *arg4 = 0 ;
  Node *arg5 = (Node *) 0 ;
  Node *arg6 = (Node *) 0 ;
  Node *arg7 = (Node *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = larg7;
  try {
    (arg1)->appendNote((char const *)arg2,(btVector3 const &)*arg3,(btVector4 const &)*arg4,arg5,arg6,arg7);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_appendNote__SWIG_2 (btSoftBody *larg1, char *larg2, btVector3 *larg3, btVector4 *larg4, Node *larg5, Node *larg6) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  char *arg2 = (char *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector4 *arg4 = 0 ;
  Node *arg5 = (Node *) 0 ;
  Node *arg6 = (Node *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    (arg1)->appendNote((char const *)arg2,(btVector3 const &)*arg3,(btVector4 const &)*arg4,arg5,arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_appendNote__SWIG_3 (btSoftBody *larg1, char *larg2, btVector3 *larg3, btVector4 *larg4, Node *larg5) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  char *arg2 = (char *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector4 *arg4 = 0 ;
  Node *arg5 = (Node *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->appendNote((char const *)arg2,(btVector3 const &)*arg3,(btVector4 const &)*arg4,arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_appendNote__SWIG_4 (btSoftBody *larg1, char *larg2, btVector3 *larg3, btVector4 *larg4) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  char *arg2 = (char *) 0 ;
  btVector3 *arg3 = 0 ;
  btVector4 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->appendNote((char const *)arg2,(btVector3 const &)*arg3,(btVector4 const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_appendNote__SWIG_5 (btSoftBody *larg1, char *larg2, btVector3 *larg3) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  char *arg2 = (char *) 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->appendNote((char const *)arg2,(btVector3 const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_appendNote__SWIG_6 (btSoftBody *larg1, char *larg2, btVector3 *larg3, Node *larg4) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  char *arg2 = (char *) 0 ;
  btVector3 *arg3 = 0 ;
  Node *arg4 = (Node *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->appendNote((char const *)arg2,(btVector3 const &)*arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_appendNote__SWIG_7 (btSoftBody *larg1, char *larg2, btVector3 *larg3, btSoftBody::Link *larg4) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  char *arg2 = (char *) 0 ;
  btVector3 *arg3 = 0 ;
  btSoftBody::Link *arg4 = (btSoftBody::Link *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->appendNote((char const *)arg2,(btVector3 const &)*arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_appendNote__SWIG_8 (btSoftBody *larg1, char *larg2, btVector3 *larg3, btSoftBody::Face *larg4) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  char *arg2 = (char *) 0 ;
  btVector3 *arg3 = 0 ;
  btSoftBody::Face *arg4 = (btSoftBody::Face *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->appendNote((char const *)arg2,(btVector3 const &)*arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_appendNode (btSoftBody *larg1, btVector3 *larg2, btScalar larg3) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->appendNode((btVector3 const &)*arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_appendLink__SWIG_0 (btSoftBody *larg1, int larg2, Material *larg3) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  int arg2 ;
  Material *arg3 = (Material *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->appendLink(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_appendLink__SWIG_1 (btSoftBody *larg1, int larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->appendLink(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_appendLink__SWIG_2 (btSoftBody *larg1) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->appendLink();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_appendLink__SWIG_3 (btSoftBody *larg1, int larg2, int larg3, Material *larg4, int larg5) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  int arg2 ;
  int arg3 ;
  Material *arg4 = (Material *) 0 ;
  bool arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = (bool)larg5;
  try {
    (arg1)->appendLink(arg2,arg3,arg4,arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_appendLink__SWIG_4 (btSoftBody *larg1, int larg2, int larg3, Material *larg4) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  int arg2 ;
  int arg3 ;
  Material *arg4 = (Material *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->appendLink(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_appendLink__SWIG_5 (btSoftBody *larg1, int larg2, int larg3) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->appendLink(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_appendLink__SWIG_6 (btSoftBody *larg1, Node *larg2, Node *larg3, Material *larg4, int larg5) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  Node *arg2 = (Node *) 0 ;
  Node *arg3 = (Node *) 0 ;
  Material *arg4 = (Material *) 0 ;
  bool arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = (bool)larg5;
  try {
    (arg1)->appendLink(arg2,arg3,arg4,arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_appendLink__SWIG_7 (btSoftBody *larg1, Node *larg2, Node *larg3, Material *larg4) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  Node *arg2 = (Node *) 0 ;
  Node *arg3 = (Node *) 0 ;
  Material *arg4 = (Material *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->appendLink(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_appendLink__SWIG_8 (btSoftBody *larg1, Node *larg2, Node *larg3) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  Node *arg2 = (Node *) 0 ;
  Node *arg3 = (Node *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->appendLink(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_appendFace__SWIG_0 (btSoftBody *larg1, int larg2, Material *larg3) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  int arg2 ;
  Material *arg3 = (Material *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->appendFace(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_appendFace__SWIG_1 (btSoftBody *larg1, int larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->appendFace(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_appendFace__SWIG_2 (btSoftBody *larg1) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->appendFace();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_appendFace__SWIG_3 (btSoftBody *larg1, int larg2, int larg3, int larg4, Material *larg5) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  Material *arg5 = (Material *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->appendFace(arg2,arg3,arg4,arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_appendFace__SWIG_4 (btSoftBody *larg1, int larg2, int larg3, int larg4) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->appendFace(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_appendTetra__SWIG_0 (btSoftBody *larg1, int larg2, Material *larg3) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  int arg2 ;
  Material *arg3 = (Material *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->appendTetra(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_appendTetra__SWIG_1 (btSoftBody *larg1, int larg2, int larg3, int larg4, int larg5, Material *larg6) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  Material *arg6 = (Material *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    (arg1)->appendTetra(arg2,arg3,arg4,arg5,arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_appendTetra__SWIG_2 (btSoftBody *larg1, int larg2, int larg3, int larg4, int larg5) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    (arg1)->appendTetra(arg2,arg3,arg4,arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_appendAnchor__SWIG_0 (btSoftBody *larg1, int larg2, btRigidBody *larg3, int larg4, btScalar larg5) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  int arg2 ;
  btRigidBody *arg3 = (btRigidBody *) 0 ;
  bool arg4 ;
  btScalar arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  arg5 = larg5;
  try {
    (arg1)->appendAnchor(arg2,arg3,arg4,arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_appendAnchor__SWIG_1 (btSoftBody *larg1, int larg2, btRigidBody *larg3, int larg4) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  int arg2 ;
  btRigidBody *arg3 = (btRigidBody *) 0 ;
  bool arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  try {
    (arg1)->appendAnchor(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_appendAnchor__SWIG_2 (btSoftBody *larg1, int larg2, btRigidBody *larg3) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  int arg2 ;
  btRigidBody *arg3 = (btRigidBody *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->appendAnchor(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_appendAnchor__SWIG_3 (btSoftBody *larg1, int larg2, btRigidBody *larg3, btVector3 *larg4, int larg5, btScalar larg6) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  int arg2 ;
  btRigidBody *arg3 = (btRigidBody *) 0 ;
  btVector3 *arg4 = 0 ;
  bool arg5 ;
  btScalar arg6 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = (bool)larg5;
  arg6 = larg6;
  try {
    (arg1)->appendAnchor(arg2,arg3,(btVector3 const &)*arg4,arg5,arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_appendAnchor__SWIG_4 (btSoftBody *larg1, int larg2, btRigidBody *larg3, btVector3 *larg4, int larg5) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  int arg2 ;
  btRigidBody *arg3 = (btRigidBody *) 0 ;
  btVector3 *arg4 = 0 ;
  bool arg5 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = (bool)larg5;
  try {
    (arg1)->appendAnchor(arg2,arg3,(btVector3 const &)*arg4,arg5);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_appendAnchor__SWIG_5 (btSoftBody *larg1, int larg2, btRigidBody *larg3, btVector3 *larg4) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  int arg2 ;
  btRigidBody *arg3 = (btRigidBody *) 0 ;
  btVector3 *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->appendAnchor(arg2,arg3,(btVector3 const &)*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_appendLinearJoint__SWIG_0 (btSoftBody *larg1, btSoftBody::LJoint::Specs *larg2, btSoftBody::Cluster *larg3, btSoftBody::Body *larg4) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBody::LJoint::Specs *arg2 = 0 ;
  btSoftBody::Cluster *arg3 = (btSoftBody::Cluster *) 0 ;
  btSoftBody::Body arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = *larg4;
  try {
    (arg1)->appendLinearJoint((btSoftBody::LJoint::Specs const &)*arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_appendLinearJoint__SWIG_1 (btSoftBody *larg1, btSoftBody::LJoint::Specs *larg2, btSoftBody::Body *larg3) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBody::LJoint::Specs *arg2 = 0 ;
  btSoftBody::Body arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = *larg3;
  try {
    (arg1)->appendLinearJoint((btSoftBody::LJoint::Specs const &)*arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_appendLinearJoint__SWIG_2 (btSoftBody *larg1, btSoftBody::LJoint::Specs *larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBody::LJoint::Specs *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->appendLinearJoint((btSoftBody::LJoint::Specs const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_appendLinearJoint__SWIG_3 (btSoftBody *larg1, btSoftBody::LJoint::Specs *larg2, btSoftBody *larg3) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBody::LJoint::Specs *arg2 = 0 ;
  btSoftBody *arg3 = (btSoftBody *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->appendLinearJoint((btSoftBody::LJoint::Specs const &)*arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_appendAngularJoint__SWIG_0 (btSoftBody *larg1, btSoftBody::AJoint::Specs *larg2, btSoftBody::Cluster *larg3, btSoftBody::Body *larg4) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBody::AJoint::Specs *arg2 = 0 ;
  btSoftBody::Cluster *arg3 = (btSoftBody::Cluster *) 0 ;
  btSoftBody::Body arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = *larg4;
  try {
    (arg1)->appendAngularJoint((btSoftBody::AJoint::Specs const &)*arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_appendAngularJoint__SWIG_1 (btSoftBody *larg1, btSoftBody::AJoint::Specs *larg2, btSoftBody::Body *larg3) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBody::AJoint::Specs *arg2 = 0 ;
  btSoftBody::Body arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = *larg3;
  try {
    (arg1)->appendAngularJoint((btSoftBody::AJoint::Specs const &)*arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_appendAngularJoint__SWIG_2 (btSoftBody *larg1, btSoftBody::AJoint::Specs *larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBody::AJoint::Specs *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->appendAngularJoint((btSoftBody::AJoint::Specs const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_appendAngularJoint__SWIG_3 (btSoftBody *larg1, btSoftBody::AJoint::Specs *larg2, btSoftBody *larg3) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBody::AJoint::Specs *arg2 = 0 ;
  btSoftBody *arg3 = (btSoftBody *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->appendAngularJoint((btSoftBody::AJoint::Specs const &)*arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_addForce__SWIG_0 (btSoftBody *larg1, btVector3 *larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addForce((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_addForce__SWIG_1 (btSoftBody *larg1, btVector3 *larg2, int larg3) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btVector3 *arg2 = 0 ;
  int arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->addForce((btVector3 const &)*arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_addAeroForceToNode (btSoftBody *larg1, btVector3 *larg2, int larg3) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btVector3 *arg2 = 0 ;
  int arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->addAeroForceToNode((btVector3 const &)*arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_addAeroForceToFace (btSoftBody *larg1, btVector3 *larg2, int larg3) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btVector3 *arg2 = 0 ;
  int arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->addAeroForceToFace((btVector3 const &)*arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_addVelocity__SWIG_0 (btSoftBody *larg1, btVector3 *larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addVelocity((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_setVelocity (btSoftBody *larg1, btVector3 *larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setVelocity((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_addVelocity__SWIG_1 (btSoftBody *larg1, btVector3 *larg2, int larg3) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btVector3 *arg2 = 0 ;
  int arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->addVelocity((btVector3 const &)*arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_setMass (btSoftBody *larg1, int larg2, btScalar larg3) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  int arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->setMass(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btSoftBody_getMass (btSoftBody *larg1, int larg2) {
  btScalar lresult = (btScalar)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  int arg2 ;
  btScalar result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btScalar)((btSoftBody const *)arg1)->getMass(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT btScalar _wrap_btSoftBody_getTotalMass (btSoftBody *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btSoftBody const *)arg1)->getTotalMass();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btSoftBody_setTotalMass__SWIG_0 (btSoftBody *larg1, btScalar larg2, int larg3) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btScalar arg2 ;
  bool arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    (arg1)->setTotalMass(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_setTotalMass__SWIG_1 (btSoftBody *larg1, btScalar larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setTotalMass(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_setTotalDensity (btSoftBody *larg1, btScalar larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setTotalDensity(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_setVolumeMass (btSoftBody *larg1, btScalar larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setVolumeMass(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_setVolumeDensity (btSoftBody *larg1, btScalar larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setVolumeDensity(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_transform (btSoftBody *larg1, btTransform *larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btTransform *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->transform((btTransform const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_translate (btSoftBody *larg1, btVector3 *larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->translate((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_rotate (btSoftBody *larg1, btQuaternion *larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btQuaternion *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->rotate((btQuaternion const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_scale (btSoftBody *larg1, btVector3 *larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->scale((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btSoftBody_getRestLengthScale (btSoftBody *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)(arg1)->getRestLengthScale();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT void _wrap_btSoftBody_setRestLengthScale (btSoftBody *larg1, btScalar larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setRestLengthScale(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_setPose (btSoftBody *larg1, int larg2, int larg3) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  bool arg2 ;
  bool arg3 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  arg3 = (bool)larg3;
  try {
    (arg1)->setPose(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_resetLinkRestLengths (btSoftBody *larg1) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->resetLinkRestLengths();
    
  } catch (...) {
    
  }
}


EXPORT btScalar _wrap_btSoftBody_getVolume (btSoftBody *larg1) {
  btScalar lresult = (btScalar)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btScalar result;
  
  arg1 = larg1;
  try {
    result = (btScalar)((btSoftBody const *)arg1)->getVolume();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btScalar)0;
  }
}


EXPORT int _wrap_btSoftBody_clusterCount (btSoftBody *larg1) {
  int lresult = (int)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btSoftBody const *)arg1)->clusterCount();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT btVector3 *_wrap_btSoftBody_clusterCom__SWIG_0 (btSoftBody::Cluster *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btSoftBody::Cluster *arg1 = (btSoftBody::Cluster *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  try {
    result = btSoftBody::clusterCom((btSoftBody::Cluster const *)arg1);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btSoftBody_clusterCom__SWIG_1 (btSoftBody *larg1, int larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  int arg2 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = ((btSoftBody const *)arg1)->clusterCom(arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT btVector3 *_wrap_btSoftBody_clusterVelocity (btSoftBody::Cluster *larg1, btVector3 *larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btSoftBody::Cluster *arg1 = (btSoftBody::Cluster *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = btSoftBody::clusterVelocity((btSoftBody::Cluster const *)arg1,(btVector3 const &)*arg2);
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btSoftBody_clusterVImpulse (btSoftBody::Cluster *larg1, btVector3 *larg2, btVector3 *larg3) {
  btSoftBody::Cluster *arg1 = (btSoftBody::Cluster *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    btSoftBody::clusterVImpulse(arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_clusterDImpulse (btSoftBody::Cluster *larg1, btVector3 *larg2, btVector3 *larg3) {
  btSoftBody::Cluster *arg1 = (btSoftBody::Cluster *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    btSoftBody::clusterDImpulse(arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_clusterImpulse (btSoftBody::Cluster *larg1, btVector3 *larg2, btSoftBody::Impulse *larg3) {
  btSoftBody::Cluster *arg1 = (btSoftBody::Cluster *) 0 ;
  btVector3 *arg2 = 0 ;
  btSoftBody::Impulse *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    btSoftBody::clusterImpulse(arg1,(btVector3 const &)*arg2,(btSoftBody::Impulse const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_clusterVAImpulse (btSoftBody::Cluster *larg1, btVector3 *larg2) {
  btSoftBody::Cluster *arg1 = (btSoftBody::Cluster *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    btSoftBody::clusterVAImpulse(arg1,(btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_clusterDAImpulse (btSoftBody::Cluster *larg1, btVector3 *larg2) {
  btSoftBody::Cluster *arg1 = (btSoftBody::Cluster *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    btSoftBody::clusterDAImpulse(arg1,(btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_clusterAImpulse (btSoftBody::Cluster *larg1, btSoftBody::Impulse *larg2) {
  btSoftBody::Cluster *arg1 = (btSoftBody::Cluster *) 0 ;
  btSoftBody::Impulse *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    btSoftBody::clusterAImpulse(arg1,(btSoftBody::Impulse const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_clusterDCImpulse (btSoftBody::Cluster *larg1, btVector3 *larg2) {
  btSoftBody::Cluster *arg1 = (btSoftBody::Cluster *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    btSoftBody::clusterDCImpulse(arg1,(btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btSoftBody_generateBendingConstraints__SWIG_0 (btSoftBody *larg1, int larg2, Material *larg3) {
  int lresult = (int)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  int arg2 ;
  Material *arg3 = (Material *) 0 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (int)(arg1)->generateBendingConstraints(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btSoftBody_generateBendingConstraints__SWIG_1 (btSoftBody *larg1, int larg2) {
  int lresult = (int)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  int arg2 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (int)(arg1)->generateBendingConstraints(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btSoftBody_randomizeConstraints (btSoftBody *larg1) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->randomizeConstraints();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_releaseCluster (btSoftBody *larg1, int larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->releaseCluster(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_releaseClusters (btSoftBody *larg1) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->releaseClusters();
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btSoftBody_generateClusters__SWIG_0 (btSoftBody *larg1, int larg2, int larg3) {
  int lresult = (int)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  int arg2 ;
  int arg3 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (int)(arg1)->generateClusters(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btSoftBody_generateClusters__SWIG_1 (btSoftBody *larg1, int larg2) {
  int lresult = (int)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  int arg2 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (int)(arg1)->generateClusters(arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btSoftBody_refine (btSoftBody *larg1, btSoftBody::ImplicitFn *larg2, btScalar larg3, int larg4) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBody::ImplicitFn *arg2 = (btSoftBody::ImplicitFn *) 0 ;
  btScalar arg3 ;
  bool arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = (bool)larg4;
  try {
    (arg1)->refine(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btSoftBody_cutLink__SWIG_0 (btSoftBody *larg1, int larg2, int larg3, btScalar larg4) {
  int lresult = (int)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  int arg2 ;
  int arg3 ;
  btScalar arg4 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (bool)(arg1)->cutLink(arg2,arg3,arg4);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btSoftBody_cutLink__SWIG_1 (btSoftBody *larg1, Node *larg2, Node *larg3, btScalar larg4) {
  int lresult = (int)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  Node *arg2 = (Node *) 0 ;
  Node *arg3 = (Node *) 0 ;
  btScalar arg4 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (bool)(arg1)->cutLink((Node const *)arg2,(Node const *)arg3,arg4);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT int _wrap_btSoftBody_rayTest__SWIG_0 (btSoftBody *larg1, btVector3 *larg2, btVector3 *larg3, btSoftBody::sRayCast *larg4) {
  int lresult = (int)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btSoftBody::sRayCast *arg4 = 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (bool)(arg1)->rayTest((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btSoftBody_setSolver (btSoftBody *larg1, btSoftBody::eSolverPresets::_ *larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBody::eSolverPresets::_ arg2 ;
  
  arg1 = larg1;
  arg2 = *larg2;
  try {
    (arg1)->setSolver(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_predictMotion (btSoftBody *larg1, btScalar larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->predictMotion(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_solveConstraints (btSoftBody *larg1) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->solveConstraints();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_staticSolve (btSoftBody *larg1, int larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->staticSolve(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_solveCommonConstraints (btSoftBody **larg1, int larg2, int larg3) {
  btSoftBody **arg1 = (btSoftBody **) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    btSoftBody::solveCommonConstraints(arg1,arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_solveClusters__SWIG_0 (btAlignedObjectArray< btSoftBody * > *larg1) {
  btAlignedObjectArray< btSoftBody * > *arg1 = 0 ;
  
  arg1 = larg1;
  try {
    btSoftBody::solveClusters((btAlignedObjectArray< btSoftBody * > const &)*arg1);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_integrateMotion (btSoftBody *larg1) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->integrateMotion();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_defaultCollisionHandler__SWIG_0 (btSoftBody *larg1, btCollisionObjectWrapper *larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btCollisionObjectWrapper *arg2 = (btCollisionObjectWrapper *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->defaultCollisionHandler((btCollisionObjectWrapper const *)arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_defaultCollisionHandler__SWIG_1 (btSoftBody *larg1, btSoftBody *larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBody *arg2 = (btSoftBody *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->defaultCollisionHandler(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_setWindVelocity (btSoftBody *larg1, btVector3 *larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btVector3 *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setWindVelocity((btVector3 const &)*arg2);
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btSoftBody_getWindVelocity (btSoftBody *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btVector3 *) &(arg1)->getWindVelocity();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btSoftBody_setSoftBodySolver (btSoftBody *larg1, btSoftBodySolver *larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBodySolver *arg2 = (btSoftBodySolver *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setSoftBodySolver(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btSoftBodySolver *_wrap_btSoftBody_getSoftBodySolver__SWIG_0 (btSoftBody *larg1) {
  btSoftBodySolver * lresult = (btSoftBodySolver *)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBodySolver *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSoftBodySolver *)(arg1)->getSoftBodySolver();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftBodySolver *)0;
  }
}


EXPORT btSoftBodySolver *_wrap_btSoftBody_getSoftBodySolver__SWIG_1 (btSoftBody *larg1) {
  btSoftBodySolver * lresult = (btSoftBodySolver *)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btSoftBodySolver *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSoftBodySolver *)((btSoftBody const *)arg1)->getSoftBodySolver();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftBodySolver *)0;
  }
}


EXPORT btSoftBody *_wrap_btSoftBody_upcast__SWIG_0 (btCollisionObject *larg1) {
  btSoftBody * lresult = (btSoftBody *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btSoftBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSoftBody *)btSoftBody::upcast((btCollisionObject const *)arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftBody *)0;
  }
}


EXPORT btSoftBody *_wrap_btSoftBody_upcast__SWIG_1 (btCollisionObject *larg1) {
  btSoftBody * lresult = (btSoftBody *)0 ;
  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
  btSoftBody *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSoftBody *)btSoftBody::upcast(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftBody *)0;
  }
}


EXPORT void _wrap_btSoftBody_getAabb (btSoftBody *larg1, btVector3 *larg2, btVector3 *larg3) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    ((btSoftBody const *)arg1)->getAabb(*arg2,*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_pointersToIndices (btSoftBody *larg1) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->pointersToIndices();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_indicesToPointers__SWIG_0 (btSoftBody *larg1, int *larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  int *arg2 = (int *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->indicesToPointers((int const *)arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_indicesToPointers__SWIG_1 (btSoftBody *larg1) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->indicesToPointers();
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btSoftBody_rayTest__SWIG_1 (btSoftBody *larg1, btVector3 *larg2, btVector3 *larg3, btScalar *larg4, btSoftBody::eFeature::_ *larg5, int *larg6, int larg7) {
  int lresult = (int)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btScalar *arg4 = 0 ;
  btSoftBody::eFeature::_ *arg5 = 0 ;
  int *arg6 = 0 ;
  bool arg7 ;
  int result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  arg7 = (bool)larg7;
  try {
    result = (int)((btSoftBody const *)arg1)->rayTest((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4,*arg5,*arg6,arg7);
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btSoftBody_initializeFaceTree (btSoftBody *larg1) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->initializeFaceTree();
    
  } catch (...) {
    
  }
}


EXPORT btVector3 *_wrap_btSoftBody_evaluateCom (btSoftBody *larg1) {
  btVector3 * lresult = (btVector3 *)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btVector3 result;
  
  arg1 = larg1;
  try {
    result = ((btSoftBody const *)arg1)->evaluateCom();
    lresult = new btVector3(result);
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT int _wrap_btSoftBody_checkContact (btSoftBody *larg1, btCollisionObjectWrapper *larg2, btVector3 *larg3, btScalar larg4, btSoftBody::sCti *larg5) {
  int lresult = (int)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btCollisionObjectWrapper *arg2 = (btCollisionObjectWrapper *) 0 ;
  btVector3 *arg3 = 0 ;
  btScalar arg4 ;
  btSoftBody::sCti *arg5 = 0 ;
  bool result;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    result = (bool)((btSoftBody const *)arg1)->checkContact((btCollisionObjectWrapper const *)arg2,(btVector3 const &)*arg3,arg4,*arg5);
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btSoftBody_updateNormals (btSoftBody *larg1) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->updateNormals();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_updateBounds (btSoftBody *larg1) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->updateBounds();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_updatePose (btSoftBody *larg1) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->updatePose();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_updateConstants (btSoftBody *larg1) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->updateConstants();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_updateLinkConstants (btSoftBody *larg1) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->updateLinkConstants();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_updateArea__SWIG_0 (btSoftBody *larg1, int larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->updateArea(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_updateArea__SWIG_1 (btSoftBody *larg1) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->updateArea();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_initializeClusters (btSoftBody *larg1) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->initializeClusters();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_updateClusters (btSoftBody *larg1) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->updateClusters();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_cleanupClusters (btSoftBody *larg1) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->cleanupClusters();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_prepareClusters (btSoftBody *larg1, int larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->prepareClusters(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_solveClusters__SWIG_1 (btSoftBody *larg1, btScalar larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->solveClusters(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_applyClusters (btSoftBody *larg1, int larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->applyClusters(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_dampClusters (btSoftBody *larg1) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->dampClusters();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_applyForces (btSoftBody *larg1) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->applyForces();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_PSolve_Anchors (btSoftBody *larg1, btScalar larg2, btScalar larg3) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    btSoftBody::PSolve_Anchors(arg1,arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_PSolve_RContacts (btSoftBody *larg1, btScalar larg2, btScalar larg3) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    btSoftBody::PSolve_RContacts(arg1,arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_PSolve_SContacts (btSoftBody *larg1, btScalar larg2, btScalar larg3) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    btSoftBody::PSolve_SContacts(arg1,arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_PSolve_Links (btSoftBody *larg1, btScalar larg2, btScalar larg3) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btScalar arg2 ;
  btScalar arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    btSoftBody::PSolve_Links(arg1,arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBody_VSolve_Links (btSoftBody *larg1, btScalar larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  btScalar arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    btSoftBody::VSolve_Links(arg1,arg2);
    
  } catch (...) {
    
  }
}


EXPORT btSoftBody::psolver_t _wrap_btSoftBody_getSolver__SWIG_0 (btSoftBody::ePSolver::_ *larg1) {
  btSoftBody::psolver_t lresult = (btSoftBody::psolver_t)0 ;
  btSoftBody::ePSolver::_ arg1 ;
  btSoftBody::psolver_t result;
  
  arg1 = *larg1;
  try {
    result = (btSoftBody::psolver_t)btSoftBody::getSolver(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftBody::psolver_t)0;
  }
}


EXPORT btSoftBody::vsolver_t _wrap_btSoftBody_getSolver__SWIG_1 (btSoftBody::eVSolver::_ *larg1) {
  btSoftBody::vsolver_t lresult = (btSoftBody::vsolver_t)0 ;
  btSoftBody::eVSolver::_ arg1 ;
  btSoftBody::vsolver_t result;
  
  arg1 = *larg1;
  try {
    result = (btSoftBody::vsolver_t)btSoftBody::getSolver(arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftBody::vsolver_t)0;
  }
}


EXPORT int _wrap_btSoftBody_calculateSerializeBufferSize (btSoftBody *larg1) {
  int lresult = (int)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btSoftBody const *)arg1)->calculateSerializeBufferSize();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT char *_wrap_btSoftBody_serialize (btSoftBody *larg1, void *larg2, btSerializer *larg3) {
  char * lresult = (char *)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  void *arg2 = (void *) 0 ;
  btSerializer *arg3 = (btSerializer *) 0 ;
  char *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (char *)((btSoftBody const *)arg1)->serialize(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (char *)0;
  }
}


EXPORT btSoftRigidDynamicsWorld *_wrap_new_btSoftRigidDynamicsWorld__SWIG_0 (btDispatcher *larg1, btBroadphaseInterface *larg2, btConstraintSolver *larg3, btCollisionConfiguration *larg4, btSoftBodySolver *larg5) {
  btSoftRigidDynamicsWorld * lresult = (btSoftRigidDynamicsWorld *)0 ;
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btBroadphaseInterface *arg2 = (btBroadphaseInterface *) 0 ;
  btConstraintSolver *arg3 = (btConstraintSolver *) 0 ;
  btCollisionConfiguration *arg4 = (btCollisionConfiguration *) 0 ;
  btSoftBodySolver *arg5 = (btSoftBodySolver *) 0 ;
  btSoftRigidDynamicsWorld *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  try {
    result = (btSoftRigidDynamicsWorld *)new btSoftRigidDynamicsWorld(arg1,arg2,arg3,arg4,arg5);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftRigidDynamicsWorld *)0;
  }
}


EXPORT btSoftRigidDynamicsWorld *_wrap_new_btSoftRigidDynamicsWorld__SWIG_1 (btDispatcher *larg1, btBroadphaseInterface *larg2, btConstraintSolver *larg3, btCollisionConfiguration *larg4) {
  btSoftRigidDynamicsWorld * lresult = (btSoftRigidDynamicsWorld *)0 ;
  btDispatcher *arg1 = (btDispatcher *) 0 ;
  btBroadphaseInterface *arg2 = (btBroadphaseInterface *) 0 ;
  btConstraintSolver *arg3 = (btConstraintSolver *) 0 ;
  btCollisionConfiguration *arg4 = (btCollisionConfiguration *) 0 ;
  btSoftRigidDynamicsWorld *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    result = (btSoftRigidDynamicsWorld *)new btSoftRigidDynamicsWorld(arg1,arg2,arg3,arg4);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftRigidDynamicsWorld *)0;
  }
}


EXPORT void _wrap_delete_btSoftRigidDynamicsWorld (btSoftRigidDynamicsWorld *larg1) {
  btSoftRigidDynamicsWorld *arg1 = (btSoftRigidDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftRigidDynamicsWorld_debugDrawWorld (btSoftRigidDynamicsWorld *larg1) {
  btSoftRigidDynamicsWorld *arg1 = (btSoftRigidDynamicsWorld *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->debugDrawWorld();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftRigidDynamicsWorld_addSoftBody__SWIG_0 (btSoftRigidDynamicsWorld *larg1, btSoftBody *larg2, short larg3, short larg4) {
  btSoftRigidDynamicsWorld *arg1 = (btSoftRigidDynamicsWorld *) 0 ;
  btSoftBody *arg2 = (btSoftBody *) 0 ;
  short arg3 ;
  short arg4 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    (arg1)->addSoftBody(arg2,arg3,arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftRigidDynamicsWorld_addSoftBody__SWIG_1 (btSoftRigidDynamicsWorld *larg1, btSoftBody *larg2, short larg3) {
  btSoftRigidDynamicsWorld *arg1 = (btSoftRigidDynamicsWorld *) 0 ;
  btSoftBody *arg2 = (btSoftBody *) 0 ;
  short arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->addSoftBody(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftRigidDynamicsWorld_addSoftBody__SWIG_2 (btSoftRigidDynamicsWorld *larg1, btSoftBody *larg2) {
  btSoftRigidDynamicsWorld *arg1 = (btSoftRigidDynamicsWorld *) 0 ;
  btSoftBody *arg2 = (btSoftBody *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->addSoftBody(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftRigidDynamicsWorld_removeSoftBody (btSoftRigidDynamicsWorld *larg1, btSoftBody *larg2) {
  btSoftRigidDynamicsWorld *arg1 = (btSoftRigidDynamicsWorld *) 0 ;
  btSoftBody *arg2 = (btSoftBody *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeSoftBody(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftRigidDynamicsWorld_removeCollisionObject (btSoftRigidDynamicsWorld *larg1, btCollisionObject *larg2) {
  btSoftRigidDynamicsWorld *arg1 = (btSoftRigidDynamicsWorld *) 0 ;
  btCollisionObject *arg2 = (btCollisionObject *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->removeCollisionObject(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btSoftRigidDynamicsWorld_getDrawFlags (btSoftRigidDynamicsWorld *larg1) {
  int lresult = (int)0 ;
  btSoftRigidDynamicsWorld *arg1 = (btSoftRigidDynamicsWorld *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)((btSoftRigidDynamicsWorld const *)arg1)->getDrawFlags();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btSoftRigidDynamicsWorld_setDrawFlags (btSoftRigidDynamicsWorld *larg1, int larg2) {
  btSoftRigidDynamicsWorld *arg1 = (btSoftRigidDynamicsWorld *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setDrawFlags(arg2);
    
  } catch (...) {
    
  }
}


EXPORT btSoftBodyWorldInfo *_wrap_btSoftRigidDynamicsWorld_getWorldInfo__SWIG_0 (btSoftRigidDynamicsWorld *larg1) {
  btSoftBodyWorldInfo * lresult = (btSoftBodyWorldInfo *)0 ;
  btSoftRigidDynamicsWorld *arg1 = (btSoftRigidDynamicsWorld *) 0 ;
  btSoftBodyWorldInfo *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSoftBodyWorldInfo *) &(arg1)->getWorldInfo();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftBodyWorldInfo *)0;
  }
}


EXPORT btSoftBodyWorldInfo *_wrap_btSoftRigidDynamicsWorld_getWorldInfo__SWIG_1 (btSoftRigidDynamicsWorld *larg1) {
  btSoftBodyWorldInfo * lresult = (btSoftBodyWorldInfo *)0 ;
  btSoftRigidDynamicsWorld *arg1 = (btSoftRigidDynamicsWorld *) 0 ;
  btSoftBodyWorldInfo *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSoftBodyWorldInfo *) &((btSoftRigidDynamicsWorld const *)arg1)->getWorldInfo();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftBodyWorldInfo *)0;
  }
}


EXPORT btDynamicsWorldType _wrap_btSoftRigidDynamicsWorld_getWorldType (btSoftRigidDynamicsWorld *larg1) {
  btDynamicsWorldType lresult = (btDynamicsWorldType)0 ;
  btSoftRigidDynamicsWorld *arg1 = (btSoftRigidDynamicsWorld *) 0 ;
  btDynamicsWorldType result;
  
  arg1 = larg1;
  try {
    result = (btDynamicsWorldType)((btSoftRigidDynamicsWorld const *)arg1)->getWorldType();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDynamicsWorldType)0;
  }
}


EXPORT btSoftBodyArray *_wrap_btSoftRigidDynamicsWorld_getSoftBodyArray__SWIG_0 (btSoftRigidDynamicsWorld *larg1) {
  btSoftBodyArray * lresult = (btSoftBodyArray *)0 ;
  btSoftRigidDynamicsWorld *arg1 = (btSoftRigidDynamicsWorld *) 0 ;
  btSoftBodyArray *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSoftBodyArray *) &(arg1)->getSoftBodyArray();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftBodyArray *)0;
  }
}


EXPORT btSoftBodyArray *_wrap_btSoftRigidDynamicsWorld_getSoftBodyArray__SWIG_1 (btSoftRigidDynamicsWorld *larg1) {
  btSoftBodyArray * lresult = (btSoftBodyArray *)0 ;
  btSoftRigidDynamicsWorld *arg1 = (btSoftRigidDynamicsWorld *) 0 ;
  btSoftBodyArray *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSoftBodyArray *) &((btSoftRigidDynamicsWorld const *)arg1)->getSoftBodyArray();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftBodyArray *)0;
  }
}


EXPORT void _wrap_btSoftRigidDynamicsWorld_rayTest (btSoftRigidDynamicsWorld *larg1, btVector3 *larg2, btVector3 *larg3, btCollisionWorld::RayResultCallback *larg4) {
  btSoftRigidDynamicsWorld *arg1 = (btSoftRigidDynamicsWorld *) 0 ;
  btVector3 *arg2 = 0 ;
  btVector3 *arg3 = 0 ;
  btCollisionWorld::RayResultCallback *arg4 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  try {
    ((btSoftRigidDynamicsWorld const *)arg1)->rayTest((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftRigidDynamicsWorld_rayTestSingle (btTransform *larg1, btTransform *larg2, btCollisionObject *larg3, btCollisionShape *larg4, btTransform *larg5, btCollisionWorld::RayResultCallback *larg6) {
  btTransform *arg1 = 0 ;
  btTransform *arg2 = 0 ;
  btCollisionObject *arg3 = (btCollisionObject *) 0 ;
  btCollisionShape *arg4 = (btCollisionShape *) 0 ;
  btTransform *arg5 = 0 ;
  btCollisionWorld::RayResultCallback *arg6 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  arg4 = larg4;
  arg5 = larg5;
  arg6 = larg6;
  try {
    btSoftRigidDynamicsWorld::rayTestSingle((btTransform const &)*arg1,(btTransform const &)*arg2,arg3,(btCollisionShape const *)arg4,(btTransform const &)*arg5,*arg6);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftRigidDynamicsWorld_serialize (btSoftRigidDynamicsWorld *larg1, btSerializer *larg2) {
  btSoftRigidDynamicsWorld *arg1 = (btSoftRigidDynamicsWorld *) 0 ;
  btSerializer *arg2 = (btSerializer *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->serialize(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_delete_btSoftBodySolver (btSoftBodySolver *larg1) {
  btSoftBodySolver *arg1 = (btSoftBodySolver *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btSoftBodySolver::SolverTypes _wrap_btSoftBodySolver_getSolverType (btSoftBodySolver *larg1) {
  btSoftBodySolver::SolverTypes lresult = (btSoftBodySolver::SolverTypes)0 ;
  btSoftBodySolver *arg1 = (btSoftBodySolver *) 0 ;
  btSoftBodySolver::SolverTypes result;
  
  arg1 = larg1;
  try {
    result = (btSoftBodySolver::SolverTypes)((btSoftBodySolver const *)arg1)->getSolverType();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftBodySolver::SolverTypes)0;
  }
}


EXPORT int _wrap_btSoftBodySolver_checkInitialized (btSoftBodySolver *larg1) {
  int lresult = (int)0 ;
  btSoftBodySolver *arg1 = (btSoftBodySolver *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->checkInitialized();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btSoftBodySolver_optimize__SWIG_0 (btSoftBodySolver *larg1, btAlignedObjectArray< btSoftBody * > *larg2, int larg3) {
  btSoftBodySolver *arg1 = (btSoftBodySolver *) 0 ;
  btAlignedObjectArray< btSoftBody * > *arg2 = 0 ;
  bool arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    (arg1)->optimize(*arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBodySolver_optimize__SWIG_1 (btSoftBodySolver *larg1, btAlignedObjectArray< btSoftBody * > *larg2) {
  btSoftBodySolver *arg1 = (btSoftBodySolver *) 0 ;
  btAlignedObjectArray< btSoftBody * > *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->optimize(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBodySolver_copyBackToSoftBodies__SWIG_0 (btSoftBodySolver *larg1, int larg2) {
  btSoftBodySolver *arg1 = (btSoftBodySolver *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->copyBackToSoftBodies(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBodySolver_copyBackToSoftBodies__SWIG_1 (btSoftBodySolver *larg1) {
  btSoftBodySolver *arg1 = (btSoftBodySolver *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->copyBackToSoftBodies();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBodySolver_predictMotion (btSoftBodySolver *larg1, float larg2) {
  btSoftBodySolver *arg1 = (btSoftBodySolver *) 0 ;
  float arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->predictMotion(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBodySolver_solveConstraints (btSoftBodySolver *larg1, float larg2) {
  btSoftBodySolver *arg1 = (btSoftBodySolver *) 0 ;
  float arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->solveConstraints(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBodySolver_updateSoftBodies (btSoftBodySolver *larg1) {
  btSoftBodySolver *arg1 = (btSoftBodySolver *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->updateSoftBodies();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBodySolver_processCollision__SWIG_0 (btSoftBodySolver *larg1, btSoftBody *larg2, btCollisionObjectWrapper *larg3) {
  btSoftBodySolver *arg1 = (btSoftBodySolver *) 0 ;
  btSoftBody *arg2 = (btSoftBody *) 0 ;
  btCollisionObjectWrapper *arg3 = (btCollisionObjectWrapper *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->processCollision(arg2,(btCollisionObjectWrapper const *)arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBodySolver_processCollision__SWIG_1 (btSoftBodySolver *larg1, btSoftBody *larg2, btSoftBody *larg3) {
  btSoftBodySolver *arg1 = (btSoftBodySolver *) 0 ;
  btSoftBody *arg2 = (btSoftBody *) 0 ;
  btSoftBody *arg3 = (btSoftBody *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->processCollision(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBodySolver_setNumberOfPositionIterations (btSoftBodySolver *larg1, int larg2) {
  btSoftBodySolver *arg1 = (btSoftBodySolver *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setNumberOfPositionIterations(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btSoftBodySolver_getNumberOfPositionIterations (btSoftBodySolver *larg1) {
  int lresult = (int)0 ;
  btSoftBodySolver *arg1 = (btSoftBodySolver *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)(arg1)->getNumberOfPositionIterations();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btSoftBodySolver_setNumberOfVelocityIterations (btSoftBodySolver *larg1, int larg2) {
  btSoftBodySolver *arg1 = (btSoftBodySolver *) 0 ;
  int arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->setNumberOfVelocityIterations(arg2);
    
  } catch (...) {
    
  }
}


EXPORT int _wrap_btSoftBodySolver_getNumberOfVelocityIterations (btSoftBodySolver *larg1) {
  int lresult = (int)0 ;
  btSoftBodySolver *arg1 = (btSoftBodySolver *) 0 ;
  int result;
  
  arg1 = larg1;
  try {
    result = (int)(arg1)->getNumberOfVelocityIterations();
    lresult = result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT float _wrap_btSoftBodySolver_getTimeScale (btSoftBodySolver *larg1) {
  float lresult = (float)0 ;
  btSoftBodySolver *arg1 = (btSoftBodySolver *) 0 ;
  float result;
  
  arg1 = larg1;
  try {
    result = (float)(arg1)->getTimeScale();
    lresult = result;
    return lresult;
  } catch (...) {
    return (float)0;
  }
}


EXPORT void _wrap_delete_btSoftBodySolverOutput (btSoftBodySolverOutput *larg1) {
  btSoftBodySolverOutput *arg1 = (btSoftBodySolverOutput *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBodySolverOutput_copySoftBodyToVertexBuffer (btSoftBodySolverOutput *larg1, btSoftBody *larg2, btVertexBufferDescriptor *larg3) {
  btSoftBodySolverOutput *arg1 = (btSoftBodySolverOutput *) 0 ;
  btSoftBody *arg2 = (btSoftBody *) (btSoftBody *)0 ;
  btVertexBufferDescriptor *arg3 = (btVertexBufferDescriptor *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->copySoftBodyToVertexBuffer((btSoftBody const *)arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT btDefaultSoftBodySolver *_wrap_new_btDefaultSoftBodySolver () {
  btDefaultSoftBodySolver * lresult = (btDefaultSoftBodySolver *)0 ;
  btDefaultSoftBodySolver *result = 0 ;
  
  try {
    result = (btDefaultSoftBodySolver *)new btDefaultSoftBodySolver();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btDefaultSoftBodySolver *)0;
  }
}


EXPORT void _wrap_delete_btDefaultSoftBodySolver (btDefaultSoftBodySolver *larg1) {
  btDefaultSoftBodySolver *arg1 = (btDefaultSoftBodySolver *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btSoftBodySolver::SolverTypes _wrap_btDefaultSoftBodySolver_getSolverType (btDefaultSoftBodySolver *larg1) {
  btSoftBodySolver::SolverTypes lresult = (btSoftBodySolver::SolverTypes)0 ;
  btDefaultSoftBodySolver *arg1 = (btDefaultSoftBodySolver *) 0 ;
  btSoftBodySolver::SolverTypes result;
  
  arg1 = larg1;
  try {
    result = (btSoftBodySolver::SolverTypes)((btDefaultSoftBodySolver const *)arg1)->getSolverType();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftBodySolver::SolverTypes)0;
  }
}


EXPORT int _wrap_btDefaultSoftBodySolver_checkInitialized (btDefaultSoftBodySolver *larg1) {
  int lresult = (int)0 ;
  btDefaultSoftBodySolver *arg1 = (btDefaultSoftBodySolver *) 0 ;
  bool result;
  
  arg1 = larg1;
  try {
    result = (bool)(arg1)->checkInitialized();
    lresult = (int)result;
    return lresult;
  } catch (...) {
    return (int)0;
  }
}


EXPORT void _wrap_btDefaultSoftBodySolver_updateSoftBodies (btDefaultSoftBodySolver *larg1) {
  btDefaultSoftBodySolver *arg1 = (btDefaultSoftBodySolver *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->updateSoftBodies();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDefaultSoftBodySolver_optimize__SWIG_0 (btDefaultSoftBodySolver *larg1, btAlignedObjectArray< btSoftBody * > *larg2, int larg3) {
  btDefaultSoftBodySolver *arg1 = (btDefaultSoftBodySolver *) 0 ;
  btAlignedObjectArray< btSoftBody * > *arg2 = 0 ;
  bool arg3 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = (bool)larg3;
  try {
    (arg1)->optimize(*arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDefaultSoftBodySolver_optimize__SWIG_1 (btDefaultSoftBodySolver *larg1, btAlignedObjectArray< btSoftBody * > *larg2) {
  btDefaultSoftBodySolver *arg1 = (btDefaultSoftBodySolver *) 0 ;
  btAlignedObjectArray< btSoftBody * > *arg2 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->optimize(*arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDefaultSoftBodySolver_copyBackToSoftBodies__SWIG_0 (btDefaultSoftBodySolver *larg1, int larg2) {
  btDefaultSoftBodySolver *arg1 = (btDefaultSoftBodySolver *) 0 ;
  bool arg2 ;
  
  arg1 = larg1;
  arg2 = (bool)larg2;
  try {
    (arg1)->copyBackToSoftBodies(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDefaultSoftBodySolver_copyBackToSoftBodies__SWIG_1 (btDefaultSoftBodySolver *larg1) {
  btDefaultSoftBodySolver *arg1 = (btDefaultSoftBodySolver *) 0 ;
  
  arg1 = larg1;
  try {
    (arg1)->copyBackToSoftBodies();
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDefaultSoftBodySolver_solveConstraints (btDefaultSoftBodySolver *larg1, float larg2) {
  btDefaultSoftBodySolver *arg1 = (btDefaultSoftBodySolver *) 0 ;
  float arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->solveConstraints(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDefaultSoftBodySolver_predictMotion (btDefaultSoftBodySolver *larg1, float larg2) {
  btDefaultSoftBodySolver *arg1 = (btDefaultSoftBodySolver *) 0 ;
  float arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    (arg1)->predictMotion(arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDefaultSoftBodySolver_copySoftBodyToVertexBuffer (btDefaultSoftBodySolver *larg1, btSoftBody *larg2, btVertexBufferDescriptor *larg3) {
  btDefaultSoftBodySolver *arg1 = (btDefaultSoftBodySolver *) 0 ;
  btSoftBody *arg2 = (btSoftBody *) (btSoftBody *)0 ;
  btVertexBufferDescriptor *arg3 = (btVertexBufferDescriptor *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->copySoftBodyToVertexBuffer((btSoftBody const *)arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDefaultSoftBodySolver_processCollision__SWIG_0 (btDefaultSoftBodySolver *larg1, btSoftBody *larg2, btCollisionObjectWrapper *larg3) {
  btDefaultSoftBodySolver *arg1 = (btDefaultSoftBodySolver *) 0 ;
  btSoftBody *arg2 = (btSoftBody *) 0 ;
  btCollisionObjectWrapper *arg3 = (btCollisionObjectWrapper *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->processCollision(arg2,(btCollisionObjectWrapper const *)arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btDefaultSoftBodySolver_processCollision__SWIG_1 (btDefaultSoftBodySolver *larg1, btSoftBody *larg2, btSoftBody *larg3) {
  btDefaultSoftBodySolver *arg1 = (btDefaultSoftBodySolver *) 0 ;
  btSoftBody *arg2 = (btSoftBody *) 0 ;
  btSoftBody *arg3 = (btSoftBody *) 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    (arg1)->processCollision(arg2,arg3);
    
  } catch (...) {
    
  }
}


EXPORT btSoftBodyRigidBodyCollisionConfiguration *_wrap_new_btSoftBodyRigidBodyCollisionConfiguration__SWIG_0 (btDefaultCollisionConstructionInfo *larg1) {
  btSoftBodyRigidBodyCollisionConfiguration * lresult = (btSoftBodyRigidBodyCollisionConfiguration *)0 ;
  btDefaultCollisionConstructionInfo *arg1 = 0 ;
  btSoftBodyRigidBodyCollisionConfiguration *result = 0 ;
  
  arg1 = larg1;
  try {
    result = (btSoftBodyRigidBodyCollisionConfiguration *)new btSoftBodyRigidBodyCollisionConfiguration((btDefaultCollisionConstructionInfo const &)*arg1);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftBodyRigidBodyCollisionConfiguration *)0;
  }
}


EXPORT btSoftBodyRigidBodyCollisionConfiguration *_wrap_new_btSoftBodyRigidBodyCollisionConfiguration__SWIG_1 () {
  btSoftBodyRigidBodyCollisionConfiguration * lresult = (btSoftBodyRigidBodyCollisionConfiguration *)0 ;
  btSoftBodyRigidBodyCollisionConfiguration *result = 0 ;
  
  try {
    result = (btSoftBodyRigidBodyCollisionConfiguration *)new btSoftBodyRigidBodyCollisionConfiguration();
    lresult = result;
    return lresult;
  } catch (...) {
    return (btSoftBodyRigidBodyCollisionConfiguration *)0;
  }
}


EXPORT void _wrap_delete_btSoftBodyRigidBodyCollisionConfiguration (btSoftBodyRigidBodyCollisionConfiguration *larg1) {
  btSoftBodyRigidBodyCollisionConfiguration *arg1 = (btSoftBodyRigidBodyCollisionConfiguration *) 0 ;
  
  arg1 = larg1;
  try {
    delete arg1;
    
  } catch (...) {
    
  }
}


EXPORT btCollisionAlgorithmCreateFunc *_wrap_btSoftBodyRigidBodyCollisionConfiguration_getCollisionAlgorithmCreateFunc (btSoftBodyRigidBodyCollisionConfiguration *larg1, int larg2, int larg3) {
  btCollisionAlgorithmCreateFunc * lresult = (btCollisionAlgorithmCreateFunc *)0 ;
  btSoftBodyRigidBodyCollisionConfiguration *arg1 = (btSoftBodyRigidBodyCollisionConfiguration *) 0 ;
  int arg2 ;
  int arg3 ;
  btCollisionAlgorithmCreateFunc *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    result = (btCollisionAlgorithmCreateFunc *)(arg1)->getCollisionAlgorithmCreateFunc(arg2,arg3);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btCollisionAlgorithmCreateFunc *)0;
  }
}




EXPORT btDbvt *_wrap_btSoftBody_m_ndbvt_get (btSoftBody *larg1) {
    btDbvt * lresult = (btDbvt *)0 ;
    btSoftBody *arg1 = (btSoftBody *) 0 ;
  
    arg1 = larg1;
    try {
      return &((arg1)->m_ndbvt);
    } catch (...) {
      return (btDbvt *)0;
    }
  }
 


 EXPORT btDbvt *_wrap_btSoftBody_m_fdbvt_get (btSoftBody *larg1) {
   btDbvt * lresult = (btDbvt *)0 ;
   btSoftBody *arg1 = (btSoftBody *) 0 ;
   
   arg1 = larg1;
   try {
     return &((arg1)->m_fdbvt);
   } catch (...) {
     return (btDbvt *)0;
   }
 }
  
EXPORT btDbvt *_wrap_btSoftBody_m_cdbvt_get (btSoftBody *larg1) {
  btDbvt * lresult = (btDbvt *)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  
  arg1 = larg1;
  try {
    return &((arg1)->m_cdbvt);
  } catch (...) {
    return (btDbvt *)0;
  }
}


  


  const btVector3& btSoftBodyGetNodePosition(const btSoftBody *body, int n) {
    return body->m_nodes[n].m_x;
  }

  void btSoftBodySetNodePosition(btSoftBody *body, int n, const btVector3& pos) {
    body->m_nodes[n].m_x = pos;
  }

  void btSoftBodySetStretch(btSoftBody *body, float val) {
    body->m_materials[0]->m_kLST = val;
  }

  void btSoftBodySetShear(btSoftBody *body, float val) {
    body->m_materials[0]->m_kAST = val;
  }
  
EXPORT btVector3 *_wrap_btSoftBodyGetNodePosition (btSoftBody *larg1, int larg2) {
  btVector3 * lresult = (btVector3 *)0 ;
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  int arg2 ;
  btVector3 *result = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    result = (btVector3 *) &btSoftBodyGetNodePosition((btSoftBody const *)arg1,arg2);
    lresult = result;
    return lresult;
  } catch (...) {
    return (btVector3 *)0;
  }
}


EXPORT void _wrap_btSoftBodySetNodePosition (btSoftBody *larg1, int larg2, btVector3 *larg3) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  int arg2 ;
  btVector3 *arg3 = 0 ;
  
  arg1 = larg1;
  arg2 = larg2;
  arg3 = larg3;
  try {
    btSoftBodySetNodePosition(arg1,arg2,(btVector3 const &)*arg3);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBodySetStretch (btSoftBody *larg1, float larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  float arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    btSoftBodySetStretch(arg1,arg2);
    
  } catch (...) {
    
  }
}


EXPORT void _wrap_btSoftBodySetShear (btSoftBody *larg1, float larg2) {
  btSoftBody *arg1 = (btSoftBody *) 0 ;
  float arg2 ;
  
  arg1 = larg1;
  arg2 = larg2;
  try {
    btSoftBodySetShear(arg1,arg2);
    
  } catch (...) {
    
  }
}



typedef float floatArray;


typedef btVector3 btVector3Array;


  int main() {

    return 0;
  }
  
